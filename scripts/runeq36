# runeq36
#
#     Runeq36 for EQ3/6, Version 8.0a
#     Last revised 09/02/11 by TJW
#
#     The person responsible for this software is:
#
#       Thomas J. Wolery, L-219
#       Lawrence Livermore National Laboratory
#       P.O. Box 808
#       Livermore, CA  94550
#
#       Telephone: (925) 422-5789
#       E-mail: wolery@llnl.gov
#
#-----------------------------------------------------------------------------
#
#     This is a shell script utility to run the following codes:
#
#       EQ3NR: the EQ3/6 speciation solubility code
#       EQ6:   the EQ3/6 reaction-path code.
#
#     This script is written in C-shell UNIX.
#
#     The EQ3NR or EQ6  executable should be in the code directory
#     defined in the environment variable "EQ36CO". The code directory
#     on a UNIX or Linux platform should normally be:
#
#       ~\eq3_6v8.0a\bin
#
#     The EQ36CO variable should be set in your .cshrc file. Note that
#     your .cshrc file will be sourced for the daughter shell which
#     will be created when you execute this script.
#
#     The supporting DATA1 data files should be in the data file
#     directory defined in the environment variable "EQ36DA". The data
#     file  directory on a UNIX platform should normally be:
#
#       ~\eq3_6v8.0a\db
#
#     The EQ36DA variable should be set in your .cshrc file.
#
#     This script processes the specified input files specified.
#     The input file names must have file name extensions of .3i for
#     EQ3NR and .6i or EQ6. The output files will be named after the
#     input file and carry file name extensions as follows:
#
#       EQ3NR:
#         output     3o
#         pickup     3p
#
#       EQ6:
#         output     6o
#         pickup     6p
#         tab        csv or 6t
#         tabx       6tx
#
#     This script is always called as "runeq3" to run EQ3NR or as
#     "runeq6" to run EQ6. To support this, "runeq3" and "runeq6" are
#     normally set up as symbolic links to this script. However, they
#     could be hard links or even copies.
#
#-----------------------------------------------------------------------------
#
#     Unalias rm, mv, cp, ln, and wc. Any aliases will not be effective
#     in the process run by this script. The aliases if any will
#     remain in place outside this script.
#
      unalias rm mv cp ln wc
#
#     Alias wc to include the proper pathname, if possible, in case this
#     isn't in the user's search path.
#
      if ( -e /usr/bin/wc ) then
        alias wc /usr/bin/wc
      else if ( -e /usr/ucb/wc ) then
        alias wc /usr/ucb/wc
      else if ( -e /bin/wc ) then
        alias wc /bin/wc
      endif
#
#-----------------------------------------------------------------------------
#
      unset noclobber
#
#-----------------------------------------------------------------------------
#
#     Test the number of arguments.
#
      if ( $#argv < 2 ) then
        echo "usage: runeq[36] datafilekey inputfile(s)"
        echo "  datafilekeys = cmp, sup, hmw, pit, and so forth"
        echo "  Input files must end in .3i or .6i"
        exit 1
      endif
#
#-----------------------------------------------------------------------------
#
      echo " Running $0"
      echo ""
#
#-----------------------------------------------------------------------------
#
#     Get the code directory from the environment variable EQ36CO.
#
      set xcodir=`env | grep EQ36CO`
      if !( $xcodir =~ "") then
        set codir=$EQ36CO
      else
        echo " "
        echo " * Error- The EQ36CO environment variable is not set."
        echo "       This is normally set in your .cshrc file."
        echo "       Please refer to the installation instructions."
        exit 1
      endif
      unset xcodir
#
#     Get the data file directory from the environment variable EQ36DA.
#
      set xdadir=`env | grep EQ36DA`
      if !( $xdadir =~ "") then
        set dadir=$EQ36DA
      else
        echo " "
        echo " * Error- The EQ36DA environment variable is not set."
        echo "       This is normally set in your .cshrc file."
        echo "       Please refer to the installation instructions."
        exit 1
      endif
      unset xdadir
#
#-----------------------------------------------------------------------------
#
#     Get the generic code name (EQ3NR or EQ6).
#
      set za0=$0
      set za=$za0:t
      unset za0
      if ( $za =~ runeq3 ) then
        set gcode=eq3nr
        set ucode=EQ3NR
      else if ( $za =~ runeq6 ) then
        set gcode=eq6
        set ucode=EQ6
      else if ( $za =~ runeq36 ) then
        echo " "
        echo ' * Error- You must call this script as "runeq3" or "runeq6".'
        exit 1
      else
        echo " "
        echo " * Error- Don't recognize what kind of code to run."
        echo "        This script was called as "$za"."
        echo '        It must be called as "runeq3" or "runeq6".'
        exit 1
      endif
      echo "  Generic code name is $ucode."
#
#-----------------------------------------------------------------------------
#
#     Get the EQ3NR or EQ6 executable code.
#
      echo "  The code directory is "$codir
      if !( -d $codir) then
        echo " "
        echo " * Error- The code directory doesn't exist. Don't know where"
        echo "       to find the EQ3NR and EQ6 executables."
        exit 1
      endif
#
      echo ""
      set eqcode=$codir/$gcode
      rm -f $codir/${eqcode}*.trace >& /dev/null
#
      if !( -e $eqcode ) then
        echo "  Don't have an executable named {$gcode} in the code directory"
        exit 1
      endif
#
      echo "  The executable file is "$eqcode:t
#
#-----------------------------------------------------------------------------
#
#     Identify the activity coefficient model type to which the data1
#     file corresponds. This is determined by checking the data file
#     key against a list of known keys. If no match is found, this
#     script will not be able to avoid calling EQ3NR or EQ6 in cases
#     of mismatches between data file and activity coefficient option
#     specified on the input file. EQ3NR or EQ6 will of course note
#     the mismatch.
#
      set dfkey=$argv[1]
      shift
#
      if ( $dfkey =~ dav ) then
        set iopg1d = -1
      else if ( $dfkey =~ com ) then
        set iopg1d = 0
      else if ( $dfkey =~ cmp ) then
        set iopg1d = 0
      else if ( $dfkey =~ ymp ) then
        set iopg1d = 0
      else if ( $dfkey =~ cm1 ) then
        set iopg1d = 0
      else if ( $dfkey =~ cm2 ) then
        set iopg1d = 0
      else if ( $dfkey =~ cm3 ) then
        set iopg1d = 0
      else if ( $dfkey =~ alt ) then
        set iopg1d = 0
      else if ( $dfkey =~ sup ) then
        set iopg1d = 0
      else if ( $dfkey =~ nea ) then
        set iopg1d = 0
      else if ( $dfkey =~ cod ) then
        set iopg1d = 0
      else if ( $dfkey =~ chv ) then
        set iopg1d = 0
      else if ( $dfkey =~ cv1 ) then
        set iopg1d = 0
      else if ( $dfkey =~ cv2 ) then
        set iopg1d = 0
      else if ( $dfkey =~ cv3 ) then
        set iopg1d = 0
      else if ( $dfkey =~ phr ) then
        set iopg1d = 0
      else if ( $dfkey =~ skb ) then
        set iopg1d = 0
      else if ( $dfkey =~ wat ) then
        set iopg1d = 0
      else if ( $dfkey =~ bdt ) then
        set iopg1d = 0
      else if ( $dfkey =~ pit ) then
        set iopg1d = 1
      else if ( $dfkey =~ pt1 ) then
        set iopg1d = 1
      else if ( $dfkey =~ pt2 ) then
        set iopg1d = 1
      else if ( $dfkey =~ pt3 ) then
        set iopg1d = 1
      else if ( $dfkey =~ hmw ) then
        set iopg1d = 1
      else if ( $dfkey =~ ypf ) then
        set iopg1d = 1
      else if ( $dfkey =~ fmt ) then
        set iopg1d = 1
      else if ( $dfkey =~ ppz ) then
        set iopg1d = 1
      else if ( $dfkey =~ pze ) then
        set iopg1d = 1
      else if ( $dfkey =~ fwe ) then
        set iopg1d = 1
      else if ( $dfkey =~ gmo ) then
        set iopg1d = 1
      else if ( $dfkey =~ smw ) then
        set iopg1d = 1
      else if ( $dfkey =~ ub0 ) then
        set iopg1d = 1
      else if ( $dfkey =~ ubr ) then
        set iopg1d = 1
      else
        echo " "
        echo " * Note- Don't recognize the data file key "\"${dfkey}\".
        echo "        Won't be able to screen out possible mismatches"
        echo "        between the data file and the input file or files."
        set iopg1d = 999
      endif
#
#-----------------------------------------------------------------------------
#
#     Does the data file directory exist?
#
      if ( -d $dadir ) then
        echo "  The data file directory is "$dadir
      else
        echo " "
        echo " * Error- The data file directory "$dadir
        echo "        doesn't exist."
        exit 1
      endif
#
#-----------------------------------------------------------------------------
#
#     Get the appropriate data1 file. Look in the data file directory
#     in the following order until a file is found:
#
#       data1.dfkey     (dfkey = three-character string)
#
#     where name = eq3nr or eq6.
#
      rm -f data1 >& /dev/null
      set datafi=$dadir/data1.$dfkey
#
      if ( -e $datafi ) then
        echo "  The data file is" $datafi:t
      else
        echo " "
        echo " * Error- Can't find a version of the data file"
        echo "        in the data file directory."
        exit 1
      endif
#
      ln -s $datafi data1
#
#-----------------------------------------------------------------------------
#
      if ( $#argv == 0 ) then
        echo " "
        echo " * Error- No input files are specified."
        exit 1
      endif
#
      echo "  Have "$#argv" input files to process."
      echo ""
      echo ------------------------------------
#
#-----------------------------------------------------------------------------
#
#     Set counter for input files run without generating any EQ3NR or EQ6
#     error messages.
#
      @ nfrun = 0
      set ifrun=/usr/tmp/ifrun$$
#
#     Set counter for input files which require a different kind of
#     data file.
#
      @ nfindf = 0
      set ifindf=/usr/tmp/ifindf$$
#
#     Set counter for input files without the correct file name extension.
#     (.3i or .6i).
#
      @ nfwrext = 0
      set ifwrext=/usr/tmp/ifwrext$$
#
#     Set counter for input files for which EQ3NR or EQ6 error messages are
#     generated.
#
      @ nferr = 0
      set iferr=/usr/tmp/iferr$$
#
#     Set counter for input files which don't exist.
#
      @ nfnoex = 0
      set ifnoex=/usr/tmp/ifnoex$$
#
#-----------------------------------------------------------------------------
#
      rm -f inputs >&/dev/null
      rm -f output > &/dev/null
      rm -f pickup > &/dev/null
      if ( $gcode =~ eq6 ) then
        rm -f tab > &/dev/null
        rm -f tabs > &/dev/null
        rm -f tabx > &/dev/null
      endif
#
#-----------------------------------------------------------------------------
#
#     Loop on input files.
#
      foreach ff ($*)
#
        set fn=$ff:t
        set fe=$fn:e
#
#       Check the file name extension against the code.
#
        set extchk=true
        if ( $gcode =~ eq3nr && $fe != 3i) then
          echo " "
          echo " * Error- Can't run EQ3NR on input file "$ff
          echo "       because it doesn't have a .3i file name extension."
          if ( $fe =~ 6i) echo "       It's an EQ6 input file."
          @ nfwrext = $nfwrext + 1
          echo "     "$ff >> $ifwrext
          set extchk=false
        endif
#
        if ( $gcode =~ eq6 && $fe != 6i) then
          echo " "
          echo " * Error- Can't run EQ6 on input file "$ff
          echo "       because it doesn't have a .6i file name extension."
          if ( $fe =~ 3i) echo "       It's an EQ3NR input file."
          @ nfwrext = $nfwrext + 1
          echo "     "$ff >> $ifwrext
          set extchk=false
        endif
#
        if ( $extchk =~ true ) then
#
#         Does the input file exist?
#
          if ( -e $ff ) then
            rm -f input >& /dev/null
#
#           Is the input file in "W" or "D" format?
#
            set fm=$fn:r
            set ft=/tmp/$fm.tmp$$
            grep '^|' $ff > $ft
            set wclout=`wc -l $ft`
            @ barlines=$wclout[1]
            unset wclout
            rm -f $ft >& /dev/null
            set format=W
            if ( $barlines >= 10) then
              set format=D
            endif
#
#           Determine the activity coefficient model type specified on
#           the input file. Find the EQ3NR or EQ6 input line defining
#           the iopg(1) flag.
#
            @ iopg1 = 999
            if ( $format =~ W) then
#
#             Find the input file line containing the iopg1 flag.
#
              set iopgline=`grep "iopg1-10=" $ff`
              @ iopglines=`grep "iopg1-10=" $ff | wc -l`
#
              if ( $iopglines == 0 ) then
                echo " "
                echo " * Error- Can't find the iopg1 line on input file "$ff
                exit 1
              endif

              @ iopg1=$iopgline[2]
              if ( $iopg1 << -1 ) @iopg1 = 999
              if ( $iopg1 >>  1 ) @iopg1 = 999
            else

              if ( $iopg1 == 999 ) then

                grep "^|  \[x\] ( 0) The B-dot equation" $ff > $ft
                grep "^|  \[X\] ( 0) The B-dot equation" $ff >> $ft
                grep "^|  \[\*\] ( 0) The B-dot equation" $ff >> $ft

                set wclout=`wc -l $ft`
                @ ifl = $wclout[1]
                unset wclout
                rm -f $ft >& /dev/null
                if ( $ifl == 1 ) @ iopg1 = 0
              endif

              if ( $iopg1 == 999 ) then
                grep "^|  \[x\] ( 1) Pitzer's equations" $ff > $ft
                grep "^|  \[X\] ( 1) Pitzer's equations" $ff >> $ft
                grep "^|  \[\*\] ( 1) Pitzer's equations" $ff >> $ft

                set wclout=`wc -l $ft`
                @ ifl = $wclout[1]
                unset wclout
                rm -f $ft >& /dev/null
                if ( $ifl == 1 ) @ iopg1 = 1
              endif

              if ( $iopg1 == 999 ) then
                grep "^|  \[x\] (-1) The Davies equation" $ff > $ft
                grep "^|  \[X\] (-1) The Davies equation" $ff >> $ft
                grep "^|  \[\*\] (-1) The Davies equation" $ff >> $ft

                set wclout=`wc -l $ft`
                @ ifl = $wclout[1]
                unset wclout
                rm -f $ft >& /dev/null
                if ( $ifl == 1 ) @ iopg1 = -1
              endif

            endif
#
#           Check compatibility with the data1 file.
#
            set ok=no
            if ( $iopg1 == -1 ) then
#
#             Davies equation.
#
              if ( $iopg1d == -1 || $iopg1d == 0 ) set ok=yes
            else if ( $iopg1 <= 3 ) then
#
#             All other equations.
#
              if ( $iopg1d == $iopg1 ) set ok=yes
            else
              echo " "
              echo " * Error- Don't recognize iopg1= $iopg1 on the"
              echo "        input file "$ff
            endif
#
            if ( $iopg1 == 999 ) set ok=yes
            if ( $iopg1d == 999 ) set ok=yes
#
            if ( $ok =~ yes ) then
#
              @ tabastxt = 0
              if ( $gcode =~ eq6 ) then
                rm -f $ft >& /dev/null
                grep "TABFILEASTXT" $ff > $ft
                set wclout=`wc -l $ft`
                @ ifl = $wclout[1]
                unset wclout
                if ( $ifl >> 0 ) @ tabastxt = 1
                rm -f $ft >& /dev/null
              endif
#
#             Set up to run the code.
#
              ln -s $ff input
              set fr=$ff:r
              set fn=$fr:t
#
              if ( $gcode =~ eq3nr ) then
                rm -f $fn.3o > & /dev/null
                rm -f $fn.3p > & /dev/null
              else
                rm -f $fn.6o >& /dev/null
                rm -f $fn.6p >& /dev/null
                rm -f $fn.6t >& /dev/null
#
#               Rename an existing .6tx file as the tabx file.
#
                if ( -e $fn.6tx ) mv $fn.6tx tabx
              endif
#
              echo ""
              echo "  Processing input file "$ff
#
#             Run the code.
#
              $eqcode
#
#             Remove some files.
#
              rm -f input >& /dev/null
#
#             Remove any output files that are empty.
#
              if ( -e output ) then
                set wclout=`wc -l output`
                @ fsize=$wclout[1]
                unset wclout
                if ( $fsize == 0 ) rm -f output
                unset fsize
              endif
#
              if ( -e pickup ) then
                set wclout=`wc -l pickup`
                @ fsize=$wclout[1]
                unset wclout
                if ( $fsize == 0 ) rm -f pickup
                unset fsize
              endif
#
              if ( $gcode =~ eq6 ) then
                if ( -e tab ) then
                  set wclout=`wc -l tab`
                  @ fsize=$wclout[1]
                  unset wclout
                  if ( $fsize == 0 ) rm -f tab
                  unset fsize
                endif

                if ( -e tabs ) then
                  set wclout=`wc -l tabs`
                  @ fsize=$wclout[1]
                  unset wclout
                  if ( $fsize == 0 ) rm -f tabs
                  unset fsize
                endif

                if ( -e tabx ) then
                  set wclout=`wc -l tabx`
                  @ fsize=$wclout[1]
                  unset wclout
                  if ( $fsize == 0 ) rm -f tabx
                  unset fsize
                endif
              endif
#
#             Check the output file for errors.
#
              set errflg=false
              if ( -e output ) then
                grep " \* error" output > /usr/tmp/errchk$$
                grep " \* Error" output >> /usr/tmp/errchk$$
                grep " \* ERROR" output >> /usr/tmp/errchk$$
                if ( -e /usr/tmp/errchk$$ ) then
                  set wclout=`wc -l /usr/tmp/errchk$$`
                  @ fsize=$wclout[1]
                  unset wclout
                  if ( $fsize != 0 ) set errflg=true
                  unset fsize
                endif
                rm -f /usr/tmp/errchk$$ >& /dev/null
              else
                set errflg=true
              endif
#
              if ( $errflg =~ false ) then
                @ nfrun = $nfrun + 1
                echo "    "$ff >> $ifrun
              else
                @ nferr = $nferr + 1
                echo "    "$ff >> $iferr
                echo " "
                echo " * Warning - "$ucode" has encountered errors in"
                echo "       processing this file. Check the output file"
                echo "       for details."
              endif

              if ( $gcode =~ eq6 ) then
                if ( $errflg =~ false ) then

#                   The run completed successfully, so remove the EQ6 backup
#                   restart files.

                  rm -f bakupa >& /dev/null
                  rm -f bakupb >& /dev/null
                endif
              endif

#
#             Rename the output files.
#
              if ( $gcode =~ eq3nr ) then
                if ( -e output) mv output $fn.3o
                if ( -e pickup) mv pickup $fn.3p
                set fnolist=`echo $fn.3o $fn.3p`
              else
                if ( -e output ) mv output $fn.6o
                if ( -e pickup ) mv pickup $fn.6p
                if ( -e bakupa ) mv bakupa $fn.6ba
                if ( -e bakupb ) mv bakupb $fn.6bb
                if ( -e pickup ) mv pickup $fn.6p
                if ( -e tabx ) mv tabx $fn.6tx

                if ( -e tab ) then
                  if ( $tabastxt == 0) then
                    mv tab $fn.csv
                  else
                    mv tab $fn.6t
                  endif
                endif
#
                if ( $tabastxt == 0) then
                  set fnolist=`echo $fn.6o $fn.6p $fn.6ba $fn.6bb $fn.6tx $fn.csv`
                else
                  set fnolist=`echo $fn.6o $fn.6p $fn.6ba $fn.6bb $fn.6tx $fn.6t`
                endif
              endif
#
              echo ------------------------------------
#
#             List the output files.
#
              echo ""
              echo "  The following output files were written:"
              echo ""
              @ nfnwr = 0
              foreach fno ( $fnolist )
                if ( -e $fno) then
                  echo "    "$fno
                else
                  @ nfnwr = $nfnwr + 1
                endif
              end
              echo ""
#
#             List the normal output files which were not written.
#
              if ( $nfnwr > 0 ) then
                echo ""
                echo "  The following output files were not written:"
                echo ""
                foreach fno ( $fnolist )
                  if !( -e $fno) echo "    "$fno
                end
                echo ""
              endif
              echo ------------------------------------
              unset fnolist
              unset nfnwr
#
            else
              @ nfindf = $nfindf + 1
              echo "    "$ff >> $ifindf
            endif
          else
            @ nfnoex = $nfnoex + 1
            echo "    "$ff >> $ifnoex
          endif
        endif
      end
#
      rm -f data1 >& /dev/null
#
#-----------------------------------------------------------------------------
#
#     Write some statistics.
#
      if ( $nfrun >= 1 ) then
        echo ""
        echo "  The following input files were run without generating"
        echo "  any "$ucode" error messages:"
        echo ""
        cat $ifrun
        echo ""
        echo ------------------------------------
      endif
#
      if ( $nfwrext >= 1 ) then
        echo ""
        echo "  The following input files were not run because they"
        echo "  don't have the correct file name extension:"
        echo ""
        cat $ifwrext
        echo ""
        echo ------------------------------------
      endif
#
      if ( $nfnoex >= 1 ) then
        echo ""
        echo "  The following input files were not run because"
        echo "  they don't exist:"
        echo ""
        cat $ifnoex
        echo ""
        echo ------------------------------------
      endif
#
      if ( $nfindf >= 1 ) then
        echo ""
        echo "  The following input files were not run because"
        echo "  they require an activity coefficient model that isn't"
        echo "  compatible with the specified data file:"
        echo ""
        cat $ifindf
        echo ""
        echo ------------------------------------
      endif
#
      if ( $nferr >= 1 ) then
        echo ""
        echo "  The following input files were run, but "$ucode" error"
        echo "  messages were generated:"
        echo ""
        cat $iferr
        echo ""
        echo ------------------------------------
      endif
#
#-----------------------------------------------------------------------------
#
#     Remove scratch files.
#
      rm -f $ifrun >& /dev/null
      rm -f $ifindf >& /dev/null
      rm -f $iferr >& /dev/null
      rm -f $ifwrext >& /dev/null
      rm -f $ifnoex >& /dev/null
#
      echo "All done"
      if ( $nferr >= 1 ) exit 1
      if ( $nfwrext >= 1 ) exit 1
      if ( $nfnoex >= 1 ) exit 1
      exit 0
#
# End of script
#-----------------------------------------------------------------------------
