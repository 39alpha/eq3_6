      subroutine aaaeqt(usteqt,uveeqt)
c
c     EQPT: EQ3/6 Data File Preprocessor Code
c     EQ3/6 version 8.0a R43a (Patched 10/01/2009)
c
c     Last revised 04/24/02 by TJW
c
c
c     Copyright (c) 1987, 1990-1993, 1995, 1997, 2002 The Regents of
c     the University of California, Lawrence Livermore National
c     Laboratory. All rights reserved.
c
c     This work was produced at the University of California,
c     Lawrence Livermore National Laboratory (UC LLNL) under
c     contract no. W-7405-ENG-48 between the U.S. Department of
c     Energy (DOE) and The Regents of the University of California
c     (University) for the operation of UC LLNL. Copyright is
c     reserved to the University for purposes of controlled
c     dissemination, commercialization through formal licensing,
c     or other disposition under terms of Contract 48; DOE
c     policies, regulations, and orders; and U.S. statutes.
c
c
c                            DISCLAIMER
c
c     This computer code was prepared as an account of work
c     sponsored by an agency of the United States Government.
c     Neither the United States Government nor the University of
c     California nor any of their employees, makes any warranty,
c     express or implied, or assumes any liability or responsibility
c     for the accuracy, completeness, or usefulness of any
c     information, apparatus, product, or process disclosed, or
c     represents that its use would not infringe privately-owned
c     rights. Reference herein to any specific commercial products,
c     process, or service by trade name, trademark, manufacturer,
c     or otherwise, does not necessarily constitute or imply its
c     endorsement, recommendation, or favoring by the United States
c     Government or the University of California. The views and
c     opinions of authors expressed herein do not necessarily state
c     or reflect those of the United States government or the
c     University of California, and shall not be used for
c     advertising or product endorsement purposes.
c
c
c-----------------------------------------------------------------------
c
c     See the readme.txt file that came with this software for further
c     information, including contact information and references.
c
c
c-----------------------------------------------------------------------
c
c     This code is a data file preprocessor for EQ3/6. It reads a
c     primary data file (a DATA0 file) and writes a secondary,
c     unformatted data file (a DATA1 file), which can be read by
c     EQ3NR and EQ6. EQPT conducts a number of checks on the data as
c     it processes it. For example, it checks reactions for mass
c     balance and electrical balance. The code also fits interpolating
c     polynomials to temperature-dependent data that are represented
c     on a DATA0 file by values on a temperature grid. The coefficients
c     of these polynomials are written on the DATA1 file in place of
c     the original gridded data.
c
c     This code requires subroutines from the following EQ3/6 libraries:
c
c       EQLIBU
c
c
c-----------------------------------------------------------------------
c
c     This subroutine is designed to ensure that the copyright statement
c     and legal and other disclaimers appear at the beginning of the
c     concatenated source code for EQPT. Concatenation is normally
c     alphabetical, hence the form of the name. This subroutine returns
c     the stage and version numbers of this computer code.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Input:
c
c       None
c
c     Output:
c
c       usteqt = EQPT stage number
c       uveeqt = EQPT version number
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      character*8 usteqt,uveeqt
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*8 ust,uve
c
c-----------------------------------------------------------------------
c
      data ust /'R43a    '/
      data uve /'8.0a    '/
c
c-----------------------------------------------------------------------
c
      usteqt = ust
      uveeqt = uve
c
      end
      subroutine adalph(alpha,ipbtmx,iz1,iz2,npx2,npx2mx)
c
c     This subroutine assigns standard values of the Pitzer
c     alpha parameters for the npx2-th species pair. The standard
c     values depend on the charge combination.
c
c     This subroutine is called by:
c
c       EQPT/rdpca.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c
c     Principal output:
c
c       nazt   = the number of specified hard core diameters
c       uazp   = array of aqueous species names used to specify
c                  hard core diamters on the data file
c       azero  = array of corresponding hard core diameters
c       insgf  = array of corresponding neutral species
c                  activity coefficient flags
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,npx2mx
c
      integer iz1,iz2,npx2
c
      real(8) alpha(ipbtmx,npx2mx)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,iaz1,iaz2
c
c-----------------------------------------------------------------------
c
c     Assign standard alpha values for the npx2-th species pair,
c     according the charge combination.
c
      iaz1 = abs(iz1)
      iaz2 = abs(iz2)
c
      do i = 1,ipbtmx
        alpha(i,npx2) = 0.
      enddo
c
      if (iaz1.gt.0 .or. iaz2.gt.0) then
        if (iaz1.eq.1 .or. iaz2.eq.1) then
          alpha(1,npx2) = 2.
        else
          alpha(1,npx2) = 1.4
          alpha(2,npx2) = 12.0
        endif
      endif
c
      end
      subroutine artrip(iz1,iz2,iz3,na,nc,nn,n1,n2,n3,
     $ u1,u2,u3,z1,z2,z3)
c
c     This suboutine arranges the members of a species triplet
c     according to the following rules:
c
c       If exactly one neutral is present:
c         neutral, cation, anion
c
c       If exactly two neutrals are present:
c         neutral 1, neutral 1, neutral2
c
c       If two cations are present:
c         cation 1, cation 2, anion
c
c       If two anions are present:
c         anion 1, anion 2, cation
c
c     This suboutine is called by:
c
c       EQPT/rdpz3.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       iz1    = (integer) charge of the first species in a triplet
c       iz2    = (integer) charge of the second species in a triplet
c       iz3    = (integer) charge of the third species in a triplet
c       na     = number of anions in a species triplet
c       nc     = number of cations in a species triplet
c       nn     = number of neutral species in a species triplet
c       u1     = first name in a species triplet
c       u2     = second name in a species triplet
c       u3     = third name in a species triplet
c       z1     = charge of the first species in a triplet
c       z2     = charge of the second species in a triplet
c       z3     = charge of the third species in a triplet
c
c     Principal output:
c
c       none     (u1, u2, u3 are rearranged)
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer iz1,iz2,iz3,na,nc,nn,n1,n2,n3
c
      character(len=24) u1,u2,u3
c
      real(8) z1,z2,z3
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer nu,nx,izx
c
      character(len=24) ux24
c
      real(8) zx
c
c-----------------------------------------------------------------------
c
      if (nn .eq. 3) then
        if (n1.ne.n2 .or. n1.ne.n3) then
c
c         Have the combination nnn'.
c
c         Make sure that the unique neutral is in third place.
c
c         Find the unique neutral.
c
          if (n2 .eq. n3) nu = 1
          if (n1 .eq. n3) nu = 2
          if (n1 .eq. n2) nu = 3
c
          if (nu .eq. 1) then
c
c           The unique neutral is the first species. Switch it
c           with the third one.
c
            ux24 = u1
            u1 = u3
            u3 = ux24
c
            nx = n1
            n1 = n3
            n3 = nx
c
            zx = z1
            z1 = z3
            z3 = zx
c
            izx = iz1
            iz1 = iz3
            iz3 = izx
          elseif (nu .eq. 2) then
c
c           The unique neutral is the second species. Switch it
c           with the third one.
c
            ux24 = u2
            u2 = u3
            u3 = ux24
c
            nx = n2
            n2 = n3
            n3 = nx
c
            zx = z2
            z2 = z3
            z3 = zx
c
            izx = iz2
            iz2 = iz3
            iz3 = izx
          endif
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nn.eq.1 .and. nc.eq.1 .and. na.eq.1) then
c
c       Have the combination nca.
c
c       Make sure that the neutral is in first place.
c
        if (iz2 .eq. 0) then
c
          ux24 = u1
          u1 = u2
          u2 = ux24
c
          nx = n1
          n1 = n2
          n2 = nx
c
          zx = z1
          z1 = z2
          z2 = zx
c
          izx = iz1
          iz1 = iz2
          iz2 = izx
        elseif (iz3 .eq. 0) then
c
          ux24 = u1
          u1 = u3
          u3 = ux24
c
          nx = n1
          n1 = n3
          n3 = nx
c
          zx = z1
          z1 = z3
          z3 = zx
c
          izx = iz1
          iz1 = iz3
          iz3 = izx
        endif
c
c       Make sure that the cation is in second place. It
c       must presently be in second or third place.
c
        if (iz3 .gt. 0) then
c
          ux24 = u2
          u2 = u3
          u3 = ux24
c
          nx = n2
          n2 = n3
          n3 = nx
c
          zx = z2
          z2 = z3
          z3 = zx
c
          izx = iz2
          iz2 = iz3
          iz3 = izx
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nc.eq.2 .and. na.eq.1) then
c
c       Have the combination cc'a.
c
c       Make sure that the anion is in third place.
c
        if (iz1 .lt. 0) then
c
          ux24 = u1
          u1 = u3
          u3 = ux24
c
          nx = n1
          n1 = n3
          n3 = nx
c
          zx = z1
          z1 = z3
          z3 = zx
c
          izx = iz1
          iz1 = iz3
          iz3 = izx
        elseif (iz2 .lt. 0) then
c
          ux24 = u2
          u2 = u3
          u3 = ux24
c
          nx = n2
          n2 = n3
          n3 = nx
c
          zx = z2
          z2 = z3
          z3 = zx
c
          izx = iz2
          iz2 = iz3
          iz3 = izx
        endif
c
c       Put the two cations in alphabetical order.
c
        if (u1(1:24) .gt. u2(1:24)) then
c
          ux24 = u1
          u1 = u2
          u2 = ux24
c
          nx = n1
          n1 = n2
          n2 = nx
c
          zx = z1
          z1 = z2
          z2 = zx
c
          izx = iz1
          iz1 = iz2
          iz2 = izx
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (na.eq.2 .and. nc.eq.1) then
c
c       Have the combination aa'c.
c
C       Make sure that the cation is in third place.
c
        if (iz1 .gt. 0) then
c
          ux24 = u1
          u1 = u3
          u3 = ux24
c
          nx = n1
          n1 = n3
          n3 = nx
c
          zx = z1
          z1 = z3
          z3 = zx
c
          izx = iz1
          iz1 = iz3
          iz3 = izx
        elseif (iz2 .gt. 0) then
c
          ux24 = u2
          u2 = u3
          u3 = ux24
c
          nx = n2
          n2 = n3
          n3 = nx
c
          zx = z2
          z2 = z3
          z3 = zx
c
          izx = iz2
          iz2 = iz3
          iz3 = izx
        endif
c
c       Put the two anions in alphabetical order.
c
        if (u1(1:24) .gt. u2(1:24)) then
c
          ux24 = u1
          u1 = u2
          u2 = ux24
c
          nx = n1
          n1 = n2
          n2 = nx
c
          zx = z1
          z1 = z2
          z2 = zx
c
          izx = iz1
          iz1 = iz2
          iz2 = izx
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      block data bkdeqp
c
c     This is the block data subroutine for EQPT.
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
      end
      subroutine bldspc(iaapr,icapr,iccpr,inapr,incpr,innpr,
     $ in2pr,iaactr,ia2ctr,iccatr,ic2atr,incatr,in2ntr,in3tr,
     $ jassan,jassca,jassne,nat,natmax,naapr,ncapr,nccpr,nnapr,
     $ nncpr,nnnpr,nn2pr,naactr,na2ctr,nncatr,nccatr,nc2atr,
     $ nn2ntr,nn3tr,uaqsp,zaqsp)
c
c     Build index arrays for the pair and triplet combinations of
c     aqueous solute species for use with Pitzer parameters.
c
c     All pairs and triplets are distinct in the sense that the
c     ordering of the members is not relevant; e.g., ca = ac,
c     cc' = c'c, nca = anc = can = cna = acn = nac.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       naapr  = number of aa' pairs
c       ncapr  = number of ca pairs
c       nccpr  = number of cc' pairs
c       nnapr  = number of na pairs
c       nncpr  = number of nc pairs
c       nnnpr  = number of nn' pairs
c       nn2pr  = number of nn pairs
c
c       naactr = number of aa'c triplets
c       na2ctr = number of aac triplets
c       nccatr = number of cc'a triplets
c       nc2atr = number of cca triplets
c       nncatr = number of nca triplets
c       nn3tr = number of nnn triplets
c       nn2ntr = number of nnn' triplets
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c       zaqsp  = array of electrical charages of aqueous species
c
c     Principal output:
c
c       iaapr  = array of indices of species in aa' pairs
c       icapr  = array of indices of species in ca pairs
c       iccpr  = array of indices of species in cc' pairs
c       inapr  = array of indices of species in na pairs
c       incpr  = array of indices of species in nc pairs
c       innpr  = array of indices of species in nn' pairs
c       in2pr  = array of indices of species in nn pairs
c
c       iaactr = array of indices of species in aa'c triplets
c       ia2ctr = array of indices of species in aac triplets
c       iccatr = array of indices of species in cc'a triplets
c       ic2atr = array of indices of species in cca triplets
c       incatr = array of indices of species in nca triplets
c       in3tr = array of indices of species in nnn triplets
c       in2ntr = array of indices of species in nnn' triplets
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer natmax
c
      integer naapr,ncapr,nccpr,nnapr,nncpr,nnnpr,nn2pr,
     $ naactr,na2ctr,nccatr,nc2atr,nncatr,nn2ntr,nn3tr
c
      integer iaapr(2,naapr),icapr(2,ncapr),iccpr(2,nccpr),
     $ inapr(2,nnapr),incpr(2,nncpr),innpr(2,nnnpr),in2pr(nn2pr)
c
      integer iaactr(3,naactr),ia2ctr(2,na2ctr),iccatr(3,nccatr),
     $ ic2atr(2,nc2atr),incatr(3,nncatr),in2ntr(2,nn2ntr),in3tr(nn3tr)
c
      integer jassan,jassca,jassne,nat
c
      character(len=24) uaqsp(natmax)
c
      real*8 zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer, dimension(:), allocatable :: iworka,iworkc,iworkn
c
      character(len=24), dimension(:), allocatable :: uworka,uworkc,
     $ uworkn
c
      integer i,j,k,jn,jc,ja,n,npr
c
c-----------------------------------------------------------------------
c
c     Allocate work arrays.
c
      ALLOCATE(iworkn(jassne))
      ALLOCATE(iworkc(jassca))
      ALLOCATE(iworka(jassan))
c
      ALLOCATE(uworkn(jassne))
      ALLOCATE(uworkc(jassca))
      ALLOCATE(uworka(jassan))
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Build scratch lists for cations, anions, and neutrals.
c     Do not include solvent water or O2(g) in the neutrals list.
c     Do not include e- on the anions list.
c
      jn = 0
      jc = 0
      ja = 0
      do n = 2,nat
        if (zaqsp(n) .eq. 0.) then
          if (uaqsp(n)(1:6) .ne. 'O2(g) ') then
            jn = jn + 1
            uworkn(jn) = uaqsp(n)
            iworkn(jn) = n
          endif
        elseif (zaqsp(n) .gt. 0.) then
          jc = jc + 1
          uworkc(jc) = uaqsp(n)
          iworkc(jc) = n
        else
          if (uaqsp(n)(1:3) .ne. 'e- ') then
            ja = ja + 1
            uworka(ja) = uaqsp(n)
            iworka(ja) = n
          endif
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Construct the index array for ca pairs.
c
      n = 0
      do i = 1,jc
        do j = 1,ja
          n = n + 1
          icapr(1,n) = iworkc(i)
          icapr(2,n) = iworka(j)
        enddo
      enddo
c
c     Construct the index array for cc' pairs (c' != c).
c
      n = 0
      do i = 1,jc
        do j = i + 1,jc
          n = n + 1
c
c         Store the pair in alphabetical order.
c
          if (uworkc(i) .lt. uworkc(j)) then
            iccpr(1,n) = iworkc(i)
            iccpr(2,n) = iworkc(j)
          else
            iccpr(1,n) = iworkc(j)
            iccpr(2,n) = iworkc(i)
          endif
        enddo
      enddo
c
c     Construct the index array for anion-distinct anion pairs.
c     Ignore pairs where an anion is paired with itself, such as
c     Cl-, Cl-, because the associated Pitzer coefficients are
c     either implicitly undefined or explicitly set to zero.
c     Ignore pairs where an anion is paired with itself.
c
      n = 0
      do i = 1,ja
        do j = i + 1,ja
          n = n + 1
c
c         Store the pair in alphabetical order.
c
          if (uworka(i) .lt. uworka(j)) then
            iaapr(1,n) = iworka(i)
            iaapr(2,n) = iworka(j)
          else
            iaapr(1,n) = iworka(j)
            iaapr(2,n) = iworka(i)
          endif
        enddo
      enddo
c
c     Construct the index array for nn pairs.
c
      n = 0
      do i = 1,jn
        n = n + 1
c
c       Store the "pair."
c
        in2pr(n) = iworkn(i)
      enddo
c
c     Construct the index array for nn' pairs.
c
      n = 0
      do i = 1,jn
        do j = i + 1,jn
          n = n + 1
c
c         Store the pair in alphabetical order.
c
          if (uworkn(i) .le. uworkn(j)) then
            innpr(1,n) = iworkn(i)
            innpr(2,n) = iworkn(j)
          else
            innpr(1,n) = iworkn(j)
            innpr(2,n) = iworkn(i)
          endif
        enddo
      enddo
c
c     Construct the index array for nc pairs.
c
      n = 0
      do i = 1,jn
        do j = 1,jc
          n = n + 1
          incpr(1,n) = iworkn(i)
          incpr(2,n) = iworkc(j)
        enddo
      enddo
c
c     Construct the index array for na pairs.
c
      n = 0
      do i = 1,jn
        do j = 1,ja
          n = n + 1
          inapr(1,n) = iworkn(i)
          inapr(2,n) = iworka(j)
        enddo
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Construct the index array for cca triplets. Note that we will
c     generally just use the icapr array whenever the ic2atr array
c     is required.
c
      do n = 1,nc2atr
        ic2atr(1,n) = icapr(1,n)
        ic2atr(2,n) = icapr(2,n)
      enddo
c
c     Construct the index array for aac triplets. Note that we will
c     generally just use the icapr array whenever the ia2ctr array
c     is required.
c
      do n = 1,na2ctr
        ia2ctr(1,n) = icapr(2,n)
        ia2ctr(2,n) = icapr(1,n)
      enddo
c
c     Construct the index array for nnn triplets. Note that we will
c     generally just use the in2pr array whenever the ic2atr array
c     is required.
c
      do n = 1,nn3tr
        in3tr(n) = in2pr(n)
      enddo
c
c     Construct the index array for nnn' triplets. Note that we could
c     just use the innpr array (with some manipulation to account for
c     the fact that there are two triplets nnn' and n'n'n for each pair
c     nn') whenever the in2ntr array is required. See comments above
c     for the ic2atr array. Also note that nn2ntr = 2*nn2pr.
c
      n = 0
      do npr = 1,nn2pr
c
c       Store the two triplet combinations corresponding to a given
c       pair together.
c
        n = n + 1
        in2ntr(1,n) = innpr(1,npr)
        in2ntr(2,n) = innpr(2,npr)
        n = n + 1
        in2ntr(1,n) = innpr(2,npr)
        in2ntr(2,n) = innpr(1,npr)
      enddo
c
c     Construct the index array for cc'a triplets.
c
      n = 0
      do i = 1,jc
        do j = i + 1,jc
          do k = 1,ja
            n = n + 1
c
c           Store the two cations in alphabetical order.
c
            if (uworkc(i) .le. uworkc(j)) then
              iccatr(1,n) = iworkc(i)
              iccatr(2,n) = iworkc(j)
            else
              iccatr(1,n) = iworkc(j)
              iccatr(2,n) = iworkc(i)
            endif
            iccatr(3,n) = iworka(k)
          enddo
        enddo
      enddo
c
c     Construct the index array for aac triplets.
c
      n = 0
      do i = 1,ja
        do j = i + 1,ja
          do k = 1,jc
            n = n + 1
c
c           Store the two anions in alphabetical order.
c
            if (uworka(i) .le. uworka(j)) then
              iaactr(1,n) = iworka(i)
              iaactr(2,n) = iworka(j)
            else
              iaactr(1,n) = iworka(j)
              iaactr(2,n) = iworka(i)
            endif
            iaactr(3,n) = iworkc(k)
          enddo
        enddo
      enddo
c
c     Construct the index array for nca triplets.
c
      n = 0
      do i = 1,jn
        do j = 1,jc
          do k = 1,ja
            n = n + 1
            incatr(1,n) = iworkn(i)
            incatr(2,n) = iworkc(j)
            incatr(3,n) = iworka(k)
          enddo
        enddo
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Deallocate work arrays.
c
      DEALLOCATE(iworka)
      DEALLOCATE(iworkc)
      DEALLOCATE(iworkn)
c
      DEALLOCATE(uworka)
      DEALLOCATE(uworkc)
      DEALLOCATE(uworkn)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine coasst(jassan,jassca,jassne,nat,natmax,uaqsp,zaqsp)
c
c     Get the numbers of aqueous solute cations, anions, and neutral
c     species. These will be used to generate lists of species pairs
c     and triplets for use with Pitzer's equations.
c
c     The fictive redox species aqueous e- and aqueous O2(g), if
c     present, are excluded in computing these totals. So is solvent
c     water.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c       zaqsp  = array of electrical charages of aqueous species
c
c     Principal output:
c
c       jassca = number of aqueous cation species
c       jassan = number of aqueous anion species (excluding aqueous e-)
c       jassne = number of aqueous neutral species (excluding solvent
c                  water and aqeuous O2(g))
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer natmax
c
      integer jassan,jassca,jassne,nat
c
      character(len=24) uaqsp(natmax)
c
      real*8 zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer n
c
c-----------------------------------------------------------------------
c
c     Count the aqueous solute cations, anions, and neutrals. Include
c     in the counts only real solute species.
c
      jassne = 0
      jassca = 0
      jassan = 0
      do n = 2,nat
        if (zaqsp(n) .eq. 0.) then
          if (uaqsp(n)(1:6) .ne. 'O2(g) ') then
            jassne = jassne + 1
          endif
        elseif (zaqsp(n) .gt. 0.) then
          jassca = jassca + 1
        else
          if (uaqsp(n)(1:3) .ne. 'e- ') then
            jassan = jassan + 1
          endif
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine cpcomb(jassan,jassca,jassne,naapr,nat,ncapr,nccpr,
     $ nnapr,nncpr,nnnpr,nn2pr,naactr,na2ctr,nncatr,nccatr,nc2atr,
     $ nn2ntr,nn3tr)
c
c     Compute all the pair and triplet combinations of aqueous
c     solute species for use with Pitzer's equations. parameters.
c
c     All pairs and triplets are distinct in the sense that the
c     ordering of the members is not relevant; e.g., ca = ac,
c     cc' = c'c, nca = anc = can = cna = acn = nac.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       jassca = number of aqueous cation species
c       jassan = number of aqueous anion species (excluding aqueous e-)
c       jassne = number of aqueous neutral species (excluding solvent
c                  water and aqeuous O2(g))
c       nat    = the number of aqueous species
c
c     Principal output:
c
c       naapr  = number of aa' pairs
c       ncapr  = number of ca pairs
c       nccpr  = number of cc' pairs
c       nnapr  = number of na pairs
c       nncpr  = number of nc pairs
c       nnnpr  = number of nn' pairs
c       nn2pr  = number of nn pairs
c
c       naactr = number of aa'c triplets
c       na2ctr = number of aac triplets
c       nccatr = number of cc'a triplets
c       nc2atr = number of cca triplets
c       nncatr = number of nca triplets
c       nn3tr  = number of nnn triplets
c       nn2ntr = number of nnn' triplets
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer jassan,jassca,jassne,nat
c
      integer naapr,ncapr,nccpr,nnapr,nncpr,nnnpr,nn2pr,
     $ naactr,na2ctr,nccatr,nc2atr,nncatr,nn2ntr,nn3tr
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer jn,jc,ja
c
c-----------------------------------------------------------------------
c
      jn = jassne
      jc = jassca
      ja = jassan
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Pair combinations.
c
c     Get the number of ca pairs.
c
      ncapr = jc*ja
c
c     Get the number of cc' pairs.
c
      nccpr = jc*(jc -1)/2
c
c     Get the number of aa' pairs.
c
      naapr = ja*(ja -1)/2
c
c     Get the number of nn pairs.
c
      nn2pr = jn
c
c     Get the number of nn' pairs.
c
      nnnpr = jn*(jn -1)/2
c
c     Get the number of nc pairs.
c
      nncpr = jn*jc
c
c     Get the number of na pairs.
c
      nnapr = jn*ja
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Triplet combinations.
c
c     Get the number of cca triplets.
c
      nc2atr = ncapr
c
c     Get the number of aac triplets.
c
      na2ctr = ncapr
c
c     Get the number of nnn triplets.
c
      nn3tr = nn2pr
c
c     Get the number of nnn' triplets.
c
      nn2ntr = 2*nn2pr
c
c     Get the number of cc'a triplets.
c
      nccatr = nccpr*ja
c
c     Get the number of aa'c triplets.
c
      naactr = naapr*jc
c
c     Get the number of nca triplets.
c
      nncatr = jn*jc*ja
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine elesck(cessi,nbtmx1,nctmax,ncts,nentei,nerr,noutpt,
     $ ns,nttyo,qblkes,qzeres,uessi,usblkf,uspec)
c
c     This subroutine conducts tests on the elemental composition
c     specified for a species. It detects any blank and duplicate
c     element names in the composition and any zero-valued
c     stoichiometric coefficients.
c
c     Note: any blank names are replaced by the string '<blank>'.
c
c     This subroutine is called by:
c
c       EQPT/pcraq.f
c       EQPT/pcrsg.f
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer nbtmx1,nctmax
c
      integer noutpt,nttyo
c
      integer nentei(nctmax)
c
      integer ncts,nerr,ns
c
      logical qblkes,qzeres
c
      character(len=24) uspec(nbtmx1)
      character(len=24) usblkf
      character(len=8) uessi(nctmax)
c
      real(8) cessi(nctmax)
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer j2,j3,j4,n,ncount
c
      integer ilnobl
c
      logical qdupes
c
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Check for blank element names.
c
      qblkes = .false.
      ncount = 0
      do n = 1,ncts
        j3 = ilnobl(uessi(n))
        if (j3 .le. 0) then
          ncount = ncount + 1
          uessi(n) = '<blank>'
        endif
      enddo
c
      if (ncount .gt. 0) then
        j2 = ilnobl(uspec(ns))
        j4 = ilnobl(usblkf)
        write (noutpt,1000) uspec(ns)(1:j2),usblkf(1:j4)
        write (nttyo,1000) uspec(ns)(1:j2),usblkf(1:j4)
 1000   format(/' * Error - (EQPT/elesck) The species ',a,
     $  ' appearing',/7x,'on the data file in the ',a,' superblock',
     $  ' has a specified',/7x,'composition with blank chemical',
     $  ' element names',/7x,'in the following positions:',/)
        do n = 1,ncts
          if (uessi(n)(1:7) .eq. '<blank>') then
            write (ux8,'(i5)') n
            call lejust(ux8)
            j4 = ilnobl(ux8)
            write (noutpt,1010) ux8(1:j4)
            write (nttyo,1010) ux8(1:j4)
 1010       format(9x,a)
          endif
        enddo
        qblkes = .true.
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for a chemical element appearing more than once in the
c     composition.
c
      call nelcck(nctmax,ncts,nentei,nerr,qdupes,uessi)
c
      if (qdupes)  then
        j2 = ilnobl(uspec(ns))
        j4 = ilnobl(usblkf)
        write (noutpt,1040) uspec(ns)(1:j2),usblkf(1:j4)
        write (nttyo,1040) uspec(ns)(1:j2),usblkf(1:j4)
 1040   format(/' * Error - (EQPT/elesck) The species ',a,
     $  ' appearing',/7x,'on the data file in the ',a,' superblock',
     $  ' has a specified',/7x,'elemental composition for which',
     $  ' there is more than one entry',/7x,'for the following',
     $  ' element(s):',/)
        do n = 1,ncts
          if (nentei(n) .gt. 1) then
            write (ux8,'(i5)') nentei(n)
            call lejust(ux8)
            j3 = ilnobl(ux8)
            j4 = ilnobl(uessi(n))
            write (noutpt,1050) uessi(n)(1:j4),ux8(1:j3)
            write (nttyo,1050) uessi(n)(1:j4),ux8(1:j3)
 1050       format(9x,a,' (',a,' entries)')
          endif
        enddo
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for zero-valued stoichiometric coefficients.
c
      qzeres = .false.
      do n = 1,ncts
        if (cessi(n) .eq. 0.) qzeres = .true.
      enddo
c
      if (qzeres) then
        j2 = ilnobl(uspec(ns))
        j4 = ilnobl(usblkf)
        write (noutpt,1080) uspec(ns)(1:j2),usblkf(1:j4)
        write (nttyo,1080) uspec(ns)(1:j2),usblkf(1:j4)
 1080   format(/' * Error - (EQPT/elesck) The species ',a,
     $  ' appearing',/7x,'on the data file in the ',a,' superblock',
     $  ' has an elemental',/7x,'composition with zero-valued',
     $  ' coefficients for the following elements:',/)
        do n = 1,ncts
          if (cessi(n) .eq. 0.) then
            ux8 = uessi(n)
            j3 = ilnobl(ux8)
            write (noutpt,1090) ux8(1:j3)
            write (nttyo,1090) ux8(1:j3)
 1090       format(9x,a)
          endif
        enddo
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 return
      end
      program eqpt
c
c     This is the main program of the EQPT code. Configuration
c     identification, the copyright statement, legal disclaimers,
c     and similar statements are contained in EQPT/aaaeqt.f, the
c     lead-off subroutine in the EQPT source code. A short description
c     of this program is also contained in that subroutine.
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Dimensioning parameters:
c
c       iapxpa = maximum number of interaction coefficients for
c                  computing activity coefficients in solid solutions
c       ibpxpa = maximum number of site-mixing parameters for
c                  computing activity coefficients in solid solutions
c
      integer iapxpa,ibpxpa,iktpar
c
      parameter(iapxpa = 20,ibpxpa = 20)
c
c-----------------------------------------------------------------------
c
c     Array allocation size variables used in EQPT.
c
c       ipch_asv = The order for pressure corrections to enthalpy
c                    functions
c       ipcv_asv = The order for pressure corrections to volume
c                    functions; the maximum order for pressure
c                    corrections to log K and other Gibbs-energy-based
c                    functions is one greater than this
c       nap_asv  = The maximum number of distinct sets of Pitzer alpha
c                    parameters
c       narx_asv = The maximum number of coefficients per temperature
c                    range
c       nat_asv  = The number of aqueous species on the data file
c       nazt_asv = the number of aqeuous species on the data file for
c                    which hard core diameters are specified
c       nbt_asv  = The number of basis species on the data file
c       nct_asv  = The number of chemical elements on the data file
c       ngt_asv  = The number of gas species on the data file
c       nlt_asv  = The number of pure liquids on the data file
c       nmt_asv  = The number of pure minerals on the data file
c       npx2_asv = The number of pairs of species not of the same
c                    charge sign for which Pitzer parameters are
c                    defined; typically, one of the pair is a cation
c                    and the other is an anion, but one or both
c                    species may also be electrically neutral
c       npx3_asv = The number of triplets of species corresponding to
c                    aqueous electrolyte mixtures for which Pitzer
c                    parameters are defined; generally, no more than
c                    two of these may have an electrical charge number
c                    that is postive, negative, or zero
c       ntid_asv = The number of lines in the data file title
c       ntpr_asv = The number of temperature ranges
c       ipbt_asv = The greatest index for a Pitzer beta(n) coefficient
c                     (the first such index is zero); also the number
c                     number of Pitzer alpha coefficients in a set
c       jpfc_asv = The number of coefficients in a function for
c                    representing a Pitzer coefficient
c
c       ndb_asv  = maximum number of distinct points on the temperature
c                    grid; ndb_asv = ntpr_asv*(narx_asv - 1) + 1
c
      integer ipbt_asv,ipch_asv,ipcv_asv,jpfc_asv,narx_asv,nat_asv,
     $ nazt_asv,nbt_asv,nct_asv,ngt_asv,nlt_asv,nmt_asv,npx2_asv,
     $ npx3_asv,ntid_asv,ntpr_asv
c
      integer ndb_asv
c
c-----------------------------------------------------------------------
c
c     Array allocation size variables which are determined in EQPT
c     but only written on the DATA1 file for use by EQ3NR and EQ6.
c
c       ikt_asv  = The maximum number of end-member component species
c                    of any solid solution on the data filen
c       nlat_asv = The number of members in the set of Pitzer lambda
c                    coefficients
c       nmut_asv = The number of members in the set of Pitzer mu
c                    coefficients
c       npt_asv  = The number of phases of all types on the data file
c       nst_asv  = The number of species of all types on the data file
c       nxt_asv  = The number of solid-solution phases on the data file
c
      integer ikt_asv,nap_asv,nlat_asv,nmut_asv,npt_asv,nst_asv,nxt_asv
c
c-----------------------------------------------------------------------
c
c     Global variable declarations.
c
c     Dimensioning variables.
c
      integer iapxmx,ibpxmx,iktmax,ipbtmx,ipchmx,ipcvmx,jpfcmx,narxmx,
     $ natmax,naztmx,nbtmax,nctmax,ngtmax,nltmax,nmtmax,npx2mx,npx3mx,
     $ ntidmx,ntprmx,nxtmax
      integer nbtmx1,nbtmx2,ndbmax
c
c     File unit numbers.
c
      integer ndata0,ndata1,ndat0s,ndat1f,noutpt,nslist,nttyo
c
c     Other variables.
c
      integer, dimension(:), allocatable :: insgf,ipivot,issot,nacdpr,
     $ narxt,nentei,nentri
c
      integer ier,ipch,ipcv,irang,nazt,nat,nbt,nct,ncvaz,ndbptg,ndbptl,
     $ nerr,ngt,nlt,nmt,nmodwr,nsb,nthdt,ntitld,ntprt,nwarn,nxt
c
      logical, dimension(:), allocatable :: qpdaz
c
      logical qelect
c
      character(len=80), dimension(:), allocatable :: utitld
      character(len=24), dimension(:), allocatable :: uaqsp,uazp,
     $ udrsi,ugassp,uliqsp,uminsp,uspec,ussoph
      character(len=24), dimension(:,:), allocatable :: ussosp
      character(len=16), dimension(:), allocatable :: udbval
      character(len=8), dimension(:), allocatable :: uelem,uessi
c
      character(len=16) udbfmt
      character(len=8) uplatc,uplatm,uveeqt,usteqt,uveelu,ustelu
      character(len=8) uakey,uethfl
c
      real(8), dimension(:), allocatable :: atwt,azero,cdrsi,cessi,
     $ mtotr,zaqsp,zchar
      real(8), dimension(:,:), allocatable :: cdrs,cess
c
      real(8) cco2(5)
c
      real(8), dimension(:,:,:), allocatable :: xhfs,xlks,xvfs
      real(8), dimension(:,:,:,:), allocatable :: dhfs,dvfs
c
      real(8), dimension(:,:), allocatable :: adh,adhh,adhv,aphi,bdh,
     $ bdhh,bdhv,bdot,bdoth,bdotv,prehw,presg,xhfe,xlke,xvfe
      real(8), dimension(:,:,:), allocatable :: dadhh,dadhv,dbdhh,
     $ dbdhv,dbdth,dbdtv,dhfe,dvfe
c
      real(8), dimension(:), allocatable :: tmpcmx,xdbval
      real(8), dimension(:,:), allocatable :: apr,avgrid,tempc,tempcs
c
      real(8), dimension(:), allocatable :: tvec,tvecs
      real(8), dimension(:), allocatable :: cof,xvec,yvec
      real(8), dimension(:,:), allocatable :: aamatr,gmmatr
c
      real(8) pcvaz
c
      real(8) eps100,smp100,tdamax,tdamin,tvecmx
c
c-----------------------------------------------------------------------
c
c     Pitzer interaction parameter arrays.
c
      integer naapr,ncapr,nccpr,nnapr,nncpr,nnnpr,nn2pr,
     $ naactr,na2ctr,nccatr,nc2atr,nncatr,nn2ntr,nn3tr
c
      integer, dimension(:), allocatable :: in2pr,in3tr
      integer, dimension(:,:), allocatable :: iaapr,icapr,iccpr,inapr,
     $ incpr,innpr
      integer, dimension(:,:), allocatable :: iaactr,ia2ctr,iccatr,
     $ ic2atr,incatr,in2ntr
c
      integer jassan,jassca,jassne,npx2t,npx3t
c
      integer ncvaa,ncvca,ncvcc,ncvna,ncvnc,ncvnn,ncvn2,
     $ ncvaac,ncvcca,ncvn2n,ncvnca
c
      integer npxca,npxth,npxni,npxnn,npxn2,npxpsi,npxzet,npxn2n
c
      logical, dimension(:), allocatable :: qpdaa,qpdca,qpdcc,qpdna,
     $ qpdnc,qpdnn,qpdn2
c
      logical, dimension(:), allocatable :: qpdaac,qpdcca,qpdnca,qpdn2n
c
      character(len=24), dimension(:,:), allocatable :: upair,uthdtr,
     $ utripl
c
      real(8), dimension(:,:), allocatable :: alpha,alphca,acphi,
     $ amua2c,amuaac,amucca,amuc2a,amunca,amun2n,amun3
      real(8), dimension(:,:,:), allocatable :: abeta,alamaa,alamca,
     $ alamcc,alamna,alamnc,alamnn,alamn2
c
      real(8), dimension(:,:), allocatable :: atheta,apsi
c
      real(8) pcvaa,pcvca,pcvcc,pcvna,pcvnc,pcvnn,pcvn2
c
      real(8) pcvaac,pcvcca,pcvn2n,pcvnca
c
c-----------------------------------------------------------------------
c
cXX
      real*8 apx(iapxpa),bpx(ibpxpa)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,iexec0,itgenf,j,jexec0,jpdblo,jptffl,j2,j3,j4,k,n,
     $ natm1,nch,nco,nmax,npx2,npx2r1,npx2r2,nrecl,nthd,ntpr
c
      integer ilnobl
c
      logical q500fl
c
      character(len=16) uacfst
      character(len=11) utime0,utime1
      character(len=8) ux8,ux8a,ux8b
      character(len=9) udate0,udate1
      character(len=80) uline
c
      real(8) tcpu,texec0,trun,tuser
c
c-----------------------------------------------------------------------
c
      data nrecl /0/
c
c-----------------------------------------------------------------------
c
c     BEGIN_MACHINE_DEPENDENT_CODE
c
c       On some systems, a BLOCK DATA subroutine must be declared in
c       an EXTERNAL statement to assure proper loading. On some other
c       systems, this is not necessary, but neither it is not harmful.
c       On yet some other systems, the EXTERNAL statement below may
c       cause a problem. If so, try commenting it out. If you still
c       have trouble, consult your local system documentation or
c       experiment to find out how to correctly handle a BLOCK DATA
c       subroutine on your system. The EXTERNAL statement below should
c       not cause a problem if you are using a compiler which is fully
c       compliant with the Fortran 90 standard. However, there is
c       no guarantee that it will be adequate to assure correct loading
c       of the BLOCK DATA subroutine.
c
        external bkdeqp
c
c     END_MACHINE_DEPENDENT_CODE
c
c-----------------------------------------------------------------------
c
c     BEGIN_MACHINE_DEPENDENT_CODE
c
c       Define the console output device number. A value of 6 applies
c       in most cases.
c
        data nttyo  /6/
c
c     END_MACHINE_DEPENDENT_CODE
c
c-----------------------------------------------------------------------
c
c     Get time and date at the start of execution. This information
c     will be used for time and date stamping.
c
      call initim(iexec0,jexec0,texec0,noutpt,nttyo,
     $ udate0,utime0)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Disable underflow trapping, if any.
c
      call undflw
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Set file unit numbers to zero.
c
      noutpt = 0
      ndata1 = 0
      ndat1f = 0
      nslist = 0
      ndata0 = 0
      ndat0s = 0
c
c     Open all output files.
c
      call openou(noutpt,nttyo,'output','formatted',nrecl,noutpt)
      call openou(noutpt,nttyo,'data1','unformatted',nrecl,ndata1)
      call openou(noutpt,nttyo,'data1f','formatted',nrecl,ndat1f)
      call openou(noutpt,nttyo,'slist','formatted',nrecl,nslist)
      call openin(noutpt,nttyo,'data0','formatted',ndata0)
      call openou(noutpt,nttyo,'data0s','formatted',nrecl,ndat0s)
c
c     Make a copy of the DATA0 file, stripped of comments.
c
      call stripl(ndata0,ndat0s)
      close(ndata0)
      ndata0 = 0
      rewind ndat0s
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get configuration identification data.
c
      call aaaeqt(usteqt,uveeqt)
      call aaaelu(ustelu,uveelu)
      call platfd(uplatc,uplatm)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write configuration identification data, the copyright statement,
c     and any remaining statements or disclaimers.
c
      i = index(uveeqt,' ') - 1
      j = index(uveeqt,'.') - 1
      k = index(uplatc,' ') - 1
      if (i .le. 0) i = 8
      if (j .le. 0) j = 8
      if (k .le. 0) k = 8
      write (nttyo,1000) uveeqt(1:i),uveeqt(1:j),uveeqt(1:i),
     $ uplatc(1:k)
      write (noutpt,1000) uveeqt(1:i),uveeqt(1:j),uveeqt(1:i),
     $ uplatc(1:k)
 1000 format(/' EQ3/6, Version ',a,' (EQ3/6-V',a,'-REL-V',a,'-',a,')')
c
      i = j
      j = index(usteqt,' ') - 1
      k = index(uplatm,' ') - 1
      if (j .le. 0) j = 8
      if (k .le. 0) k = 8
      write (nttyo,1010) uveeqt(1:i),usteqt(1:j),uplatm(1:k)
      write (noutpt,1010) uveeqt(1:i),usteqt(1:j),uplatm(1:k)
 1010 format(' EQPT Data File Preprocessor Code (EQ3/6-V',a,
     $ '-EQPT-EXE-',a,'-',a,')')
c
      write (noutpt,1020)
      write (nttyo,1020)
 1020 format(' Supported by the following EQ3/6 libraries:')
c
      i = index(uveelu,'.') - 1
      j = index(ustelu,' ') - 1
      if (i .le. 0) i = 8
      if (j .le. 0) j = 8
      write (nttyo,1030) uveelu(1:i),ustelu(1:j),uplatm(1:k)
      write (noutpt,1030) uveelu(1:i),ustelu(1:j),uplatm(1:k)
 1030 format('   EQLIBU (EQ3/6-V',a,'-EQLIBU-LIB-',a,'-',a,')',/)
c
      write (nttyo,1040)
      write (noutpt,1040)
 1040 format(' Copyright (c) 1987, 1990-1993, 1995, 1997, 2002 The',
     $ ' Regents of the',/' University of California, Lawrence',
     $ ' Livermore National Laboratory.',/' All rights reserved.',/)
c
c     Write additional statements and disclaimers.
c
      call prcndi(noutpt,nttyo)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the time and date on the output.
c
      j2 = ilnobl(udate0)
      write(noutpt,1070) utime0,udate0(1:j2)
      write(nttyo,1070) utime0,udate0(1:j2)
 1070 format(' Run',2x,a8,2x,a,//)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the platform's real*8 floating-point parameters.
c
      call flpars(eps100,irang,noutpt,nttyo,smp100)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Initialize array dimension variables.
c
      iapxmx = iapxpa
      ibpxmx = ibpxpa
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write header on the slist file.
c
      write (nslist,1090)
 1090 format(' EQPT Species List (SLIST) File:',//)
c
c     Initialize the cumulative error counter.
c
      nerr = 0
c
c     Initialize the cumulative warning counter.
c
      nwarn = 0
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check the first line of the data file to ensure that the
c     required header is present.
c
      call hdrchk(ndat0s,noutpt,nttyo)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the aqueous species activity coefficient model type
c     (Extended Debye-Huckel, Pitzer, etc.) associated with this
c     data file. This subroutine scans the data file and counts
c     keywords to make the determination.
c
      call gakey(ndat0s,noutpt,nttyo,uakey)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Scan the data file to determine the necessary array dimensions
c     and any corresponding structural information that will be
c     required before "reading" the data file.
c
c     First scan the data file title for embedded data.
c
      call ggridp(ipch_asv,ipcv_asv,itgenf,jpdblo,jpfc_asv,
     $ jptffl,narx_asv,ndat0s,ndb_asv,noutpt,ntid_asv,ntpr_asv,
     $ nttyo,q500fl,uakey)
c
c     Set the number of parameters in a Pitzer alpha set.
c
      ipbt_asv = 1
      if (uakey(1:8) .eq. 'Pitzer  ') ipbt_asv = 2
c
c     Rescan the data file to get other array dimensions.
c     Also get the actual numbers of basis species and chemical
c     elements on the data file.
c
      call gnenb(ipbt_asv,ikt_asv,jpdblo,jpfc_asv,nap_asv,
     $ nat_asv,nazt_asv,nbt_asv,nct_asv,ndat0s,ngt_asv,nlt_asv,
     4 nmt_asv,noutpt,npt_asv,npx2_asv,npx3_asv,nsb,nst_asv,nttyo,
     $ nxt_asv,uakey)
c
      nbt = nbt_asv
      nct = nct_asv
c
      if (nsb .ne. (nct + 1)) then
        write (ux8a,'(i5)') nsb
        call lejust(ux8a)
        j2 = ilnobl(ux8a)
        write (ux8b,'(i5)') nct
        call lejust(ux8b)
        j3 = ilnobl(ux8b)
        write(noutpt,1100) ux8a(1:j2),ux8b(1:j3)
        write(nttyo,1100) ux8a(1:j2),ux8b(1:j3)
 1100   format(/' * Error - (EQPT/eqpt) The number of strict basis',
     $  ' species',/7x,'must be the number of chemical elements plus',
     $  ' one. The number of',/7x,'strict basis species is ',a,',',
     $  ' but the number of chemical elements',/7x,'is ',a,'.')
        stop
      endif
c
      ipbt_asv = 1
      if (uakey(1:8) .eq. 'Pitzer  ') then
c
        ipbt_asv = 2
c
c       The following array allocation variables are only used by
c       EQ3NR and EQ6.
c
        nlat_asv = npx2_asv + npx3_asv
        nmut_asv = npx2_asv + 2*npx3_asv
        nlat_asv = max(1,nlat_asv)
        nmut_asv = max(1,nmut_asv)
      endif
c
      iktmax = ikt_asv
      ipbtmx = ipbt_asv
      ipchmx = ipch_asv
      ipcvmx = ipcv_asv
      jpfcmx = jpfc_asv
      narxmx = narx_asv
      natmax = nat_asv
      naztmx = nazt_asv
      nbtmax = nbt_asv
      nctmax = nct_asv
      ndbmax = ndb_asv
      ngtmax = ngt_asv
      nltmax = nlt_asv
      nmtmax = nmt_asv
      npx2mx = npx2_asv
      npx3mx = npx3_asv
      ntidmx = ntid_asv
      ntprmx = ntpr_asv
      nxtmax = nxt_asv
c
      nbtmx1 = nbtmax + 1
      nbtmx2 = nbtmax + 2
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Allocate the necessary arrays.
c
      ALLOCATE(ipivot(narx_asv))
      ALLOCATE(issot(nxt_asv))
      ALLOCATE(nacdpr(ntpr_asv))
      ALLOCATE(narxt(ntpr_asv))
      ALLOCATE(nentei(nct_asv))
      ALLOCATE(nentri(nbt_asv + 1))
c
      ALLOCATE(qpdaz(nat_asv))
c
      ALLOCATE(uaqsp(nat_asv))
      ALLOCATE(zaqsp(nat_asv))
c
      ALLOCATE(ugassp(ngt_asv))
      ALLOCATE(uliqsp(nlt_asv))
      ALLOCATE(uminsp(nmt_asv))
      ALLOCATE(ussoph(nxt_asv))
c
      ALLOCATE(utitld(ntid_asv))
c
      ALLOCATE(uspec(nbt_asv + 1))
      ALLOCATE(udrsi(nbt_asv + 1))
c
      ALLOCATE(ussosp(ikt_asv,nxt_asv))
c
      ALLOCATE(uelem(nct_asv))
      ALLOCATE(uessi(nct_asv))
c
      ALLOCATE(atwt(nct_asv))
      ALLOCATE(cdrsi(nbt_asv + 1))
      ALLOCATE(cessi(nct_asv))
      ALLOCATE(zchar(nbt_asv + 1))
      ALLOCATE(mtotr(nct_asv))
c
      ALLOCATE(cdrs(nbt_asv + 2,nbt_asv + 1))
      ALLOCATE(cess(nct_asv,nbt_asv + 1))
c
      ALLOCATE(dhfs(narx_asv,ntpr_asv,ipch_asv,nbt_asv + 1))
      ALLOCATE(dvfs(narx_asv,ntpr_asv,ipcv_asv,nbt_asv + 1))
      ALLOCATE(xhfs(narx_asv,ntpr_asv,nbt_asv + 1))
      ALLOCATE(xlks(narx_asv,ntpr_asv,nbt_asv + 1))
      ALLOCATE(xvfs(narx_asv,ntpr_asv,nbt_asv + 1))
c
      ALLOCATE(adh(narx_asv,ntpr_asv))
      ALLOCATE(adhh(narx_asv,ntpr_asv))
      ALLOCATE(adhv(narx_asv,ntpr_asv))
      ALLOCATE(aphi(narx_asv,ntpr_asv))
      ALLOCATE(bdh(narx_asv,ntpr_asv))
      ALLOCATE(bdhh(narx_asv,ntpr_asv))
      ALLOCATE(bdhv(narx_asv,ntpr_asv))
      ALLOCATE(bdot(narx_asv,ntpr_asv))
      ALLOCATE(bdoth(narx_asv,ntpr_asv))
      ALLOCATE(bdotv(narx_asv,ntpr_asv))
      ALLOCATE(prehw(narx_asv,ntpr_asv))
      ALLOCATE(presg(narx_asv,ntpr_asv))
      ALLOCATE(xhfe(narx_asv,ntpr_asv))
      ALLOCATE(xlke(narx_asv,ntpr_asv))
      ALLOCATE(xvfe(narx_asv,ntpr_asv))
c
      ALLOCATE(dadhh(narx_asv,ntpr_asv,ipch_asv))
      ALLOCATE(dbdhh(narx_asv,ntpr_asv,ipch_asv))
      ALLOCATE(dbdth(narx_asv,ntpr_asv,ipch_asv))
      ALLOCATE(dhfe(narx_asv,ntpr_asv,ipch_asv))
c
      ALLOCATE(dadhv(narx_asv,ntpr_asv,ipcv_asv))
      ALLOCATE(dbdhv(narx_asv,ntpr_asv,ipcv_asv))
      ALLOCATE(dbdtv(narx_asv,ntpr_asv,ipcv_asv))
      ALLOCATE(dvfe(narx_asv,ntpr_asv,ipcv_asv))
c
      ALLOCATE(apr(narx_asv,ntpr_asv))
      ALLOCATE(avgrid(narx_asv,ntpr_asv))
      ALLOCATE(tempc(narx_asv,ntpr_asv))
      ALLOCATE(tempcs(narx_asv,ntpr_asv))
      ALLOCATE(tmpcmx(ntpr_asv))
      ALLOCATE(udbval(ndb_asv))
      ALLOCATE(xdbval(ndb_asv))
c
      ALLOCATE(tvec(narx_asv))
      ALLOCATE(tvecs(narx_asv))
      ALLOCATE(cof(narx_asv))
      ALLOCATE(xvec(narx_asv))
      ALLOCATE(yvec(narx_asv))
c
      ALLOCATE(aamatr(narx_asv,narx_asv))
      ALLOCATE(gmmatr(narx_asv,narx_asv))
c
      if (uakey(1:8) .eq. 'SEDH    ') then
        ALLOCATE(uazp(nazt_asv))
        ALLOCATE(azero(nazt_asv))
        ALLOCATE(insgf(nazt_asv))
      endif
c
      if (uakey(1:8) .eq. 'Pitzer  ') then
c
        ALLOCATE(alpha(ipbt_asv,npx2_asv))
        ALLOCATE(abeta(jpfc_asv,0:ipbt_asv,npx2_asv))
        ALLOCATE(acphi(jpfc_asv,npx2_asv))
c
        ALLOCATE(upair(2,npx2_asv))
        ALLOCATE(uthdtr(3,npx3_asv))
        ALLOCATE(utripl(3,npx3_asv))
c
        ALLOCATE(atheta(jpfc_asv,npx3_asv))
        ALLOCATE(apsi(jpfc_asv,npx3_asv))
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write some tallies on the OUTPUT file.
c
      write (noutpt,1120) nct,nbt
      write (nslist,1120) nct,nbt
 1120 format(11x,'Number of elements = ',i5,
     $ /11x,'Number of basis species = ',i5,/)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the header on the DATA1 and DATA1f files. This begins with
c     the string 'data1' at the top of the files, followed by the
c     keystring for the type of aqueous species activity coefficient
c     model, and the array dimensions necessary to read the rest of
c     the DATA1 file.
c
      call wrhdr(ikt_asv,ipch_asv,ipcv_asv,jpfc_asv,nap_asv,
     $ narx_asv,nat_asv,nbt_asv,nct_asv,ndata1,ndat1f,ngt_asv,
     $ nlat_asv,nlt_asv,nmt_asv,nmut_asv,npt_asv,nst_asv,ntid_asv,
     $ ntpr_asv,nxt_asv,uakey)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the data file title on the various output files. Determine
c     certain embedded options apart from those that set dimensioning
c     parameters.
c
      ntitld = ntid_asv
      call rdwttl(ipch,ipcv,jpdblo,jpfcmx,jptffl,narxt,ndata1,
     $ ndat0s,ndat1f,noutpt,nslist,ntitld,ntidmx,ntprmx,ntprt,nttyo,
     $ uakey,utitld)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the miscellaneous parameters (write them after the chemical
c     elements block). Write the nominal temperature limits and the
c     upper limits of the temperature ranges here, however.
c
      call rdpar(adh,adhh,adhv,aphi,bdh,bdhh,bdhv,bdot,bdoth,
     $ bdotv,cco2,dadhh,dadhv,dbdhh,dbdhv,dbdth,dbdtv,dhfe,dvfe,
     $ ipch,ipchmx,ipcv,ipcvmx,itgenf,nacdpr,narxmx,narxt,ndat0s,
     $ ndbmax,ndbptg,ndbptl,nerr,noutpt,ntprmx,ntprt,nttyo,nwarn,
     $ prehw,presg,q500fl,tdamax,tdamin,tempc,uakey,udbfmt,udbval,
     $ xdbval,xhfe,xlke,xvfe)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read and write the element data.
c
      call rdwele(atwt,nch,nco,nct,nctmax,ndata1,ndat0s,ndat1f,
     $ nerr,noutpt,nslist,nttyo,uelem)
c
c     Check the element names for uniqueness.
c
      call neleck(nct,nctmax,nerr,noutpt,nttyo,uelem)
c
      if (nerr .gt. 0) then
        write (ux8,'(i5)') nerr
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1160) ux8(1:j2)
        write (nttyo,1160) ux8(1:j2)
 1160   format(//' ',a,' errors(s) were encountered.',/)
        stop
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Scale the grid temperature values for subsequent interpolation.
c
      do ntpr = 1,ntprt
c
        nmax = narxt(ntpr)
        do n = 1,nmax
          tvec(n) = tempc(n,ntpr)
        enddo
c
c       Calling sequence substitutions:
c         tvec for avx
c         tvecmx for avxmax
c         tvecs for avxs
c
        call scalx1(tvec,tvecmx,tvecs,ier,nmax)
        do n = 1,nmax
          tempcs(n,ntpr) = tvecs(n)
        enddo
        tmpcmx(ntpr) = tvecmx
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Set the interval parameter (nmodwr) for writing species and
c     phase names to nttyo. This is scaled to the number of chemical
c     elements.
c
      if (nct .gt. 50) then
        nmodwr = 20
      elseif (nct .gt. 30) then
        nmodwr = 10
      elseif (nct .gt. 20) then
        nmodwr = 5
      else
        nmodwr = 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Interpolate and write the miscellaneous parameters.
c
      call wrpar(aamatr,adh,adhh,adhv,aphi,apr,avgrid,bdh,bdhh,
     $ bdhv,bdot,bdoth,bdotv,cco2,cof,dadhh,dadhv,dbdhh,dbdhv,dbdth,
     $ dbdtv,dhfe,dvfe,eps100,gmmatr,ipch,ipchmx,ipcv,ipcvmx,ipivot,
     $ narxmx,narxt,ndata1,ndat1f,noutpt,ntprmx,ntprt,nttyo,presg,
     $ prehw,tdamax,tdamin,tempc,tempcs,tmpcmx,uakey,xhfe,xlke,xvfe,
     $ xvec,yvec)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read and write aqueous species.
c
      call pcraq(aamatr,apr,atwt,avgrid,cdrs,cdrsi,cess,cessi,
     $ cof,dhfe,dhfs,dvfe,dvfs,eps100,gmmatr,ipch,ipchmx,ipcv,ipcvmx,
     $ ipivot,itgenf,mtotr,nacdpr,narxmx,narxt,nat,natmax,nbt,nbtmx1,
     $ nbtmx2,nch,nco,nct,nctmax,ndata1,ndat0s,ndat1f,ndbmax,ndbptg,
     $ ndbptl,nentei,nentri,nerr,nmodwr,noutpt,nsb,nslist,ntprmx,ntprt,
     $ nttyo,nwarn,qelect,q500fl,tempc,tempcs,tmpcmx,uaqsp,udbfmt,
     $ udbval,udrsi,uelem,uessi,uspec,xdbval,xhfe,xhfs,xlke,xlks,xvfe,
     $ xvfs,xvec,yvec,zaqsp,zchar)
c
c     Read and write minerals, liquids, gases.
c
      call pcrsg(aamatr,apr,atwt,avgrid,cdrs,cdrsi,cess,cessi,
     $ cof,dhfe,dhfs,dvfe,dvfs,eps100,gmmatr,ipch,ipchmx,ipcv,ipcvmx,
     $ ipivot,itgenf,mtotr,nacdpr,narxmx,narxt,nat,natmax,nbt,nbtmx1,
     $ nbtmx2,nch,nco,nct,nctmax,ndata1,ndat0s,ndat1f,ndbmax,ndbptg,
     $ ndbptl,nentei,nentri,nerr,ngt,ngtmax,nlt,nltmax,nmodwr,nmt,
     $ nmtmax,noutpt,nsb,nslist,ntprmx,ntprt,nttyo,nwarn,qelect,
     $ q500fl,tempc,tempcs,tmpcmx,udbfmt,udbval,udrsi,uelem,uessi,
     $ ugassp,uliqsp,uminsp,uspec,xdbval,xhfe,xhfs,xlke,xlks,xvfe,
     $ xvfs,xvec,yvec,zchar)
c
c     Read and write solid solutions.
c
      call pcrss(apx,bpx,iapxmx,ibpxmx,iktmax,issot,nbtmx1,
     $ ndata1,ndat0s,ndat1f,nerr,nmodwr,nmt,nmtmax,noutpt,nslist,
     $ nttyo,nxt,nxtmax,uminsp,ussosp,ussoph)
c
c     Make sure that all aqueous species names are unique.
c
      call naqsck(nat,natmax,nerr,noutpt,nttyo,uaqsp)
c
c     Make sure that all pure mineral names are unique.
c
      call nminck(nerr,nmt,nmtmax,noutpt,nttyo,uminsp)
c
c     Make sure that all gas species names are unique.
c
      call ngasck(nerr,ngt,ngtmax,noutpt,nttyo,ugassp)
c
c     Make sure that all solid solution names are unique.
c
      call nssock(nerr,noutpt,nttyo,nxt,nxtmax,ussoph)
c
c     Make sure that all solid solution end-member names are unique
c     within each solid solution.
c
      call nxspck(iktmax,issot,nerr,noutpt,nttyo,nxt,nxtmax,
     $ ussoph,ussosp)
c
c     Validate the end-member names for the solid solutions. Each
c     end-member name must match that of a pure mineral.
c
      call vxspck(iktmax,issot,nerr,nmt,nmtmax,noutpt,nttyo,
     $ nxt,nxtmax,uminsp,ussoph,ussosp)
c
      if (nerr .gt. 0) then
        write (ux8,'(i5)') nerr
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1160) ux8(1:j2)
        write (nttyo,1160) ux8(1:j2)
        stop
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Rewind and position to read aqueous species activity coefficient
c     parameters.
c
      rewind(ndat0s)
c
      if (uakey(1:8) .eq. 'SEDH    ') then
        uacfst = 'bdot parameters '
      elseif (uakey(1:8) .eq. 'Pitzer  ') then
        if (jpdblo .eq. -1) then
          uacfst = 'single-salt para'
        else
          uacfst = 'ca combinations:'
        endif
      else
        j2 = ilnobl(uakey)
        write(noutpt,1200) uakey(1:j2)
        write(nttyo,1200) uakey(1:j2)
 1200   format(/' * Error - (EQPT/eqpt) Unrecognized data file',
     $  ' type = "',a,'".',/7x,'Allowed types are "SEDH" (Simple',
     $  ' Extended Debye-Huckel) and',/7x,'"Pitzer".')
        stop
      endif
c
  270 read(ndat0s,1210,end=280,err=280) uline
 1210 format(a)
      if (uline(1:16) .ne. uacfst(1:16)) go to 270
      go to 290
c
  280 j3 = ilnobl(uacfst)
      write(noutpt,1220) uacfst(1:j3)
      write(nttyo,1220) uacfst(1:j3)
 1220 format(/' * Error - (EQPT/eqpt) End-of-file hit or other read',
     $ /7x,'error occurred while searching for the block header',
     $ /7x,'beginning with "',a,'".')
      stop
c
  290 backspace(ndat0s)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Zero arrays for activity coefficient parameters.
c
      if (uakey(1:8) .eq. 'SEDH    ') then
c
c       Zero the azero array.
c
        call initaz(azero,naztmx)
c
c       Zero the insgf array.
c
        call initiz(insgf,naztmx)
      endif
c
      if (uakey(1:8) .eq. 'Pitzer  ') then
c
c       Zero the alpha array.
c
        nmax = ipbtmx*npx2mx
        call initaz(alpha,nmax)
c
c       Zero the abeta array.
c
        nmax = jpfcmx*(ipbtmx + 1)*npx2mx
        call initaz(abeta,nmax)
c
c       Zero the acphi array.
c
        nmax = jpfcmx*npx2mx
        call initaz(acphi,nmax)
c
c       Zero the atheta and apsi arrays.
c
        nmax = jpfcmx*npx3mx
        call initaz(atheta,nmax)
        call initaz(apsi,nmax)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the SEDH or Pitzer section.
c
      if (uakey(1:8) .eq. 'SEDH    ') then
c
c       Read hard core diameters and related parameters used
c       in the B-dot equation.
c
        call rdazp(azero,insgf,nazt,naztmx,ndat0s,nerr,noutpt,
     $  nttyo,uazp)
      endif
c
      if (uakey(1:8) .eq. 'Pitzer  ') then
c
c       Read Pitzer parameters.
c
        if (jpdblo .eq. -1) then
c
c         Read the data according to the old Pitzer data block
c         organization. There is one superblock for data
c         pertaining to pure aqueous electrolytes, another
c         for mixtures of such with a common ion. Parameters
c         involving neutral aqueous species are handled (awkwardly,
c         but with appropriate checks) within this structure as
c         noted below.
c
c         Read the beta(n) and Cphi parameters.
c           - normally for ca (cation-anion) combinations.
c           - lamda(0) values may be read in place of beta(0) values
c             for nn, nn', nc, and na combinations.
c           - mu values may be read in place of Cphi values for
c             nnn combinations.
c
          call rdpz2(abeta,alpha,acphi,ipbtmx,jpfcmx,nat,natmax,
     $    ndat0s,nerr,noutpt,npx2mx,npx2t,nttyo,nwarn,uaqsp,upair,
     $    zaqsp)
c
c         Read the S-theta and psi parameters.
c           - normally for cc'a and aa'c combinations.
c           - zeta values may be read in place of psi values for
c             nca combinations.
c           - mu values may be read in place of psi values for
c             nnn' and n'n'n combinations.
c
          call rdpz3(apsi,atheta,jpfcmx,nat,natmax,ndat0s,nerr,
     $    noutpt,npx3mx,npx3t,nthdt,nttyo,nwarn,uaqsp,uethfl,uthdtr,
     $    utripl,zaqsp)
        else
c
c         Read the data according to the new Pitzer data block
c         organization. There is one superblock for each allowed
c         species pair or triplet type. Note that for the "new"
c         organization, the E-theta flag is hardwired to 'on'.
c         That is because basically all modern implementations
c         of Pitzer's equations use the theoretically-based
c         higher-order electrostatic term formalism (which is
c         turned on by uethfl = 'on').
c
          uethfl = 'on'
          npx2t = 0
          npx3t = 0
c
c         Read ca (cation-anion) data.
c
          call rdpca(abeta,alpha,acphi,ipbtmx,jpfcmx,nat,natmax,
     $    ndat0s,nerr,noutpt,npxca,npx2mx,npx2t,nttyo,nwarn,uaqsp,
     $    upair,zaqsp)
c
c         Read cc' (cation-different cation) and aa' (anion-
c         different anion) data.
c
          call rdpth(abeta,ipbtmx,jpfcmx,nat,natmax,ndat0s,nerr,
     $    noutpt,npxth,npx2mx,npx2t,nttyo,nwarn,uaqsp,upair,zaqsp)
c
c         Read nc (neutral-cation) and na (neutral-anion) data.
c
          call rdpni(abeta,ipbtmx,jpfcmx,nat,natmax,ndat0s,nerr,
     $    noutpt,npxni,npx2mx,npx2t,nttyo,nwarn,uaqsp,upair,zaqsp)
c
c         Read nn (neutral-same neutral) data.
c
          call rdpn2(abeta,acphi,ipbtmx,jpfcmx,nat,natmax,
     $    ndat0s,nerr,noutpt,npxn2,npx2mx,npx2t,nttyo,nwarn,
     $    uaqsp,upair,zaqsp)
c
c         Read nn'(neutral-different neutral) data.
c
          call rdpnn(abeta,ipbtmx,jpfcmx,nat,natmax,ndat0s,nerr,
     $    noutpt,npxnn,npx2mx,npx2t,nttyo,nwarn,uaqsp,upair,zaqsp)
c
c         Read cc'a (cation-different cation-anion) and aa'c
c         (anion-different anion-cation) data.
c
          call rdppsi(apsi,jpfcmx,nat,natmax,ndat0s,nerr,noutpt,
     $    npxpsi,npx3mx,npx3t,nttyo,nwarn,uaqsp,utripl,zaqsp)
c
c         Read nca (neutral-cation--anion) data.
c
          call rdpzet(apsi,jpfcmx,nat,natmax,ndat0s,nerr,noutpt,
     $    npxzet,npx3mx,npx3t,nttyo,nwarn,uaqsp,utripl,zaqsp)
c
c         Read nnn' (neutral-neutral-different neutral) data.
c
          call rdpn2n(apsi,jpfcmx,nat,natmax,ndat0s,nerr,noutpt,
     $    npxn2n,npx3mx,npx3t,nttyo,nwarn,uaqsp,utripl,zaqsp)
c
c         Copy the theta data into arrays used with the old
c         Pitzer data block organization.
c
          nthdt = npxth
          nthd = 0
          npx2r1 = npxca + 1
          npx2r2 = npxca + npxth
          do npx2 = npx2r1,npx2r2
            nthd = nthd + 1
            uthdtr(1,nthd) = upair(1,npx2)
            uthdtr(2,nthd) = upair(2,npx2)
            uthdtr(3,nthd) = '<dummy>'
            do j = 1,jpfcmx
              atheta(j,nthd) = abeta(j,0,npx2)
            enddo
          enddo
c
        endif
      endif
c
      if (nerr .gt. 0) then
        write (ux8,'(i5)') nerr
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1160) ux8(1:j2)
        write (nttyo,1160) ux8(1:j2)
        stop
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Test and write the SEDH data section of DATA1.
c
      if (uakey(1:8) .eq. 'SEDH    ') then
c
c       Validate the names of aqueous species used to specify azero
c       ('bdot') data. Each such name should correspond to an aqueous
c       species for which there is a species block on the data file.
c       Write a note for any exceptions.
c
        call vazpck(nat,natmax,nazt,naztmx,noutpt,nttyo,
     $  uaqsp,uazp)
c
c       Test and process all azero and insgf ('bdot') data.
c
        call tpraz(nat,natmax,nazt,naztmx,ncvaz,nerr,noutpt,nttyo,
     $  pcvaz,qpdaz,uaqsp,uazp)
c
c       Write the azero and insgf data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvaz
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1230)
 1230   format(//2x,'Aqueous species hard core diameter coverage:')
        natm1 = nat - 1
        write (noutpt,1240) ncvaz,natm1,ux8(1:j2)
 1240   format(/4x,i5,' aqueous species have hard core diameters',
     $  ' specified on the data file',/4x,i5,' aqueous solute',
     $  ' species are present on this file',/4x,'Coverage is ',a,
     $  ' per cent')
c
        if (nerr .gt. 0) then
          write (ux8,'(i5)') nerr
          call lejust(ux8)
          j2 = ilnobl(ux8)
          write (noutpt,1160) ux8(1:j2)
          write (nttyo,1160) ux8(1:j2)
          stop
        endif
c
c       Write hard core diameters and related parameters used
c       for example in the B-dot equation.
c
        call wrazp(azero,insgf,nazt,naztmx,ndata1,ndat1f,
     $  noutpt,nttyo,uazp)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Test and write the Pitzer data section of DATA1.
c
      if (uakey(1:8) .eq. 'Pitzer  ') then
c
c       Count the numbers of aqueous solution cations, anions, and
c       neutrals, excluding any fictive redox species. These will
c       be used to compute the species pairs and triplets relevant
c       to Pitzer parameters.
c
        call coasst(jassan,jassca,jassne,nat,natmax,uaqsp,zaqsp)
c
c       Compute the number of each of the relevant types of these
c       species pairs and triplets (e.g., ca, cc', aa', nc, na, nn,
c       nn', cca, aac, nnn, nnn', and nca).
c
        call cpcomb(jassan,jassca,jassne,naapr,nat,ncapr,nccpr,
     $  nnapr,nncpr,nnnpr,nn2pr,naactr,na2ctr,nncatr,nccatr,nc2atr,
     $  nn2ntr,nn3tr)
c
c       Allocate the associated arrays.
c
        ALLOCATE(alphca(ipbt_asv,ncapr))
c
        ALLOCATE(alamaa(jpfc_asv,0:ipbt_asv,naapr))
        ALLOCATE(alamca(jpfc_asv,0:ipbt_asv,ncapr))
        ALLOCATE(alamcc(jpfc_asv,0:ipbt_asv,nccpr))
        ALLOCATE(alamna(jpfc_asv,0:ipbt_asv,nnapr))
        ALLOCATE(alamnc(jpfc_asv,0:ipbt_asv,nncpr))
        ALLOCATE(alamnn(jpfc_asv,0:ipbt_asv,nnnpr))
        ALLOCATE(alamn2(jpfc_asv,0:ipbt_asv,nn2pr))
c
        ALLOCATE(amua2c(jpfc_asv,na2ctr))
        ALLOCATE(amuc2a(jpfc_asv,nc2atr))
        ALLOCATE(amun3(jpfc_asv,nn3tr))
c
        ALLOCATE(amuaac(jpfc_asv,naactr))
        ALLOCATE(amucca(jpfc_asv,nccatr))
        ALLOCATE(amunca(jpfc_asv,nncatr))
        ALLOCATE(amun2n(jpfc_asv,nn2ntr))
c
        ALLOCATE(qpdaa(naapr))
        ALLOCATE(qpdca(ncapr))
        ALLOCATE(qpdcc(nccpr))
        ALLOCATE(qpdna(nnapr))
        ALLOCATE(qpdnc(nncpr))
        ALLOCATE(qpdnn(nnnpr))
        ALLOCATE(qpdn2(nn2pr))
c
        ALLOCATE(qpdaac(naactr))
        ALLOCATE(qpdcca(nccatr))
        ALLOCATE(qpdnca(nncatr))
        ALLOCATE(qpdn2n(nn2ntr))
c
        ALLOCATE(in2pr(nn2pr))
        ALLOCATE(in3tr(nn3tr))
c
        ALLOCATE(iaapr(2,naapr))
        ALLOCATE(icapr(2,ncapr))
        ALLOCATE(iccpr(2,nccpr))
        ALLOCATE(inapr(2,nnapr))
        ALLOCATE(incpr(2,nncpr))
        ALLOCATE(innpr(2,nnnpr))
c
        ALLOCATE(in2ntr(2,nn2ntr))
        ALLOCATE(ia2ctr(2,na2ctr))
        ALLOCATE(ic2atr(2,nc2atr))
        ALLOCATE(iaactr(3,naactr))
        ALLOCATE(iccatr(3,nccatr))
        ALLOCATE(incatr(3,nncatr))
c
c       Construct index arrays for those pairs and triplets.
c
        call bldspc(iaapr,icapr,iccpr,inapr,incpr,innpr,
     $  in2pr,iaactr,ia2ctr,iccatr,ic2atr,incatr,in2ntr,in3tr,
     $  jassan,jassca,jassne,nat,natmax,naapr,ncapr,nccpr,nnapr,
     $  nncpr,nnnpr,nn2pr,naactr,na2ctr,nncatr,nccatr,nc2atr,
     $  nn2ntr,nn3tr,uaqsp,zaqsp)
c
c       Note on subroutine and array naming for species pairs and
c       triplets associated with Pitzer coefficients:
c
c         ca   is represented by "ca"
c         cc'a is represented by "cca"
c         cca  is represented by "c2a"
c         aa'c is represented by "a2c"
c         aac  is represented by "aac"
c         cc' is represented by "cc"
c
c       Test and process all ca (cation-anion) parameters. This includes
c       the cca (repeated cation-anion) and aac (cation-repeated anion)
c       cases. The basic transformations are:
c
c         beta(n)(ca) -> lambda(n)(ca)   (n = 0,2)
c         Cphi(ca)    -> mu(cca) and mu(aac)
c
        call tprca(abeta,acphi,alamca,alpha,alphca,amua2c,amuc2a,
     $  icapr,ipbtmx,jpfcmx,natmax,na2ctr,ncapr,ncvca,nc2atr,nerr,
     $  noutpt,npx2mx,npx2t,nttyo,nwarn,pcvca,qpdca,uaqsp,upair,zaqsp)
c
c       Test and process the cc' (cation-different cation) parameters.
c       cases. The basic transformation is:
c
c         theta(cc') -> lambda(cc')
c
        call tprcc(alamcc,atheta,iccpr,ipbtmx,jpfcmx,natmax,
     $  nccpr,ncvcc,nerr,noutpt,npx3mx,nthdt,nttyo,nwarn,pcvcc,
     $  qpdcc,uaqsp,uthdtr)
c
c       Test and process the aa' (anion-different anion) parameters.
c       cases. The basic transformation is:
c
c         theta(aa') -> lambda(aa')
c
        call tpraa(alamaa,atheta,iaapr,ipbtmx,jpfcmx,naapr,
     $  natmax,ncvaa,nerr,noutpt,npx3mx,nthdt,nttyo,nwarn,pcvaa,
     $  qpdaa,uaqsp,uthdtr)
c
c       Test and process the nn (repeated-neutral) parameters. This
c       includes the nnn (doubly repeated neutral) cases. Note on
c       subroutine and array naming:
c
c         nn  is represented by "n2"
c         nn' is represented by "nn"
c
c         lambda(nn) -> lambda(nn)
c         mu(nnn)    -> mu(nnn)
c
        call tprn2(abeta,acphi,alamn2,amun3,in2pr,ipbtmx,
     $  jpfcmx,natmax,ncvn2,nerr,nn2pr,nn3tr,noutpt,npx2mx,npx2t,
     $  nttyo,nwarn,pcvn2,qpdn2,uaqsp,upair)
c
c       Test and process the nn' (neutral-different neutral) parameters.
c       See the above note on subroutine and array naming.
c
c         lambda(nn') -> lambda(nn')
c
        call tprnn(abeta,acphi,alamnn,innpr,in2pr,ipbtmx,
     $  jpfcmx,natmax,ncvnn,nerr,nnnpr,nn2pr,noutpt,npx2mx,npx2t,
     $  nttyo,nwarn,pcvnn,qpdnn,qpdn2,uaqsp,upair)
c
c       Test and process the nc (neutral-cation) parameters.
c
c         lambda(nc) -> lambda(nc)
c
        call tprnc(abeta,alamnc,incpr,ipbtmx,jpfcmx,natmax,
     $  ncvnc,nerr,nncpr,noutpt,npx2mx,npx2t,nttyo,nwarn,pcvnc,
     $  qpdnc,uaqsp,upair)
c
c       Test and process the na (neutral-anion) parameters.
c
c         lambda(na) -> lambda(na)
c
        call tprna(abeta,alamna,inapr,ipbtmx,jpfcmx,natmax,
     $  ncvna,nerr,nnapr,noutpt,npx2mx,npx2t,nttyo,nwarn,pcvna,
     $  qpdna,uaqsp,upair)
c
c       Test and process the cc'a (cation-different cation-anion)
c       parameters. Note that mu(cc'a) depends not only on psi(cc'a),
c       but also on mu(cca) and mu(c'c'a), hence indirectly on Cphi(ca)
c       and Cphi(c'a). Note on subroutine and array naming:
c
c         cc'a is represented by "cca"
c         cca  is represented by "c2a"
c
c         psi(cc'a) -> mu(cc'a)
c
        call tprcca(amucca,amuc2a,apsi,icapr,iccatr,ipbtmx,
     $  jpfcmx,natmax,ncapr,nccatr,ncvcca,nc2atr,nerr,noutpt,
     $  npx3mx,npx3t,nttyo,nwarn,pcvcca,qpdca,qpdcca,uaqsp,
     $  utripl,zaqsp)
c
c       Test and process the aa'c (anion-different anion-cation)
c       parameters. Note that mu(aa'c) depends not only on psi(aa'c),
c       but also on mu(aac) and mu(a'a'c), hence indirectly on Cphi(ca)
c       and Cphi(ca'). Note on subroutine and array naming:
c
c         aa'c is represented by "aac"
c         aac  is represented by "a2c"
c
c         psi(aa'c) -> mu(aa'c)
c
        call tpraac(amuaac,amua2c,apsi,iaactr,icapr,ipbtmx,
     $  jpfcmx,naactr,natmax,na2ctr,ncapr,ncvaac,nerr,noutpt,
     $  npx3mx,npx3t,nttyo,nwarn,pcvaac,qpdaac,qpdca,uaqsp,
     $  utripl,zaqsp)
c
c       Test and process the nnn' (repeated neutral-different neutral)
c       parameters. These are not processed with the nn' parameters
c       because there are two mu coefficients (nnn' and n'n'n) for
c       each lambda coefficient (nn'). Note on subroutine and array
c       naming:
c
c         nnn' is represented by "n2n"
c
c         mu(nnn') -> mu(nnn')
c
        call tprn2n(amun2n,apsi,innpr,in2pr,in2ntr,ipbtmx,
     $  jpfcmx,natmax,ncvn2n,nerr,nnnpr,nn2pr,nn2ntr,noutpt,npx3mx,
     $  npx3t,nttyo,nwarn,pcvn2n,qpdnn,qpdn2,qpdn2n,uaqsp,utripl)
c
c       Test and process the nca (neutral-cation-anion) parameters.
c
c         mu(nca) -> mu(nca)
c
        call tprnca(amunca,apsi,inapr,incatr,incpr,ipbtmx,
     $  jpfcmx,natmax,ncvnca,nerr,nnapr,nncatr,nncpr,noutpt,npx3mx,
     $  npx3t,nttyo,nwarn,pcvnca,qpdna,qpdnca,qpdnc,uaqsp,utripl)
c
c
c       What about the following combinations?
c
c         cc     (repeated cation)
c         aa     (repeated neutral)
c         ccc    (doubly repeated cation)
c         aaa    (doubly repeated cation)
c         ccc'   (repeated cation and a distinct cation)
c         aaa'   (repeated anion and a distinct anion)
c         cc'c'' (three distinct cations)
c         aa'a'' (three distinct anions)
c         nn'n'' (three distinct neutrals)
c         ncc'   (neutral and two distinct cations)
c         naa'   (neutral and two distinct anions)
c         nn'c   (two distinct neutrals and a cation)
c         nn'a   (two distinct neutrals and an anion)
c
c       Some (e.g., cc,  aa) are defined to be zero by convention.
c       Others (e.g., cc'c'' and nn'n'') correspond to quaternary
c       or higher mixtures. In any case, they are not used in the
c       normal Pitzer treatment of electrolyte solutions.
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c       Write the cation-anion (ca) data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvca
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1300)
 1300   format(//2x,'Cation-anion (ca) pair coverage:')
        write (noutpt,1310) ncvca,ncapr,ux8(1:j2)
 1310   format(/4x,i5,' pairs have Pitzer parameters specified on',
     $  ' the data file',/4x,i5,' pairs can be constructed from',
     $  ' the species present on this file',/4x,'Coverage is ',a,
     $  ' per cent')
c
c       Write the cation-distinct cation (cc') data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvcc
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1320)
 1320   format(//2x,"Cation-distinct cation (cc') pair coverage:")
        write (noutpt,1310) ncvcc,nccpr,ux8(1:j2)
c
c       Write the anion-distinct anion (aa') data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvaa
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1330)
 1330   format(//2x,"Anion-distinct anion (aa') pair coverage:")
        write (noutpt,1310) ncvaa,naapr,ux8(1:j2)
c
c       Write the repeated-neutral (nn) data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvn2
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1340)
 1340   format(//2x,'Repeated-neutral (nn) pair coverage:')
        write (noutpt,1310) ncvn2,nn2pr,ux8(1:j2)
c
c       Write the neutral-distinct neutral (nn') data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvnn
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1350)
 1350   format(//2x,"Neutral-distinct neutral (nn') pair coverage:")
        write (noutpt,1310) ncvnn,nnnpr,ux8(1:j2)
c
c       Write the neutral-cation (nc) data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvnc
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1360)
 1360   format(//2x,'Neutral-cation (nc) pair coverage:')
        write (noutpt,1310) ncvnc,nncpr,ux8(1:j2)
c
c       Write the neutral-anion (na) data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvna
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1370)
 1370   format(//2x,'Neutral-anion (na) pair coverage:')
        write (noutpt,1310) ncvna,nnapr,ux8(1:j2)
c
c       Write the cation-distinct cation-anion (cc'a) data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvcca
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1380)
 1380   format(//2x,"Cation-distinct cation-anion (cc'a) triplet",
     $  ' coverage:')
        write (noutpt,1390) ncvcca,nccatr,ux8(1:j2)
 1390   format(/4x,i5,' triplets have Pitzer parameters specified on',
     $  ' the data file',/4x,i5,' triplets can be constructed from',
     $  ' the species present on this file',/4x,'Coverage is ',a,
     $  ' per cent')
c
c
c       Write the anion-distinct anion-cation (aa'c) data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvaac
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1400)
 1400   format(//2x,"Anion-distinct anion-cation (aa'c) triplet",
     $  ' coverage:')
        write (noutpt,1390) ncvaac,naactr,ux8(1:j2)
c
c       Write the repeated neutral-distinct neutral (nnn') data
c       summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvn2n
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1410)
 1410   format(//2x,"Repeated neutral-distinct neutral (nnn')",
     $  ' triplet coverage:')
        write (noutpt,1390) ncvn2n,nn2ntr,ux8(1:j2)
c
c       Write the neutral-cation-anion data summary.
c
        ux8 = ' '
        write (ux8,'(f6.2)') pcvnca
        call lejust(ux8)
        j2 = ilnobl(ux8)
        write (noutpt,1420)
 1420   format(//2x,'Neutral-cation-anion (nca) triplet coverage:')
        write (noutpt,1390) ncvnca,nncatr,ux8(1:j2)
c
        if (nerr .gt. 0) then
          write (ux8,'(i5)') nerr
          call lejust(ux8)
          j2 = ilnobl(ux8)
          write (noutpt,1160) ux8(1:j2)
          write (nttyo,1160) ux8(1:j2)
          stop
        endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c       Write Pitzer parameters.
c
        call wrpz23(alphca,alamaa,alamca,alamcc,alamna,alamnc,
     $  alamnn,alamn2,amuaac,amua2c,amucca,amuc2a,amunca,amun2n,
     $  amun3,ipbtmx,iaapr,icapr,iccpr,inapr,incpr,innpr,in2pr,
     $  iaactr,ia2ctr,iccatr,ic2atr,incatr,in2ntr,in3tr,jpdblo,
     $  jpfcmx,natmax,naapr,ncapr,nccpr,nnapr,nncpr,nnnpr,nn2pr,
     $  naactr,na2ctr,nccatr,nc2atr,nncatr,nn2ntr,nn3tr,ndata1,
     $  ndat1f,noutpt,nttyo,uaqsp,uethfl)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      j2 = ilnobl(uakey)
      j3 = ilnobl(utitld(1))
      write (nttyo,1460) uakey(1:j2),utitld(1)(1:j3)
      write (noutpt,1460) uakey(1:j2),utitld(1)(1:j3)
 1460 format(//' Completed processing the ',a,' data file ',a,'.')
      write (noutpt,1470)
      write (nttyo,1470)
 1470 format(//' No errors were encountered.')
      if (nwarn .le. 0) then
        write (noutpt,1480)
        write (nttyo,1480)
 1480   format(/' No warnings were encountered.',//)
      else
        write (ux8,'(i5)') nwarn
        call lejust(ux8)
        j4 = ilnobl(ux8)
        write (noutpt,1490) ux8(1:j4)
        write (nttyo,1490) ux8(1:j4)
 1490   format(/' ',a,' warning(s) were encountered.',//)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get end time and date. Also get the run time. Optionally, on
c     a Unix platform, get the user and cpu times.
c
      call runtim(iexec0,jexec0,texec0,noutpt,nttyo,trun,
     $ tuser,tcpu,udate1,utime1)
c
      j2 = ilnobl(udate0)
      j3 = ilnobl(udate1)
      write (noutpt,1500) utime0,udate0(1:j2),utime1,udate1(1:j3)
      write (nttyo,1500) utime0,udate0(1:j2),utime1,udate1(1:j3)
 1500 format(10x,'Start time = ',a8,2x,a,/12x,
     $ 'End time = ',a8,2x,a)
c
c     Print the run, user, and cpu times.
c
      write (noutpt,1510) trun
      write (nttyo,1510)  trun
 1510 format(/10x,' Run time = ',g10.3,' seconds')
      if (tuser .gt. 0.) then
        write (noutpt,1520) tuser
        write (nttyo,1520)  tuser
 1520   format(10x,'User time = ',g10.3,' seconds')
      endif
      if (tcpu .gt. 0.) then
        write (noutpt,1530) tcpu
        write (nttyo,1530)  tcpu
 1530   format(10x,' Cpu time = ',g10.3,' seconds')
      endif
c
      write (noutpt,1540)
      write (nttyo,1540)
 1540 format(/' Normal exit')
c
c     Clear the IEEE flag for floating-point underflow, if such a
c     flag is present, to avoid getting an unnecessary system
c     warning message. Underflow is a normal condition in EQ3/6.
c     Make porting changes in the EQLIBU subroutine that is called
c     in this section. Do not make the porting changes here.
c
      call cliefu()
c
c     Close files.
c
      close(ndat0s,status='delete')
c
      close(noutpt)
      close(nslist)
      close(ndata1)
      close(ndat1f)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine etoo2(cdrsi,dhfe,dhfs,dvfe,dvfs,ipch,ipchmx,ipcv,
     $ ipcvmx,narxmx,narxt,nbtmx1,ndrsts,ns,ntprmx,ntprt,udrsi,
     $ xhfe,xhfs,xlke,xlks,xvfe,xvfs)
c
c     This subroutine converts the reaction for the ns-th species from
c     one written in terms of e- to one written in terms of O2(g).
c     The "Eh" reaction is used to do this.
c
c     This subroutine is called by:
c       EQPT/pcraq.f
c       EQPT/pcrsg.f
c
c-----------------------------------------------------------------------
c
c     Input:
c
c       cdrsi  = array of coefficients for the original reaction
c                  associated with the ns-th species
c       nbtmx1 = the maximum number of basis species plus 1
c       ndrsts = number of species in the reaction
c       ns     = index of the species whose reaction is to be rewritten
c       udrsi  = names of species in the original reaction
c       xlke   = the array of log K values for the "Eh reaction"
c       xlks   = the array of log K values for the original reaction
c
c     Output:
c
c       cdrsi  = array of coefficients for a reaction, rewritten
c                  in terms of e- instead of O2(g)
c       udrsi  = names of species in the rewritten reaction
c       xlks   = the array of log K values for the rewritten reaction
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipchmx,ipcvmx,narxmx,nbtmx1,ntprmx
c
      integer narxt(ntprmx)
c
      integer ipch,ipcv,ndrsts,ns,ntprt
c
      character*24 udrsi(nbtmx1)
c
      real*8 cdrsi(nbtmx1),dhfe(narxmx,ntprmx,ipchmx),
     $ dhfs(narxmx,ntprmx,ipchmx,nbtmx1),dvfe(narxmx,ntprmx,ipcvmx),
     $ dvfs(narxmx,ntprmx,ipcvmx,nbtmx1),xhfe(narxmx,ntprmx),
     $ xhfs(narxmx,ntprmx,nbtmx1),xlke(narxmx,ntprmx),
     $ xlks(narxmx,ntprmx,nbtmx1),xvfe(narxmx,ntprmx),
     $ xvfs(narxmx,ntprmx,nbtmx1)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ipc,kdrsts,n,nelect,nhydr,ntpr,nwater
c
      real*8 factor
c
c-----------------------------------------------------------------------
c
c     Search for e-, H+, and H2O in the reaction.
c
      nelect = 0
      nhydr = 0
      nwater = 0
c
      do n = 2,ndrsts
        if (udrsi(n)(1:3) .eq. 'e- ') nelect = n
        if (udrsi(n)(1:3) .eq. 'H+ ') nhydr = n
        if (udrsi(n)(1:4) .eq. 'H2O ') nwater = n
      enddo
c
      if (nelect .eq. 0) go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Re-write the reaction, using the Eh reaction:
c
c       H2O = 4H+ + 4e- + O2(g)
c
      factor = -cdrsi(nelect)/4.
c
      udrsi(nelect) = 'O2(g)'
      cdrsi(nelect) = factor
c
      if (nhydr .gt. 0) then
        cdrsi(nhydr) = cdrsi(nhydr) + 4.*factor
      else
        ndrsts = ndrsts + 1
        nhydr = ndrsts
        udrsi(nhydr) = 'H+'
        cdrsi(nhydr) = 4.*factor
      endif
c
      if (nwater .gt. 0) then
        cdrsi(nwater) = cdrsi(nwater) - 2.*factor
      else
        ndrsts = ndrsts + 1
        nwater = ndrsts
        udrsi(nwater) = 'H2O'
        cdrsi(nwater) = -2.*factor
      endif
c
c     Clear any zeroes in the reaction coefficients.
c
      kdrsts = ndrsts
      do n = 1,ndrsts
        if (abs(cdrsi(n)) .le. 1.e-6) then
          if (n .le. kdrsts - 1) then
            do i = n,kdrsts - 1
              cdrsi(i) = cdrsi(i + 1)
              udrsi(i) = udrsi(i + 1)
            enddo
          endif
          kdrsts = kdrsts - 1
        endif
        if (n .ge. kdrsts) go to 150
      enddo
  150 ndrsts = kdrsts
c
c     Modify the log K values.
c
      do ntpr = 1,ntprt
        do n = 1,narxt(ntpr)
          if (xlks(n,ntpr,ns).lt.9999999. .and.
     $      xlke(n,ntpr).lt.9999999.) then
            xlks(n,ntpr,ns) = xlks(n,ntpr,ns) + factor*xlke(n,ntpr)
          else
            xlks(n,ntpr,ns) = 9999999.
          endif
        enddo
      enddo
c
      if (ipch .ge. 0) then
        do ntpr = 1,ntprt
          do n = 1,narxt(ntpr)
            if (xhfs(n,ntpr,ns).lt.9999999. .and.
     $        xhfe(n,ntpr).lt.9999999.) then
              xhfs(n,ntpr,ns) = xhfs(n,ntpr,ns) + factor*xhfe(n,ntpr)
            else
              xhfs(n,ntpr,ns) = 9999999.
            endif
          enddo
        enddo
c
        do ipc = 1,ipch
          do ntpr = 1,ntprt
            do n = 1,narxt(ntpr)
              if (dhfs(n,ntpr,ipc,ns).lt.9999999. .and.
     $          dhfe(n,ntpr,ipc).lt.9999999.) then
                dhfs(n,ntpr,ipc,ns) = dhfs(n,ntpr,ipc,ns)
     $          + factor*dhfe(n,ntpr,ipc)
              else
                dhfs(n,ntpr,ipc,ns) = 9999999.
              endif
            enddo
          enddo
        enddo
      endif
c
      if (ipcv .ge. 0) then
        do ntpr = 1,ntprt
          do n = 1,narxt(ntpr)
            if (xvfs(n,ntpr,ns).lt.9999999. .and.
     $        xvfe(n,ntpr).lt.9999999.) then
              xvfs(n,ntpr,ns) = xvfs(n,ntpr,ns) + factor*xvfe(n,ntpr)
            else
              xvfs(n,ntpr,ns) = 9999999.
            endif
          enddo
        enddo
c
        do ipc = 1,ipcv
          do ntpr = 1,ntprt
            do n = 1,narxt(ntpr)
              if (dvfs(n,ntpr,ipc,ns).lt.9999999. .and.
     $          dvfe(n,ntpr,ipc).lt.9999999.) then
                dvfs(n,ntpr,ipc,ns) = dvfs(n,ntpr,ipc,ns)
     $          + factor*dvfe(n,ntpr,ipc)
              else
                dvfs(n,ntpr,ipc,ns) = 9999999.
              endif
            enddo
          enddo
        enddo
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine g1dat(ier,noutpt,nttyo,udastr,var)
c
c     This subroutine reads a number (var) from a string (udastr)
c
c     This subroutine is called by:
c
c       EQPT/gnenb.f
c       EQPT/rdpca.f
c       EQPT/rdpth.f
c       EQPT/rdpni.f
c       EQPT/rdpn2.f
c       EQPT/rdpnn.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       udastr = a string containing one numerical data field
c
c     Principal output:
c
c       ier    = error flag
c       var    = the number contained in that field
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer noutpt,nttyo
c
      integer ier
c
      character(len=80) udastr
c
      real(8) var
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer jj,jlen
c
      integer ilnobl
c
c-----------------------------------------------------------------------
c
      var = 0.
      ier = 0
c
      call lejust(udastr)
      jj = index(udastr,' ')
      if (jj .eq. 0) jj = 81
      if (jj .lt. 80) udastr(jj:80) = ' '
      jlen = ilnobl(udastr)
c
      if (jlen .gt. 25) then
        write (noutpt,1000) udastr(1:jlen)
        write (nttyo,1000) udastr(1:jlen)
 1000   format(/' * Error - (EQPT/g1dat) Have found a data',
     $  ' field in the string:',/7x,'"',a,'"',/7x,'that appears',
     $  ' to exceed the allowed 25 characters.')
        ier = 1
      else
        read (udastr,1010,err=995) var
 1010   format(e25.18)
      endif
      go to 999
c
  995 ier = 1
c
  999 continue
      end
      subroutine gakey(ndat0s,noutpt,nttyo,uakey)
c
c     This suboutine scans the DATA0 file to determine the aqueous
c     species activity coefficient model (e.g., Pitzer, Simple
c     Extended Debye-Huckel) associated with this file.
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c
c     Principal output:
c
c       uakey  = the type of data file ("SEDH" or "Pitzer")
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ndat0s,noutpt,nttyo
c
      character(len=8) uakey
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,icount,n
c
      character(len=80) uline
c
c-----------------------------------------------------------------------
c
c     Determine whether or not this is a Pitzer-type data file.
c     Look for patterns indicating the presence of Pitzer interaction
c     coefficients.
c
      icount = 0
      do n = 1,500
        read (ndat0s,1000,end=100,err=995) uline
 1000   format(a)
        i = index(uline,'beta0 =')
        icount = icount + i
        i = index(uline,'beta1 =')
        icount = icount + i
        i = index(uline,'beta2 =')
        icount = icount + i
        i = index(uline,'cphi =')
        icount = icount + i
        i = index(uline,'Beta0 =')
        icount = icount + i
        i = index(uline,'Beta1 =')
        icount = icount + i
        i = index(uline,'Beta2 =')
        icount = icount + i
        i = index(uline,'Cphi =')
        icount = icount + i
        i = index(uline,'beta(0)')
        icount = icount + i
        i = index(uline,'beta(1)')
        icount = icount + i
        i = index(uline,'beta(2)')
        icount = icount + i
        i = index(uline,'Cphi')
        icount = icount + i
        i = index(uline,'C(phi)')
        icount = icount + i
        if (icount .ge. 24) go to 100
      enddo
  100 continue
c
      if (icount .ge. 8) then
        uakey = 'Pitzer'
      else
        uakey = 'SEDH'
      endif
c
      rewind(ndat0s)
      go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write a message for any read error other than end-of-file.
c
  995 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/gakey) Encountered a read format',
     $ ' error while',/7x,'scanning the DATA0 file to determine',
     $ ' the associated aqueous',/7x,'activity coefficient model.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine ggridp(ipch_asv,ipcv_asv,itgenf,jpdblo,jpfc_asv,
     $ jptffl,narx_asv,ndat0s,ndb_asv,noutpt,ntid_asv,ntpr_asv,
     $ nttyo,q500fl,uakey)
c
c     This suboutine gets the necessary dimensioning parameters for the
c     temperature grid on which thermodynamic data are represented.
c     These parameters are presently embedded in the data file title,
c     in order to maintain maximum forward and backward compatibility
c     of data files between Versions 7 and 8 of EQ3/6. There is
c     compatibility if the temperature grid matches the old "standard"
c     form and if there are no data grids for volume and enthalpy data.
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c       uakey  = string identifying the type of aqueous species
c                activity coefficient model ("SEDH" or "Pitzer")
c
c
c     Principal output:
c
c       ipch_asv = the maximum order of pressure corrections to the
c                    enthalpy functions; ipch_asv = min(1,ipch)
c       ipcv_asv = the maximum order of pressure corrections to the
c       itgenf   = temperature grid enforcement parameter:
c                    -1 = do nothing
c                     0 = warn if any sparsely filled ranges in
c                         "log K" temperature grid data
c                     1 = declare error condition if any sparsely
c                           filled ranges in "log K" temperature
c                           grid data
c       jpdblo   = Pitzer data block organization flag; -1 =
c                    "classical", 0 = new
c                    volume functions; ipcv_asv = min(1,ipcv)
c       jpfc_asv = the number of terms in the temperature function
c                    used to represent Pitzer interaction parameters;
c                    must be at least 1
c       jptffl   = integer flag denoting the temperature function
c                    used to represent Pitzer interaction parameters;
c                    -1 = classical truncated Taylor's series,
c                    0 = LLNL5TERM, 1 = Greenberg and Moller (1989)
c                    eight-term equation
c       narx_asv = the maximum number of points in any range of the
c                    temperature grid
c       ntid_asv = the number of lines in the data file title
c       ntpr_asv = the number of temperature ranges on the temperature
c                    grid (ntpr_asv = ntprt)
c       ndb_asv  = the maximum number of distinct points on the
c                    temperature grid;
c                    ndb_asv = ntpr_asv*(narx_asv - 1) + 1
c       q500fl   = logical flag; if .true., treat instances of "500."
c                    in "log K" temperature grids as a "no data"
c                    condition"
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ndat0s,noutpt,nttyo
c
      integer ipch_asv,ipcv_asv,jpfc_asv,narx_asv,ndb_asv,ntid_asv,
     $ ntpr_asv
c
      integer itgenf,jpdblo,jptffl
c
      character(len=8) uakey
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,j,j2,k,n,narxti,narx_x,ntpr,ntpri
c
      integer ilnobl
c
      logical q500fl,qnarxr,qrderr
c
      character(len=80), dimension(:), allocatable :: ux80ar
c
      character(len=80) ulbufa,ulbufb,uline
      character(len=16) ustr16,uterm
      character(len=8) ustr
c
c-----------------------------------------------------------------------
c
      data uterm  /'+---------------'/
c
c-----------------------------------------------------------------------
c
c     Determine the number of lines in the data file title.
c     Count that first terminator line as the last line of the title.
c
      n = 0
  100 read (ndat0s,1000,end=990,err=995) uline
 1000 format(a)
      n = n + 1
      if (uline(1:16) .ne. uterm(1:16)) go to 100
c
      ntid_asv = n
      rewind(ndat0s)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Allocate an array to hold the lines in the title.
c
      ALLOCATE(ux80ar(ntid_asv))
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the title into the holding array.
c
      do n = 1,ntid_asv
        read (ndat0s,1000,end=990,err=995) ux80ar(n)
      enddo
c
      rewind(ndat0s)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Set parameters for the temperature grid used to represent log K
c     values and standard state enthalpy and volume functions.
c
c     Values corresponding to the "classical" EQ3/6 temperature grid
c     will be used as defaults. These are intended to support the use
c     of version 7 format data files by the version 8 and higher
c     software.
c
c       ntprt       = the number of temperature ranges
c       narxt(ntpr) = the number of points or coefficients in the
c                       ntpr-th temperature range
c
c     The old standard grid corresponds to:
c
c       ntprt = 2
c       narxt(1) = 4  (0, 25, 60 100 C)
c       narxt(2) = 5  (100, 150, 200, 250, 300 C)
c       ipch = -1   (no enthalpy function grids are present)
c       ipcv = -1   (no volume function grids are present)
c
c     Note that the last point of the ntpr-th temperature range
c     is also the first point of the following range, if any.
c     This insures continuity.
c
c     Hence the matching default dimensioning is as follows. Note
c     that if ipch < 1, ipch_asv must be set to one, as an array
c     can't have a null or negative dimension. The same applies to
c     ipcv and ipcv_asv.
c
      ntpr_asv = 2
      narx_asv = 5
      ipch_asv = 1
      ipcv_asv = 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the number of temperature ranges (ntpr_asv).
c
      do n = 1,ntid_asv
        ulbufa = ' '
        ulbufb = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(ux80ar(n),'NO. OF TEMPERATURE RANGES')
        if (i .gt. 0) then
          j = i + 25
        else
          i = index(ux80ar(n),'NUMBER OF TEMPERATURE RANGES')
          if (i .gt. 0) then
            j = i + 28
          else
            i = index(ux80ar(n),'NTPRT')
            if (i .gt. 0) j = i + 5
          endif
        endif
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = ux80ar(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a number matching the keystring.
c
          ulbufb = ulbufa(2:80)
          call lejust(ulbufb)
          ustr = ulbufb(1:8)
          call chrint(ntpr_asv,nttyo,qrderr,ustr)
          if (qrderr) go to 997
          go to 200
        endif
      enddo
c
  200 continue
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the maximum number of points in any temperature range
c     (narx_asv). Note that this is done by finding the number of
c     points in each range and determining the maximum. However, an
c     array to hold the actual values has not yet been allocated.
c     The actual values will be redetermined and stored by rdwttl.f.
c
      qnarxr = .false.
      narx_x = 0
      narxti = 0
      do ntpr = 1,ntpr_asv
        do n = 1,ntid_asv
          ulbufa = ' '
          ulbufb = ' '
          j = 0
c
c         Check for a keystring.
c
          i = index(ux80ar(n),'NO. OF POINTS IN RANGE')
          if (i .gt. 0) then
            j = i + 22
          else
             i = index(ux80ar(n),'NUMBER OF POINTS IN RANGE')
            if (i .gt. 0) then
              j = i + 25
            else
              i = index(ux80ar(n),'NARXT')
              if (i .gt. 0) j = i + 5
            endif
          endif
c
          if (j .gt. 0) then
c
c           Extract a number acting as a subscript to the keystring.
c
            ulbufb = ux80ar(n)(j:80)
            call lejust(ulbufb)
            j = index(ulbufb,' ')
            j = min(j,9)
            k = j - 1
            if (k .gt. 0) then
              ustr = ulbufb(1:k)
              call chrint(ntpri,nttyo,qrderr,ustr)
              if (qrderr) go to 997
              if (ntpri .ne. ntpr) j = 0
            else
              j = 0
            endif
          endif
c
          if (j .gt. 0) then
c
c           Check for an equal sign following the keystring.
c
            ulbufa = ulbufb(j:80)
            call lejust(ulbufa)
            i = index(ulbufa,'=')
            j = 2
            if (i .ne. 1) j = 0
          endif
c
          if (j .gt. 0) then
c
c           Extract a number matching the keystring.
c
            ulbufb = ulbufa(j:80)
            call lejust(ulbufb)
            ustr = ulbufb(1:8)
            call chrint(narxti,nttyo,qrderr,ustr)
            if (qrderr) go to 997
            qnarxr = .true.
            narx_x = max(narx_x,narxti)
            go to 220
          endif
        enddo
  220   continue
c
      enddo
c
c     If a value was read for any temperature range, use it. But
c     do not use a number less than 1, as an array can not have a
c     null or negative dimension.
c
      if (qnarxr) narx_asv = narx_x
      narx_asv = max(1,narx_asv)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Calculate the maximum possible number of points on the temperature
c     grid for the current grid parameters.
c
      ndb_asv = ntpr_asv*(narx_asv - 1) + 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Set flag for dealing with sparsely filled ranges in the
c     "log K" temperature grids.
c       itgenf:
c         -1 = do nothing
c          0 = generate warnings for sparsely filled ranges
c          1 = generate errors for sparsely filled ranges
c
      itgenf = -1
      do n = 1,ntid_asv
        ulbufa = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(ux80ar(n),'SPARSE GRID RANGE CONDITION')
        if (i .gt. 0) j = i + 27
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = ux80ar(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a string input matching the keystring.
c
          ustr16 = ulbufa(2:17)
          call lejust(ustr16)
          k = index(ustr16,'IGNORE')
          if (k .gt. 0) then
            itgenf = -1
          else
            k = index(ustr16,'WARN')
            if (k .gt. 0) then
              itgenf = 0
            else
              k = index(ustr16,'ERROR')
              if (k .gt. 0) then
                itgenf = 1
              endif
            endif
          endif
          go to 300
        endif
      enddo
  300 continue
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Set flag for dealing with values of "500." on the "log K"
c     temperature grids.
c       q500fl:
c         .false. = do nothing
c          .true. = treat values of 500. as "no data"
c
      q500fl = .true.
      do n = 1,ntid_asv
        ulbufa = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(ux80ar(n),'INTERPRET 500 AS NO DATA')
        if (i .gt. 0) j = i + 24
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = ux80ar(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a string input matching the keystring.
c
          ustr16 = ulbufa(2:17)
          call lejust(ustr16)
          k = index(ustr16,'NO')
          if (k .le. 0) k = index(ustr16,'FALSE')
          if (k .gt. 0) then
            q500fl = .false.
          else
            k = index(ustr16,'YES')
            if (k .le. 0) k = index(ustr16,'TRUE')
            if (k .gt. 0) then
              q500fl = .true.
            endif
          endif
          go to 310
        endif
      enddo
  310 continue
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the dimension corresponding to the order of the pressure
c     dependence of the enthalpy functions. An order of -1 means that
c     No enthalpy functions data are present on the data file. An order
c     of 0 means that enthalpy functions data are present, but no data
c     for the pressure dependence of the same are present. However,
c     the dimensioning variable ipch_asv must be set to a value of
c     at least one, as an array can not have a null or negative
c     dimension. Thus, it is necessary here to check only for data
c     corresponding to order 2 or higher.
c
      do n = 1,ntid_asv
        ulbufa = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(ux80ar(n),'d2H/dP2')
        if (i .gt. 0) j = i + 7
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = ux80ar(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a string input matching the keystring.
c
          ustr = ulbufa(2:9)
          call lejust(ustr)
          k = index(ustr,'ON')
          if (k .le. 0) k = index(ustr,'PRESENT')
          if (k .le. 0) k = index(ustr,'ACTIVE')
          if (k .gt. 0) ipch_asv = 2
          go to 320
        endif
      enddo
  320 continue
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the dimension corresponding to the order of the pressure
c     dependence of the volume functions. This process and the dimension
c     itself are analogous to those described above for the pressure
c     dependence of the enthalpy functions.
c
      do n = 1,ntid_asv
        ulbufa = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(ux80ar(n),'d2V/dP2')
        if (i .gt. 0) j = i + 7
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = ux80ar(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a string input matching the keystring.
c
          ustr = ulbufa(2:9)
          call lejust(ustr)
          k = index(ustr,'ON')
          if (k .le. 0) k = index(ustr,'PRESENT')
          if (k .le. 0) k = index(ustr,'ACTIVE')
          if (k .gt. 0) ipcv_asv = 2
          go to 350
        endif
      enddo
  350 continue
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Set flag for Pitzer data block organization.
c       jpdblo:
c         = -1 Classical: two superblocks, one for pure aqueous
c              electrolytes, one for mixtures of two such electrolytes
c              having a common ion. A given theta parameter can appear
c              multiple times. Data for parameters involving electrically
c              neutral species are folded into this structure. Checks are
c              in place to sort things out.
c         =  0 New: multiple superblocks, each corresponding to a
c              charge-based type of species pair or triplet. This
c              structure is more rational. Theta parameters for example
c              have their own superblock.
c
      jpdblo = -1
      if (uakey(1:8) .eq. 'Pitzer  ') then
        do n = 1,ntid_asv
          ulbufa = ' '
          j = 0
c
c         Check for a keystring.
c
          i = index(ux80ar(n),'PITZER DATA BLOCK ORG.')
          if (i .gt. 0) j = i + 22
c
          if (j .gt. 0) then
c
c           Check for an equal sign following the keystring.
c
            ulbufa = ux80ar(n)(j:80)
            call lejust(ulbufa)
            i = index(ulbufa,'=')
            j = 2
            if (i .ne. 1) j = 0
          endif
c
          if (j .gt. 0) then
c
c           Extract a string input matching the keystring.
c
            ustr16 = ulbufa(2:17)
            call lejust(ustr16)
            k = index(ustr16,'NEW')
            if (k .le. 0) k = index(ustr16,'BYSPECIES')
            if (k .gt. 0) jpdblo = 0
            go to 400
          endif
        enddo
  400   continue
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the identification of the temperature function used to
c     represent Pitzer interaction parameters. Note that the number
c     of terms or coefficients (jpfcmx) is a dimensioning parameter
c     that may also be set by an option embedded in the data file
c     title.
c
c     Temperature function flag.
c       jptffl:
c         = -1 Classic: a Taylor's series centered at 25C and
c              truncated at second order.
c
c                a1 = value at 25C
c                a2 = first derivative at 25C
c                a3 = second derivative at 25C
c
c              This is currently required if the Pitzer data block
c              organization flag is set to "Classical" (jpdblo = -1).
c              The number of terms used (jpfcmx) is fixed at 3.
c
c         =  0 The function:
c
c                x(T) = a1 + a2/(T - Tr) + a3*ln(T/Tr)
c                            a4(T - Tr) + a5(T**2 - Tr**2)
c
c              This is also 25C centric (Tr = 25C).
c              The number of terms used (jpfcmx) may vary from
c              1 to 5. This always refers to the first jpfcmx terms.
c
c         =  1 The Greenberg-Moller (1988) combination temperature
c              function. This is not 25C centric. The number of terms
c              used (mx) is fixed at 8.
c
      jptffl = -1
      if (uakey(1:8) .eq. 'Pitzer  ') then
        do n = 1,ntid_asv
          ulbufa = ' '
          j = 0
c
c         Check for a keystring.
c
          i = index(ux80ar(n),'PITZER TEMP FUNCTION')
          if (i .gt. 0) j = i + 20
c
          if (j .gt. 0) then
c
c           Check for an equal sign following the keystring.
c
            ulbufa = ux80ar(n)(j:80)
            call lejust(ulbufa)
            i = index(ulbufa,'=')
            j = 2
            if (i .ne. 1) j = 0
          endif
c
          if (j .gt. 0) then
c
c           Extract a string input matching the keystring.
c
            ustr16 = ulbufa(2:17)
            call lejust(ustr16)
            k = index(ustr16,'NEW')
            if (k .le. 0) k = index(ustr16,'Livermore')
            if (k .le. 0) k = index(ustr16,'LIVERMORE')
            if (k .le. 0) k = index(ustr16,'LLNL')
            if (k .le. 0) k = index(ustr16,'L5TERM')
            if (k .le. 0) k = index(ustr16,'5TERM')
            if (k .gt. 0) then
              jptffl = 0
              go to 410
            endif
            k = index(ustr16,'TEQUIL')
            if (k .le. 0) k = index(ustr16,'T8TERM')
            if (k .le. 0) k = index(ustr16,'GM8TERM')
            if (k .le. 0) k = index(ustr16,'8TERM')
            if (k .gt. 0) then
              jptffl = 1
              go to 410
            endif
          endif
        enddo
  410   continue
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the number of terms or coefficients (jpfc_asv) in the
c     temperature function used to represent Pitzer parameters.
c
      jpfc_asv = 1
      if (uakey(1:8) .eq. 'Pitzer  ') then
c
c       Three is the default value for a Pitzer model.
c
        jpfc_asv = 3
        do n = 1,ntid_asv
          ulbufa = ' '
          j = 0
c
c         Check for a keystring.
c
          i = index(ux80ar(n),'NO. OF PITZER TEMP FUNC TERMS')
          if (i .gt. 0) j = i + 29
c
          if (j .gt. 0) then
c
c           Check for an equal sign following the keystring.
c
            ulbufa = ux80ar(n)(j:80)
            call lejust(ulbufa)
            i = index(ulbufa,'=')
            j = 2
            if (i .ne. 1) j = 0
          endif
c
          if (j .gt. 0) then
c
c           Extract a string input matching the keystring.
c
            ustr = ulbufa(2:9)
            call lejust(ustr)
            read (ustr,'(i8)') jpfc_asv
            go to 420
          endif
        enddo
  420   continue
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Deallocate the array holding the data file title.
c
      DEALLOCATE(ux80ar)
      go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write messages for errors associated with reading the DATA0
c     file.
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/ggridp) Unexpectedly encountered',
     $ /7x,'end-of-file while reading the title of the DATA0 file.')
      if (n .le. 1) then
        write (noutpt,2010)
        write (nttyo,2010)
 2010   format(/7x,'This occurred while trying to read the first line',
     $  /7x,'of the title.')
      else
        ulbufa = ux80ar(n - 1)
        call lejust(ulbufa)
        j2 = ilnobl(ulbufa)
        j2 = min(j2,70)
        write (noutpt,2020) ulbufa(1:j2)
        write (nttyo,2020) ulbufa(1:j2)
 2020   format(/7x,'This occurred while trying to read the line',
     $  ' following',/7x,'the line:',/7x,'"',a,'"')
      endif
      stop
c
  995 write (noutpt,2030)
      write (nttyo,2030)
 2030 format(/' * Error - (EQPT/ggridp) Encountered a read format',
     $ /7x,'error while reading the DATA0 file.')
      if (n .le. 1) then
        write (noutpt,2010)
        write (nttyo,2010)
      else
        ulbufa = ux80ar(n - 1)
        call lejust(ulbufa)
        j2 = ilnobl(ulbufa)
        j2 = min(j2,70)
        write (noutpt,2020) ulbufa(1:j2)
      endif
      stop
c
  997 ulbufa = ux80ar(n)
      call lejust(ulbufa)
      j2 = ilnobl(ulbufa)
      j2 = min(j2,70)
      write (noutpt,2050) ulbufa(1:j2)
      write (nttyo,2050) ulbufa(1:j2)
 2050 format(/' * Error - (EQPT/ggridp) Encountered a read format',
     $ /7x,'error while reading data embedded in the title of the',
     $ /7x,'DATA0 file. This occurred while attempting to process',
     $ ' the line:',/7x,'"',a,'"')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine gnenb(ipbt_asv,ikt_asv,jpdblo,jpfc_asv,nap_asv,
     $ nat_asv,nazt_asv,nbt_asv,nct_asv,ndat0s,ngt_asv,nlt_asv,
     4 nmt_asv,noutpt,npt_asv,npx2_asv,npx3_asv,nsb,nst_asv,nttyo,
     $ nxt_asv,uakey)
c
c     This subroutine makes a first pass through the DATA0 file to
c     determine the necessary dimensioning of arrays. The arrays are
c     then allocated back in the main program, and the data file is
c     then processed.
c
c     The returned array allocation size variables generally end
c     in "_asv." For example, the number of chemical elements is
c     normally nct. The associated allocation size variable is
c     nct_asv.
c
c     Note: although for example nxt_asv is described as the number
c     of solid solution phases on the data file, it is actually an
c     array allocation size variable which might have to be utilized
c     in allocating an array, even if the number of items in the set
c     is zero. Thus, the minimum value of one is generally imposed
c     on any allocation size variable.
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ipbt_asv = the number of parameters in a Pitzer alpha set
c       ndat0s   = unit number of the stripped DATA0 file
c
c     Principal output:
c
c       nap_asv  = maximum number of distinct sets of Pitzer alpha
c                    parameters
c       nazt_asv = the number of aqueous species on the data file
c                    for which hard core diameters are specified
c       nbt_asv  = the number of basis species on the data file
c       nct_asv  = the number of chemical elements on the data file
c       ikt_asv  = the maximum number of end-member component species
c                    in any solid solution on the data file
c       jpdblo   = integer flag denoting the Pitzer data block
c                    organization; -1 = classical, 0 = newlockile
c       jpfc_asv = the number of terms in the temperature function
c                    used to represent Pitzer interaction parameters
c       nat_asv  = the number of aqueous species on the data file
c       ngt_asv  = the number of gas species on the data file
c       nlt_asv  = the number of pure liquid species on the data file
c       nmt_asv  = the number of gas species on the data file
c       npt_asv  = the number of phases of all types on the data file
c       npx2_asv = the number of pairs of species not of the same
c                    charge sign for which Pitzer parameters are
c                    defined; typically, one of the pair is a cation
c                    and the other is an anion, but one or both
c                    species may also be electrically neutral
c       npx3_asv = the number of triplets of species corresponding to
c                    aqueous electrolyte mixtures for which Pitzer
c                    parameters are defined; generally, no more than
c                    two of these may have an electrical charge number
c                    that is postive, negative, or zero
c       nst_asv  = the number of species of all types on the data file
c       nxt_asv  = the number of solid-solution phases on the data file
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbt_asv,ikt_asv,jpfc_asv,nap_asv,nat_asv,nazt_asv,
     $ nbt_asv,nct_asv,ngt_asv,nlt_asv,nmt_asv,npt_asv,npx2_asv,
     $ npx3_asv,nst_asv,nxt_asv
c
      integer ndat0s,noutpt,nttyo
c
      integer jpdblo,nsb
c
      character(len=8) uakey
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer, parameter :: nap_par = 500
c
      integer i,ier,j,ja,j2,j3,j4,j5,ikt_sum,ikt_x,n,nmax
c
      integer ilnobl
c
      logical qalpha
c
      character(len=80) udastr,uline,ux80
      character(len=16) uaqu,uaux,uele,ubas,ubdot,ugas,uliq,umin,
     $ uref,usso,uterm
      character(len=16) ustr16
      character(len=8) ux8
c
      real(8) palpha(ipbt_asv,nap_par),palphi(ipbt_asv)
c
      real(8) aax,var
c
c-----------------------------------------------------------------------
c
      data uaqu   /'aqueous species '/
      data uaux   /'auxiliary basis '/
      data ubas   /'basis species   '/
      data ubdot  /'bdot parameters '/
      data uele   /'elements        '/
      data ugas   /'gases           '/
      data uliq   /'liquids         '/
      data umin   /'solids          '/
      data uref   /'references      '/
      data usso   /'solid solutions '/
      data uterm  /'+---------------'/
c
c-----------------------------------------------------------------------
c
c     Initialize some variables to zero.
c
      ikt_asv = 0
      nazt_asv = 0
      nap_asv = 0
      npx2_asv = 0
      npx3_asv = 0
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (uakey(1:8) .eq. 'SEDH    ') then
c
c       Have a Simple Extended Debye-Huckel model for the activity
c       coefficients of aqueous species. Determine the number of aqueous
c       species for which hard core diameters are specified.
c
  120   read (ndat0s,1000,end=990,err=995) uline
 1000   format(a)
        if (uline(1:16) .ne. ubdot(1:16)) go to 120
c
c       Skip the terminator line.
c
        read (ndat0s,1000,end=990,err=995) uline
c
c       Tally lines until next terminator.
c
        n = 0
  130   read (ndat0s,1000,end=990,err=995) uline
        if (uline(1:16) .eq. uterm(1:16)) go to 140
        n = n + 1
        go to 130
c
  140   nazt_asv = n
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (uakey(1:8) .eq. 'Pitzer  ') then
c
c       Have a Pitzer model for the activity coefficients of aqueous
c       species.
c
        if (jpdblo .eq. -1) then
c
c         Have the "classical" Pitzer data block organization.
c         Determine the number of pairs of ions corresponding to pure
c         aqueous electrolytes for which Pitzer parameters are defined
c         ('single-salt parameters').
c
  150     read (ndat0s,1000,end=990,err=995) uline
          if (uline(1:16) .ne. 'single-salt para') go to 150
c
c         Skip the terminator line.
c
          read (ndat0s,1000,end=990,err=995) uline
c
c         Determine the number of such pairs of ions (npx2_asv) by
c         counting the number of terminator lines prior to encountering
c         the 'mixture term parameters' line.
c
c         Also determine the number of distinct sets of Pitzer alpha
c         parameters (nap_asv).
c
          n = 0
          ja = 0
  160     read (ndat0s,1000,end=990,err=995) uline
c
          if (uline(1:16) .eq. 'mixture term par') then
            backspace(ndat0s)
            go to 180
          endif
c
          i = index(uline,'alpha1')
          if (i .gt. 0) then
c
c           Found the line with the alpha parameters.
c
            read (uline,1020,end=990,err=995) palphi(1),palphi(2)
 1020       format(18x,2(16x,f5.1))
c
            if (ja .gt. 1) then
              do j = 1,ja
                if (abs(palpha(1,j) - palphi(1)).le.1.e-12
     $            .and. abs(palpha(2,j) - palphi(2)).le.1.e-12) then
                  go to 170
                endif
              enddo
            endif
c
c           Not in the set; add it.
c
            ja = ja + 1
            if (ja .gt. nap_par) then
              write (ux8,'(i5)') nap_par
              call lejust(ux8)
              j2 = ilnobl(ux8)
              write (noutpt,1030) ux8(1:j2)
              write (nttyo,1030) ux8(1:j2)
 1030         format(/' * Error - (EQPT/gnenb) Have overflowed the',
     $        ' palpha array while',/7x,'attempting to find the number',
     $        ' of distinct sets of Pitzer alpha',/7x,'parameters.',
     $        ' Increase the dimensioning parameter nap_par in this',
     $        /7x,'subroutine from its present value of ',a,'.')
              stop
            endif
c
            palpha(1,ja) = palphi(1)
            palpha(2,ja) = palphi(2)
          endif
  170     continue
c
          if (uline(1:16) .eq. uterm(1:16)) n = n + 1
          go to 160
c
  180     npx2_asv = n
          nap_asv = ja
c
c         Determine the number of triplets of ions corresponding to
c         aqueous electrolyte mixtures for which Pitzer parameters are
c         defined ('mixture term parameters').
c
  190     read (ndat0s,1000,end=990,err=995) uline
          if (uline(1:16) .ne. 'mixture term par') go to 190
c
c         Skip the terminator line.
c
          read (ndat0s,1000,end=990,err=995) uline
c
c         Skip the E-theta flag line.
c
          read (ndat0s,1000,end=990,err=995) uline
c
c         Determine the number such triplets of by counting the number
c         of terminator lines prior to encountering the 'elements' line.
c
          n = 0
  200     read (ndat0s,1000,end=990,err=995) uline
          if (uline(1:16) .eq. uele(1:16)) then
            backspace(ndat0s)
            go to 210
          endif
          if (uline(1:16) .eq. uterm(1:16)) n = n + 1
          go to 200
c
  210     npx3_asv = n
c
        elseif (jpdblo .eq. 0) then
c
c         Have the "new" Pitzer data block organization.
c
c         First determine the number of distinct sets of Pitzer alpha
c         parameters (nap_asv). It is possible that no values are
c         input here, in which case only the default set holds.
c
c         Load the default set into the palpha array.
c
          nmax = ipbt_asv*nap_par
          call initaz(palpha,nmax)
          palpha(1,1) = 2.0
          palpha(2,1) = 12.0
          palpha(1,2) = 1.4
          palpha(2,2) = 12.0
          ja = 2
          nap_asv = ja
c
c         Skip down to the "ca combinations" superblock. This is
c
  220     read (ndat0s,1000,end=990,err=995) uline
          if (uline(1:15) .ne. 'ca combinations') go to 220
c
c         Skip the terminator line.
c
          read (ndat0s,1000,end=990,err=995) uline
c
  230     read (ndat0s,1000,end=990,err=995) uline
          j3 = ilnobl(uline)
c
          if (uline(1:26) .eq. "cc'a and aa'c combinations") then
            backspace(ndat0s)
            go to 250
          endif
c
          qalpha = .false.
          ux80 = uline
          call lejust(ux80)
c
c         Find the next set of alpha lines. Look for "alpha(1)".
c         That marks the start of a set.
c
          ustr16 = 'alpha(1) ='
          j4 = 10
          if (ux80(1:j4) .eq. ustr16(1:j4)) then
c
c           Found a line with the alpha(1) parameter.
c
            j5 = index(ux80,'=')
            udastr = ux80(j5 + 1:80)
            call g1dat(ier,noutpt,nttyo,udastr,var)
            if (ier .gt. 0) then
              write (noutpt,1110) uline(1:j3)
              write (nttyo,1110) uline(1:j3)
 1110         format(/' * Error - (EQPT/gnenb) Have found a line',
     $        ' starting with:',/7x,'"',a,'"',/7x,'containing an',
     $        ' expected numerical field that could not be read.',
     $        /7x,'This occurred while scanning the data file to',
     $        ' determine the number',/7x,'of distinct sets of',
     $        ' Pitzer alpha parameters.')
              stop
            endif
            palphi(1) = var
            qalpha = .true.
c
            do i = 2,ipbt_asv
              read (ndat0s,1000,end=990,err=995) uline
              j3 = ilnobl(uline)
              ux80 = uline
              call lejust(ux80)
              ustr16 = 'alpha( ) ='
              j4 = 10
              write (ustr16(7:7),'(i1)') i
              if (ux80(1:j4) .eq. ustr16(1:j4)) then
c
c               Found a line with the expected alpha(i) parameter.
c
                j5 = index(ux80,'=')
                udastr = ux80(j5 + 1:80)
                call g1dat(ier,noutpt,nttyo,udastr,var)
                if (ier .le. 0) then
                  palphi(i) = var
                else
                  write (noutpt,1110) uline(1:j3)
                  write (nttyo,1110) uline(1:j3)
                  stop
                endif
              else
c
c               Did not find a line with the expected alpha(i)
c               parameter.
c
                ustr16 = 'beta(0) ='
                j4 = 9
                if (ux80(1:j4) .ne. ustr16(1:j4)) then
c
c                 Did not find a beta(0) line either. This
c                 condition is invalid.
c
                  write (ux8,'(i1)') i
                  write (noutpt,1120) uline(1:j3),ux8(1:1)
                  write (nttyo,1120) uline(1:j3),ux8(1:1)
 1120             format(/' * Error - (EQPT/gnenb) Have found a line',
     $            ' starting with:',/7x,'"',a,'"',/7x,'that contains',
     $            ' neither the expected alpha(',a,') data nor the',
     $            /7x,'possible beta(0) data that could mark the end',
     $            ' of an abbreviated',/7x,'alpha set. This occurred',
     $            ' while scanning the data file',/7x,'to determine',
     $            ' the number of distinct sets of Pitzer',
     $            /7x,'alpha parameters.')
                  stop
                endif
              endif
            enddo
          endif
c
          if (qalpha) then
            do j = 1,ja
              do i = 1,ipbt_asv
                aax = abs(palpha(i,j) - palphi(i))
                if (aax .gt. 1.e-12) go to 240
              enddo
c
c             The current alpha combination is already in
c             the known set.
c
              go to 230
  240         continue
            enddo
c
c           The current alpha set is not in the set; add it.
c
            ja = ja + 1
            if (ja .gt. nap_par) then
c
c             Have overflowed the palpha array, which was statically
c             dimensioned.
c
              write (ux8,'(i5)') nap_par
              call lejust(ux8)
              j2 = ilnobl(ux8)
              write (noutpt,1030) ux8(1:j2)
              write (nttyo,1030) ux8(1:j2)
              stop
            endif
            do i = 1,ipbt_asv
              palpha(i,ja) = palphi(i)
            enddo
          endif
          go to 230
c
  250     nap_asv = ja
c
          rewind(ndat0s)
c
c         Skip back down to the "ca combinations" superblock.
c
  260     read (ndat0s,1000,end=990,err=995) uline
          if (uline(1:15) .ne. 'ca combinations') go to 260
c
c         Skip the terminator line.
c
          read (ndat0s,1000,end=990,err=995) uline
c
c         Determine the number of pair combinations (npx2_asv) by
c         counting the number of terminator lines prior to
c         encountering the "cc'a and aa'c combinations" line.
c         Correct this estimate for other pair superblock
c         headers.
c
          n = 0
  270     read (ndat0s,1000,end=990,err=995) uline
c
          if (uline(1:26) .eq. "cc'a and aa'c combinations") then
            backspace(ndat0s)
            go to 280
          endif
c
          if (uline(1:24) .eq. "cc' and aa' combinations") n = n - 1
          if (uline(1:22) .eq. "nc and na combinations") n = n - 1
          if (uline(1:15) .eq. "nn combinations") n = n - 1
          if (uline(1:16) .eq. "nn' combinations") n = n - 1
          if (uline(1:16) .eq. uterm(1:16)) n = n + 1
          go to 270
c
  280     npx2_asv = n
c
c         Skip down to the "cc'a and aa'c combinations" superblock.
c
  290     read (ndat0s,1000,end=990,err=995) uline
          if (uline(1:26) .ne. "cc'a and aa'c combinations") go to 290
c
c         Skip the terminator line.
c
          read (ndat0s,1000,end=990,err=995) uline
c
c         Determine the number of triplet combinations (npx3_asv) by
c         counting the number of terminator lines prior to
c         encountering the "cc'a and aa'c combinations" line.
c         Correct this estimate for other triplet superblock
c         headers.
c
          n = 0
  300     read (ndat0s,1000,end=990,err=995) uline
c
          if (uline(1:16) .eq. uele(1:16)) then
            backspace(ndat0s)
            go to 310
          endif
c
          if (uline(1:16) .eq. "nca combinations") n = n - 1
          if (uline(1:16) .eq. "nnn' combination") n = n - 1
          if (uline(1:16) .eq. uterm(1:16)) n = n + 1
          go to 300
c
  310     npx3_asv = n
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Find the 'elements' line.
c
  350 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .ne. uele(1:16)) go to 350
c
c     Skip the terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c     Tally lines until next terminator.
c
      n = 0
  360 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .eq. uterm(1:16)) go to 370
      n = n + 1
      go to 360
c
  370 nct_asv = n
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Skip to the 'basis species' line.
c
  400 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .ne. ubas(1:16)) go to 400
c
c     Skip the terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c     Determine the number of basis species by counting the number
c     of terminator lines prior to encountering the 'aqueous species'
c     line. In this count, note that an "extra" terminator line
c     is encountered after the "auxiliary basis species" line.
c     The number of strict basis species is also determined, by
c     noting the number of basis species prior to encountering the
c     "auxiliary basis species" line.
c
      n = 0
  410 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .eq. uaux(1:16)) nsb = n
      if (uline(1:16) .eq. uaqu(1:16)) then
        backspace(ndat0s)
        go to 420
      endif
      if (uline(1:16) .eq. uterm(1:16)) n = n + 1
      go to 410
c
  420 nbt_asv = n - 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Skip to the 'aqueous species' line.
c
  450 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .ne. uaqu(1:16)) go to 450
c
c     Skip the terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c     Determine the number of non-basis aqueous species by counting the
c     number of terminator lines prior to encountering the 'solids'
c     line. The total number of aqueous species is the sum of the
c     basis and non-basis aqueous species.
c
      n = 0
  460 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .eq. umin(1:16)) then
        backspace(ndat0s)
        go to 470
      endif
      if (uline(1:16) .eq. uterm(1:16)) n = n + 1
      go to 460
c
  470 nat_asv = nbt_asv + n
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Skip to the 'solids' line.
c
  500 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .ne. umin(1:16)) go to 500
c
c     Skip the terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c     Determine the number of pure mineral species by counting the
c     number of terminator lines prior to encountering the 'liquids'
c     line.
c
      n = 0
  510 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .eq. uliq(1:16)) then
        backspace(ndat0s)
        go to 520
      endif
      if (uline(1:16) .eq. uterm(1:16)) n = n + 1
      go to 510
c
  520 nmt_asv = n
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Skip to the 'liquids' line.
c
  550 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .ne. uliq(1:16)) go to 550
c
c     Skip the terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c     Determine the number of pure liquid species by counting the
c     number of terminator lines prior to encountering the 'gases'
c     line.
c
      n = 0
  560 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .eq. ugas(1:16)) then
        backspace(ndat0s)
        go to 570
      endif
      if (uline(1:16) .eq. uterm(1:16)) n = n + 1
      go to 560
c
c     Note: water as a pure liquid phase is not explicitly on the
c     DATA0 file. It is added by EQ3NR or EQ6 by cloning the liquid
c     water species belonging to the aqueous solution phase. The pure
c     liquid water phase must be accounted for in nlt_asv, so the
c     actual count of pure liquid phases explicitly on the data file
c     is incremented by one.
c
  570 nlt_asv = n + 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Skip to the 'gases' line.
c
  600 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .ne. ugas(1:16)) go to 600
c
c     Skip the terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c     Determine the number of gas species by counting the number of
c     terminator lines prior to encountering the 'solid solutions'
c     line.
c
      n = 0
  610 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .eq. usso(1:16)) then
        backspace(ndat0s)
        go to 620
      endif
      if (uline(1:16) .eq. uterm(1:16)) n = n + 1
      go to 610
c
  620 ngt_asv = n
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Skip to the 'solid solutions' line.
c
  650 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .ne. usso(1:16)) go to 650
c
c     Skip the terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c     Determine the number of solid solution phases by counting the
c     number of terminator lines prior to encountering the 'references'
c     line.
c
c       ikt_x   = the number of components in the current solid
c                   solution
c       ikt_sum = the total number of components in all solid solutions
c
      n = 0
      ikt_x = 0
      ikt_sum = 0
c
  660 read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:16) .eq. uref(1:16)) then
        backspace(ndat0s)
        go to 670
      endif
c
      if (ikt_x .le. 0) then
c
c       Have not yet found a 'component' line.
c
        i = index(uline,'component')
        if (i .eq. 5) then
c
c         Have found the line with the number of components.
c         Note that there is a two-component minimum here.
c
          read (uline,'(1x,i2)',err=995) ikt_x
          ikt_x = max(2,ikt_x)
          ikt_asv = max(ikt_asv,ikt_x)
          ikt_sum = ikt_sum + ikt_x
        endif
      endif
c
      if (uline(1:16) .eq. uterm(1:16)) then
c
c       Have found the end of the current solid solution block.
c
        n = n + 1
        if (ikt_x .le. 0) then
c
c         No line defining the number of components was found.
c
          ikt_x = 2
          ikt_asv = max(ikt_asv,ikt_x)
          ikt_sum = ikt_sum + ikt_x
        endif
        ikt_x = 0
      endif
      go to 660
c
  670 nxt_asv = n
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the total number of phases. Be sure to account for the
c     aqueous solution and the gas phase. Water as a pure liquid
c     phase has been implicitly added to nlt_asv.
c
      npt_asv = 2 + nmt_asv + nlt_asv + nxt_asv
c
c     Get the total number of species.
c
      nst_asv = nat_asv + nmt_asv + nlt_asv + ngt_asv + ikt_sum
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Each dimensioning parameter should have a minimum value of 1,
c     even if the corresponding number of items is 0.
c
      ikt_asv = max(1,ikt_asv)
      nap_asv = max(1,nap_asv)
      nat_asv = max(1,nat_asv)
      nazt_asv = max(1,nazt_asv)
      nbt_asv = max(1,nbt_asv)
      nct_asv = max(1,nct_asv)
      ngt_asv = max(1,ngt_asv)
      nlt_asv = max(1,nlt_asv)
      nmt_asv = max(1,nmt_asv)
      npt_asv = max(1,npt_asv)
      npx2_asv = max(1,npx2_asv)
      npx3_asv = max(1,npx3_asv)
      nst_asv = max(1,nst_asv)
      nxt_asv = max(1,nxt_asv)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Rewind the DATA0 file and exit.
c
      rewind(ndat0s)
      go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write a message for any read error.
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/gnenb) Unexpectedly encountered',
     $ ' end-of-file',/7x,'while scanning the DATA0 file to determine',
     $ ' the necessary array',/7x,'dimensions.')
      stop
c
  995 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/gnenb) Encountered a read format',
     $ ' error while',/7x,'scanning the DATA0 file to determine',
     $ ' the necessary array dimensions.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine gspidx(ier,n,nat,natmax,uaqsp,unams)
c
c     Get the index (n) of the aqueous species whose name is unams.
c
c     This subroutine is called by:
c
c       EQPT/rdpz2.f
c       EQPT/rdpz3.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c       unams  = the name of an aqueous species whose index n is
c                  desired
c
c     Principal output:
c
c       ier    = error flag
c       n      = the index of the species unams in the uaqsp array
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer natmax
c
      integer ier,n,nat
c
      character*24 uaqsp(natmax)
      character*24 unams
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
c
c-----------------------------------------------------------------------
c
      ier = 0
      do n = 1,nat
        if (unams(1:24) .eq. uaqsp(n)(1:24)) then
          go to 100
        endif
      enddo
c
c     The species was not found. Set the error flag.
c
      ier = 1
      n = 0
c
  100 continue
c
      end
      subroutine hdrchk(ndat0s,noutpt,nttyo)
c
c     This suboutine checks the first line of the DATA0 file to ensure
c     that the mandatory header ("data0" beginning in column 1) is
c     present.
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c
c     Principal output:
c
c       None
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ndat0s,noutpt,nttyo
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer j2
c
      integer ilnobl
c
      character(len=80) uline
c
c-----------------------------------------------------------------------
c
c     Check the DATA0 file header. This insures that the file that
c     is supposed to be a DATA0 file really is one.
c
      read (ndat0s,1000,end=990,err=995) uline
 1000 format(a)
c
      if (uline(1:5).ne.'data0' .and. uline(1:5).ne.'Data0' .and.
     $  uline(1:5).ne.'DATA0') then
        j2 = ilnobl(uline)
        j2 = min(j2,50)
        write (noutpt,1010) uline(1:j2)
        write (nttyo,1010) uline(1:j2)
 1010   format(/' * Error - (EQPT/hdrchk) The DATA0 must have "data0"',
     $  ' beginning in',/7x,'column 1 of the first line. The first',
     $  ' line of this file begins',/7x,'instead with: "',a,'".')
        stop
      endif
c
      rewind(ndat0s)
      go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write a message for any read error.
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/hdrchk) The DATA0 file is an empty',
     $ ' file.')
      stop
c
  995 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/hdrchk) Encountered a read format',
     $ ' error while',/7x,'checking for the mandatory header on the',
     $ ' first line of the',/7x,'DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $ narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $ xvec,yvec)
c
c     This subroutine fits interpolating polynomials to data (avgrid)
c     on a temperature grid (tempc). The grid is divided into ranges.
c     A separate polynomial is fitted to the data in each range.
c     Its coefficients are obtained in the cof array. The coefficients
c     for all ranges are returned in the apr array.
c
c     This subroutine is called by:
c
c       EQPT/pcraq.f
c       EQPT/pcrsg.f
c       EQPT/wrpar.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       avgrid = array containing the data on the temperature grid
c
c     Principal output:
c
c       apr    = array of polynomial coefficients (for all ranges)
c       avgrid = array containing the data on the temperature grid
c       narxmx = the maximum number of points or coefficients per
c                  temperature range
c       narxt  = the actual number of points or coefficients per
c                  temperature range
c       nptrmx = the maximum number of temperature ranges
c       nptrt  = the actual number of temperature ranges
c
c     Workspace:
c
c       aamatr = matrix used to calculate the polynomial coefficients
c       cof    = array of fitted polynomial coefficients (for a
c                  single temperature range)
c       xvec   = array of scaled temperatures corresponding to the
c                  data in the yvec array
c       yvec   = array of data to be fitted (for a single temperature
c                  range)
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer narxmx,ntprmx
c
      integer noutpt,nttyo
c
      integer ntprt
c
      integer ipivot(narxmx),narxt(ntprmx)
c
      real*8 apr(narxmx,ntprmx),avgrid(narxmx,ntprmx)
      real*8 tempc(narxmx,ntprmx),tempcs(narxmx,ntprmx),tmpcmx(ntprmx)
      real*8 aamatr(narxmx,narxmx),gmmatr(narxmx,narxmx)
      real*8 cof(narxmx),xvec(narxmx),yvec(narxmx)
c
      real*8 eps100
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer ier,n,nmax,npft,ntpr
c
      real*8 tvecmx
c
c-----------------------------------------------------------------------
c
c     Initialize apr to 0.
c
      nmax = narxmx*ntprmx
      call initaz(apr,nmax)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Loop on temperature ranges.
c
      do ntpr = 1,ntprt
c
c       Put all real values (9999999. indicates no data) in the yvec
c       array. Put the corresponding scaled temperature values in
c       the xvec array.
c
        npft = 0
c
        do n = 1,narxt(ntpr)
          if (avgrid(n,ntpr) .lt. 9999999.) then
            npft = npft + 1
            xvec(npft) = tempcs(n,ntpr)
            yvec(npft) = avgrid(n,ntpr)
          endif
        enddo
c
c       Here npft is the number of usable values.
c
        if (npft .le. 0) then
c
c         There are no usable values.
c
          apr(1,ntpr) = 9999999.
          go to 110
        endif
c
        if (npft .gt. 1) then
c
c         Check for constant yvec.
c
          do n = 2,npft
            if(abs(yvec(n) -yvec(1)) .gt. eps100) go to 100
          enddo
          npft = 1
  100     continue
        endif
c
        if (npft .le. 1) then
          apr(1,ntpr) = yvec(1)
          go to 110
        endif
c
c       Fit the polynomial.
c
        call polfit(aamatr,cof,gmmatr,ier,ipivot,narxmx,npft,
     $  noutpt,nttyo,xvec,yvec)
c
        if (ier .gt. 0) then
          write (noutpt,1010) ntpr,tempc(1,ntpr),tempc(narxt(ntpr),ntpr)
          write (nttyo,1010) ntpr,tempc(1,ntpr),tempc(narxt(ntpr),ntpr)
 1010     format(/' * Error - (EQPT/intrp) Could not compute the',
     $    /7x,'coefficients of an interpolating polynomial in',
     $    /7x,'temperature range ',i2,' (',f6.2,' - ',f6.2,' C.')
          stop
        endif
c
c       Rescale the coefficients.
c
        tvecmx = tmpcmx(ntpr)
c
c       Calling sequence substitutions:
c         tvecmx for avxmax
c         cof for avy
c         cof for avys
c         npft for nmax
c
        call rscaly(tvecmx,cof,cof,eps100,npft)
c
c       Store the fitted coefficients for this range in the apr array.
c
        do n = 1,npft
          apr(n,ntpr) = cof(n)
        enddo
c
  110   continue
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $ xdbval,zdbval)
c
c     This subroutine loads data on the temperature grid from the
c     one-dimensional holding array (xdbval) into the two-dimensional
c     proper data array (represented here by the dummy name zdbval).
c
c     This subroutine is called by:
c
c       EQPT/rdpar.f
c       EQPT/pcraq.f
c       EQPT/pcrsg.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       narxt  = array of numbers of coefficients in the temperature
c                  ranges
c       ntprt  = the number of temperature ranges on the standard
c                  temperature grid
c       xdbval = holding array (1-dimensional)
c
c     Principal output:
c
c       nacdpr = array containging the number of actual data points
c                  by range on the "log K" temperature grid; excludes
c                  cases of "no data"
c       zdbval = dummy name for the proper data array (2-dimensional)
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer narxmx,ndbmax,ntprmx
c
      integer nacdpr(ntprmx),narxt(ntprmx)
c
      integer ntprt
c
      real*8 xdbval(ndbmax),zdbval(narxmx,ntprmx)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,k,n,ntpr
c
c-----------------------------------------------------------------------
c
c     Load the data from the xdbval array into the zdbval array.
c     Note that a point which comprises the boundary between two
c     ranges is a member of both ranges.
c
      ntpr = 1
      k = 0
      do n = 1,narxt(1)
        i = n
        zdbval(n,ntpr) = xdbval(i)
        if (xdbval(i) .lt. 9999999.) k = k + 1
      enddo
      nacdpr(ntpr) = k
c
      do ntpr = 2,ntprt
        k = 0
        zdbval(1,ntpr) = xdbval(i)
        if (xdbval(i) .lt. 9999999.) k = k + 1
        do n = 2,narxt(ntpr)
          i = i + 1
          zdbval(n,ntpr) = xdbval(i)
          if (xdbval(i) .lt. 9999999.) k = k + 1
        enddo
        nacdpr(ntpr) = k
      enddo
c
      end
      subroutine ldbar3(ipc,ipcmax,nacdpr,narxmx,narxt,ndbmax,
     $ ntprmx,ntprt,xdbval,zdbval)
c
c     This subroutine loads data on the temperature grid from the
c     one-dimensional holding array (xdbval) into the ipc-th part
c     of the three-dimensional proper data array (represented here by
c     the dummy name zdbval).
c
c     This subroutine is called by:
c
c       EQPT/rdpar.f
c       EQPT/pcraq.f
c       EQPT/pcrsg.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ipc    = the fixed dimension of the proper array
c       narxt  = array of numbers of coefficients in the temperature
c                  ranges
c       ntprt  = the number of temperature ranges on the standard
c                  temperature grid
c       xdbval = holding array (1-dimensional)
c
c     Principal output:
c
c       nacdpr = array containging the number of actual data points
c                  by range on the "log K" temperature grid; excludes
c       zdbval = dummy name for the proper data array (3-dimensional)
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipcmax,narxmx,ndbmax,ntprmx
c
      integer nacdpr(ntprmx),narxt(ntprmx)
c
      integer ipc,ntprt
c
      real*8 xdbval(ndbmax),zdbval(narxmx,ntprmx,ipcmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,k,n,ntpr
c
c-----------------------------------------------------------------------
c
c     Load the data from the xdbval array into the zdbval array.
c     Note that a point which comprises the boundary between two
c     ranges is a member of both ranges.
c
      ntpr = 1
      k = 0
      do n = 1,narxt(1)
        i = n
        zdbval(n,ntpr,ipc) = xdbval(i)
        if (xdbval(i) .lt. 9999999.) k = k + 1
      enddo
      nacdpr(ntpr) = k
c
      do ntpr = 2,ntprt
        k = 0
        zdbval(1,ntpr,ipc) = xdbval(i)
        if (xdbval(i) .lt. 9999999.) k = k + 1
        do n = 2,narxt(ntpr)
          i = i + 1
          zdbval(n,ntpr,ipc) = xdbval(i)
          if (xdbval(i) .lt. 9999999.) k = k + 1
        enddo
        nacdpr(ntpr) = k
      enddo
c
      end
      subroutine ldbar4(ipc,ipcmax,nacdpr,narxmx,narxt,nbtmx1,
     $ ndbmax,ns,ntprmx,ntprt,xdbval,zdbval)
c
c     This subroutine loads data on the temperature grid from the
c     one-dimensional holding array (xdbval) into the ipc-th and ns-th
c     part of the four-dimensional proper data array (represented here
c     by the dummy name zdbval).
c
c     This subroutine is called by:
c
c       EQPT/rdpar.f
c       EQPT/pcraq.f
c       EQPT/pcrsg.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ipc    = the first fixed dimension of the proper array
c       narxt  = array of numbers of coefficients in the temperature
c                  ranges
c       ns     = the second fixed dimension of the proper array
c       ntprt  = the number of temperature ranges on the standard
c                  temperature grid
c       xdbval = holding array (1-dimensional)
c
c     Principal output:
c
c       nacdpr = array containging the number of actual data points
c                  by range on the "log K" temperature grid; excludes
c       zdbval = dummy name for the proper data array (4-dimensional)
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipcmax,narxmx,nbtmx1,ndbmax,ntprmx
c
      integer nacdpr(ntprmx),narxt(ntprmx)
c
      integer ipc,ns,ntprt
c
      real*8 xdbval(ndbmax),zdbval(narxmx,ntprmx,ipcmax,nbtmx1)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,k,n,ntpr
c
c-----------------------------------------------------------------------
c
c     Load the data from the xdbval array into the zdbval array.
c     Note that a point which comprises the boundary between two
c     ranges is a member of both ranges.
c
      ntpr = 1
      k = 0
      do n = 1,narxt(1)
        i = n
        zdbval(n,ntpr,ipc,ns) = xdbval(i)
        if (xdbval(i) .lt. 9999999.) k = k + 1
      enddo
      nacdpr(ntpr) = k
c
      do ntpr = 2,ntprt
        k = 0
        zdbval(1,ntpr,ipc,ns) = xdbval(i)
        if (xdbval(i) .lt. 9999999.) k = k + 1
        do n = 2,narxt(ntpr)
          i = i + 1
          zdbval(n,ntpr,ipc,ns) = xdbval(i)
          if (xdbval(i) .lt. 9999999.) k = k + 1
        enddo
        nacdpr(ntpr) = k
      enddo
c
      end
      subroutine naqsck(nat,natmax,nerr,noutpt,nttyo,uaqsp)
c
c     Check the names of aqueous species for uniqueness.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       uaqsp  = array containing the names of aqueous species
c
c     Principal output:
c
c       nerr   = incremented error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer noutpt,nttyo
c
      integer natmax
c
      integer nat,nerr
c
      character(len=24) uaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*24 unam
      character*8 ux8
c
      integer i,ilist,j,j2,j3,k,ncount
c
      integer ilnobl
c
c-----------------------------------------------------------------------
c
c     Note: ilist = the number of species with duplicate blocks
c     on the data file.
c
      ilist = 0
c
c     Check each name for uniqueness.
c
      do i = 1,nat
        unam = uaqsp(i)
        ncount = 1
        if (unam(1:7) .ne. '<blank>') then
          do j = i + 1,nat
            if (unam(1:24) .eq. uaqsp(j)(1:24)) then
c
c             Have found a duplicate block moving down the list from
c             the block now being tested for uniqueness. For the first
c             such duplicate block only, make sure that there is not a
c             duplicate block moving up the list from the block now
c             being tested. If there is such a block, then the
c             duplication in question has been noted previously and
c             should not be noted again.
c
              if (ncount .eq. 1) then
                do k = 1,i - 1
                  if (unam(1:24) .eq. uaqsp(k)(1:24)) then
c
c                   Have found a duplicate block preceding the block
c                   now being tested for uniqueness.
c
                    go to 100
                  endif
                enddo
              endif
c
c             Have found a duplication that has not been previously
c             noted.
c
              ncount = ncount + 1
            endif
          enddo
  100     continue
        endif
c
        if (ncount .gt. 1) then
c
c         Have a duplicate block or blocks.
c
          ilist = ilist + 1
c
          if (ilist .eq. 1) then
c
c           Write error message header.
c
            write (noutpt,1000)
            write (nttyo,1000)
 1000       format(/' * Error - (EQPT/naqsck) The following aqueous',
     $      ' species have multiple',/7x,'species blocks:',/)
          endif
c
          write (ux8,'(i5)') ncount
          call lejust(ux8)
          j3 = ilnobl(ux8)
          j2 = ilnobl(unam)
          write (noutpt,1010) unam(1:j2),ux8(1:j3)
          write (nttyo,1010) unam(1:j2),ux8(1:j3)
 1010     format(9x,a,' has ',a,' blocks')
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      nerr = nerr + ilist
c
      end
      subroutine nelcck(nctmax,ncts,nentei,nerr,qdupes,uessi)
c
c     Check the elemental composition of a species to ensure that
c     each chemical element name appearing in the composition is unique.
c
c     This subroutine is called by:
c
c       EQPT/elesck.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c
c     Principal output:
c
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer nctmax
c
      integer nentei(nctmax)
c
      integer ncts,nerr
c
      logical qdupes
c
      character(len=8) uessi(nctmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*8 unam
c
      integer i,j,k,ncount
c
c-----------------------------------------------------------------------
c
      qdupes = .false.
c
c     Check each name for uniqueness.
c
      do i = 1,ncts
        unam = uessi(i)
        ncount = 1
        if (unam(1:7) .ne. '<blank>') then
          do j = i + 1,ncts
            if (unam(1:8) .eq. uessi(j)(1:8)) then
c
c             Have found a duplicate entry moving down the list from
c             the entry now being tested for uniqueness. For the first
c             such duplicate entry only, make sure that there is not a
c             duplicate entry moving up the list from the entry now
c             being tested. If there is such a entry, then the
c             duplication in question has been noted previously and
c             should not be noted again.
c
              if (ncount .eq. 1) then
                do k = 1,i - 1
                  if (unam(1:8) .eq. uessi(k)(1:8)) then
c
c                   Have found a duplicate entry preceding the entry
c                   now being tested for uniqueness.
c
                    go to 100
                  endif
                enddo
              endif
c
c             Have found a duplication that has not been previously
c             noted.
c
              ncount = ncount + 1
            endif
          enddo
  100     continue
        endif
c
        nentei(i) = ncount
        if (ncount .gt. 1) qdupes = .true.
      enddo
c
      end
      subroutine neleck(nct,nctmax,nerr,noutpt,nttyo,uelem)
c
c     Check the names of chemical elements for uniqueness.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c
c     Principal output:
c
c       nerr   = incremented error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer nctmax
c
      integer noutpt,nttyo
c
      integer nct,nerr
c
      character(len=8) uelem(nctmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*8 unam,ux8
c
      integer i,ilist,j,j2,j3,k,ncount
c
      integer ilnobl
c
c-----------------------------------------------------------------------
c
      ilist = 0
c
c     Check each name for uniqueness.
c
      do i = 1,nct
        unam = uelem(i)
        ncount = 1
        if (unam(1:7) .ne. '<blank>') then
          do j = i + 1,nct
            if (unam(1:8) .eq. uelem(j)(1:8)) then
c
c             Have found a duplicate entry moving down the list from
c             the entry now being tested for uniqueness. For the first
c             such duplicate entry only, make sure that there is not a
c             duplicate entry moving up the list from the entry now
c             being tested. If there is such a entry, then the
c             duplication in question has been noted previously and
c             should not be noted again.
c
              if (ncount .eq. 1) then
                do k = 1,i - 1
                  if (unam(1:8) .eq. uelem(k)(1:8)) then
c
c                   Have found a duplicate entry preceding the entry
c                   now being tested for uniqueness.
c
                    go to 100
                  endif
                enddo
              endif
c
c             Have found a duplication that has not been previously
c             noted.
c
              ncount = ncount + 1
            endif
          enddo
  100     continue
        endif
c
        if (ncount .gt. 1) then
c
c         Have a duplicate entry or entries.
c
          ilist = ilist + 1
c
          if (ilist .eq. 1) then
c
c           Write error message header.
c
            write (noutpt,1000)
            write (nttyo,1000)
 1000       format(/' * Error - (EQPT/neleck) The following chemical',
     $      ' elements have multiple',/7x,'entries in the elements',
     $      ' block:',/)
          endif
c
          write(ux8,'(i5)') ncount
          call lejust(ux8)
          j3 = ilnobl(ux8)
          j2 = ilnobl(unam)
          write (noutpt,1010) unam(1:j2),ux8(1:j3)
          write (nttyo,1010) unam(1:j2),ux8(1:j3)
 1010     format(9x,a,' has ',a,' entries')
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      nerr = nerr + ilist
c
      end
      subroutine ngasck(nerr,ngt,ngtmax,noutpt,nttyo,ugassp)
c
c     Check the names of gas species for uniqueness.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ugassp = array containing the names of gas species
c
c     Principal output:
c
c       nerr   = incremented error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer noutpt,nttyo
c
      integer ngtmax
c
      integer ngt,nerr
c
      character(len=24) ugassp(ngtmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*24 unam
      character*8 ux8
c
      integer i,ilist,j,j2,j3,k,ncount
c
      integer ilnobl
c
c-----------------------------------------------------------------------
c
c     Note: ilist = the number of species with duplicate species blocks
c     present on the data file.
c
      ilist = 0
c
c     Check each name for uniqueness.
c
      do i = 1,ngt
        unam = ugassp(i)
        ncount = 1
        if (unam(1:7) .ne. '<blank>') then
          do j = i + 1,ngt
            if (unam(1:24) .eq. ugassp(j)(1:24)) then
c
c             Have found a duplicate block moving down the list from
c             the block now being tested for uniqueness. For the first
c             such duplicate block only, make sure that there is not a
c             duplicate block moving up the list from the block now
c             being tested. If there is such a block, then the
c             duplication in question has been noted previously and
c             should not be noted again.
c
              if (ncount .eq. 1) then
                do k = 1,i - 1
                  if (unam(1:24) .eq. ugassp(k)(1:24)) then
c
c                   Have found a duplicate block preceding the block
c                   now being tested for uniqueness.
c
                    go to 100
                  endif
                enddo
              endif
c
c             Have found a duplication that has not been previously
c             noted.
c
              ncount = ncount + 1
            endif
          enddo
  100     continue
        endif
c
        if (ncount .gt. 1) then
c
c         Have a duplicate block or blocks.
c
          ilist = ilist + 1
c
          if (ilist .eq. 1) then
c
c           Write error message header.
c
            write (noutpt,1000)
            write (nttyo,1000)
 1000       format(/' * Error - (EQPT/ngasck) The following gas',
     $      ' species have multiple',/7x,'species blocks:',/)
          endif
c
          write (ux8,'(i5)') ncount
          call lejust(ux8)
          j3 = ilnobl(ux8)
          j2 = ilnobl(unam)
          write (noutpt,1010) unam(1:j2),ux8(1:j3)
          write (nttyo,1010) unam(1:j2),ux8(1:j3)
 1010     format(9x,a,' has ',a,' blocks')
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      nerr = nerr + ilist
c
      end
      subroutine nminck(nerr,nmt,nmtmax,noutpt,nttyo,uminsp)
c
c     Check the names of pure minerals for uniqueness.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       uminsp = array containing the names of pure minerals
c
c     Principal output:
c
c       nerr   = incremented error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer noutpt,nttyo
c
      integer nmtmax
c
      integer nmt,nerr
c
      character(len=24) uminsp(nmtmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*24 unam
      character*8 ux8
c
      integer i,ilist,j,j2,j3,k,ncount
c
      integer ilnobl
c
c-----------------------------------------------------------------------
c
c     Note: ilist = the number of species with duplicate species blocks
c     present on the data file.
c
      ilist = 0
c
c     Check each name for uniqueness.
c
      do i = 1,nmt
        unam = uminsp(i)
        ncount = 1
        if (unam(1:7) .ne. '<blank>') then
          do j = i + 1,nmt
            if (unam(1:24) .eq. uminsp(j)(1:24)) then
c
c             Have found a duplicate block moving down the list from
c             the block now being tested for uniqueness. For the first
c             such duplicate block only, make sure that there is not a
c             duplicate block moving up the list from the block now
c             being tested. If there is such a block, then the
c             duplication in question has been noted previously and
c             should not be noted again.
c
              if (ncount .eq. 1) then
                do k = 1,i - 1
                  if (unam(1:24) .eq. uminsp(k)(1:24)) then
c
c                   Have found a duplicate block preceding the block
c                   now being tested for uniqueness.
c
                    go to 100
                  endif
                enddo
              endif
c
c             Have found a duplication that has not been previously
c             noted.
c
              ncount = ncount + 1
            endif
          enddo
  100     continue
        endif
c
        if (ncount .gt. 1) then
c
c         Have a duplicate block or blocks.
c
          ilist = ilist + 1
c
          if (ilist .eq. 1) then
c
c           Write error message header.
c
            write (noutpt,1000)
            write (nttyo,1000)
 1000       format(/' * Error - (EQPT/nminck) The following pure',
     $      ' minerals have multiple',/7x,'species blocks:',/)
          endif
c
          write (ux8,'(i5)') ncount
          call lejust(ux8)
          j3 = ilnobl(ux8)
          j2 = ilnobl(unam)
          write (noutpt,1010) unam(1:j2),ux8(1:j3)
          write (nttyo,1010) unam(1:j2),ux8(1:j3)
 1010     format(9x,a,' has ',a,' blocks')
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      nerr = nerr + ilist
c
      end
      subroutine nrxnck(nbtmx1,ndrsts,nentri,nerr,qduprs,udrsi)
c
c     Check the associated raection of a species to ensure that
c     each species name appearing in the reaction is unique.
c
c     This subroutine is called by:
c
c       EQPT/rxnsck.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c
c     Principal output:
c
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer nbtmx1
c
      integer nentri(nbtmx1)
c
      integer ndrsts,nerr
c
      logical qduprs
c
      character(len=24) udrsi(nbtmx1)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*24 unam
c
      integer i,j,k,ncount
c
c-----------------------------------------------------------------------
c
      qduprs = .false.
c
c     Check each name for uniqueness.
c
      do i = 1,ndrsts
        unam = udrsi(i)
        ncount = 1
        if (unam(1:7) .ne. '<blank>') then
          do j = i + 1,ndrsts
            if (unam(1:24) .eq. udrsi(j)(1:24)) then
c
c             Have found a duplicate entry moving down the list from
c             the entry now being tested for uniqueness. For the first
c             such duplicate entry only, make sure that there is not a
c             duplicate entry moving up the list from the entry now
c             being tested. If there is such a entry, then the
c             duplication in question has been noted previously and
c             should not be noted again.
c
              if (ncount .eq. 1) then
                do k = 1,i - 1
                  if (unam(1:24) .eq. udrsi(k)(1:24)) then
c
c                   Have found a duplicate entry preceding the entry
c                   now being tested for uniqueness.
c
                    go to 100
                  endif
                enddo
              endif
c
c             Have found a duplication that has not been previously
c             noted.
c
              ncount = ncount + 1
            endif
          enddo
  100     continue
        endif
c
        nentri(i) = ncount
        if (ncount .gt. 1) qduprs = .true.
      enddo
c
      end
      subroutine nssock(nerr,noutpt,nttyo,nxt,nxtmax,ussoph)
c
c     Check the names of solid solutions for uniqueness.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ussoph = array containing the names of solid solutions
c
c     Principal output:
c
c       nerr   = incremented error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer noutpt,nttyo
c
      integer nxtmax
c
      integer nxt,nerr
c
      character(len=24) ussoph(nxtmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*24 unam
      character*8 ux8
c
      integer i,ilist,j,j2,j3,k,ncount
c
      integer ilnobl
c
c-----------------------------------------------------------------------
c
c     Note: ilist = the number of solid solutions with duplicate
c     phase blocks present on the data file.
c
      ilist = 0
c
c     Check each name for uniqueness.
c
      do i = 1,nxt
        unam = ussoph(i)
        ncount = 1
        if (unam(1:7) .ne. '<blank>') then
          do j = i + 1,nxt
            if (unam(1:24) .eq. ussoph(j)(1:24)) then
c
c             Have found a duplicate block moving down the list from
c             the block now being tested for uniqueness. For the first
c             such duplicate block only, make sure that there is not a
c             duplicate block moving up the list from the block now
c             being tested. If there is such a block, then the
c             duplication in question has been noted previously and
c             should not be noted again.
c
              if (ncount .eq. 1) then
                do k = 1,i - 1
                  if (unam(1:24) .eq. ussoph(k)(1:24)) then
c
c                   Have found a duplicate block preceding the block
c                   now being tested for uniqueness.
c
                    go to 100
                  endif
                enddo
              endif
c
c             Have found a duplication that has not been previously
c             noted.
c
              ncount = ncount + 1
            endif
          enddo
  100     continue
        endif
c
        if (ncount .gt. 1) then
c
c         Have a duplicate block or blocks.
c
          ilist = ilist + 1
c
          if (ilist .eq. 1) then
c
c           Write error message header.
c
            write (noutpt,1000)
            write (nttyo,1000)
 1000       format(/' * Error - (EQPT/nssock) The following solid',
     $      ' solutions have multiple',/7x,'phase blocks:',/)
          endif
c
          write (ux8,'(i5)') ncount
          call lejust(ux8)
          j3 = ilnobl(ux8)
          j2 = ilnobl(unam)
          write (noutpt,1010) unam(1:j2),ux8(1:j3)
          write (nttyo,1010) unam(1:j2),ux8(1:j3)
 1010     format(9x,a,' has ',a,' blocks')
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      nerr = nerr + ilist
c
      end
      subroutine nxspck(iktmax,issot,nerr,noutpt,nttyo,nxt,nxtmax,
     $ ussoph,ussosp)
c
c     Check the names of solid solution end-members for uniqueness
c     within each solid solution.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ussoph = array containing the names of solid solutions
c       ussosp = array containing the names of solid solution
c                  end-members
c
c     Principal output:
c
c       nerr   = incremented error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer noutpt,nttyo
c
      integer iktmax,nxtmax
c
      integer nxt,nerr
c
      integer issot(nxtmax)
c
      character(len=24) ussoph(nxtmax)
      character(len=24) ussosp(iktmax,nxtmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*24 unam
      character*8 ux8
c
      integer i,ikt,ilist,j,j2,j3,j4,k,nx,ncount
c
      integer ilnobl
c
c-----------------------------------------------------------------------
c
c     Loop over all solid solution phases.
c
      do nx = 1,nxt
c
        ikt = issot(nx)
c
c       Note: ilist = the number of end-members that are duplicated
c       for a given solid solution.
c
        ilist = 0
c
c       Check each name for uniqueness.
c
        do i = 1,ikt
          unam = ussosp(i,nx)
          ncount = 1
          if (unam(1:7) .ne. '<blank>') then
            do j = i + 1,ikt
              if (unam(1:24) .eq. ussosp(j,nx)(1:24)) then
c
c               Have found a duplicate entry moving down the list from
c               the entry now being tested for uniqueness. For the first
c               such duplicate entry only, make sure that there is not a
c               duplicate entry moving up the list from the entry now
c               being tested. If there is such a entry, then the
c               duplication in question has been noted previously and
c               should not be noted again.
c
                if (ncount .eq. 1) then
                  do k = 1,i - 1
                    if (unam(1:24) .eq. ussosp(k,nx)(1:24)) then
c
c                     Have found a duplicate entry preceding the entry
c                     now being tested for uniqueness.
c
                      go to 100
                    endif
                  enddo
                endif
c
c               Have found a duplication that has not been previously
c               noted.
c
                ncount = ncount + 1
              endif
            enddo
  100       continue
          endif
c
          if (ncount .gt. 1) then
c
c           Have a duplicate entry or entries.
c
            ilist = ilist + 1
c
            if (ilist .eq. 1) then
c
c             Write error message header.
c
              j2 = ilnobl(ussoph(nx))
              write (noutpt,1000) ussoph(nx)(1:j2)
              write (nttyo,1000) ussoph(nx)(1:j2)
 1000         format(/' * Error - (EQPT/nxspck) The following',
     $        ' end-members are listed more than',/7x,'once for solid',
     $        ' solution ',a,':',/)
            endif
c
            write (ux8,'(i5)') ncount
            call lejust(ux8)
            j4 = ilnobl(ux8)
            j3 = ilnobl(unam)
            write (noutpt,1010) unam(1:j3),ux8(1:j4)
            write (nttyo,1010) unam(1:j3),ux8(1:j4)
 1010       format(9x,a,' has ',a,' entries')
          endif
        enddo
c
        nerr = nerr + ilist
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine pcraq(aamatr,apr,atwt,avgrid,cdrs,cdrsi,cess,cessi,
     $ cof,dhfe,dhfs,dvfe,dvfs,eps100,gmmatr,ipch,ipchmx,ipcv,ipcvmx,
     $ ipivot,itgenf,mtotr,nacdpr,narxmx,narxt,nat,natmax,nbt,nbtmx1,
     $ nbtmx2,nch,nco,nct,nctmax,ndata1,ndat0s,ndat1f,ndbmax,ndbptg,
     $ ndbptl,nentei,nentri,nerr,nmodwr,noutpt,nsb,nslist,ntprmx,ntprt,
     $ nttyo,nwarn,qelect,q500fl,tempc,tempcs,tmpcmx,uaqsp,udbfmt,
     $ udbval,udrsi,uelem,uessi,uspec,xdbval,xhfe,xhfs,xlke,xlks,xvfe,
     $ xvfs,xvec,yvec,zaqsp,zchar)
c
c     This subroutine reads data on aqueous species from the stripped
c     DATA0 file, processes this data, and writes the results on the
c     DATA1 and DATA1F files. The counter nerr is incremented by
c     one for each error encountered. The counter nwarn is incremented
c     similarly for each warning.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       narxt  = array of numbers of coefficients in the temperature
c                  ranges
c       nbt    = the number of basis species
c       nct    = the number of chemical elements
c       ndata1 = unit number of the DATA1 file
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c       ndbptg = the number of distinct points on the temperature grid
c       ndbptl = the maximum number of points on the temperature grid
c                  per line
c       ntprt  = the number of temperature ranges on the standard
c                  temperature grid
c       qelect = flag denoting the use of "e-" instead of "O2(g)"
c                  in writing chemical reactions
c       tempc  = array of temperatures (on the temperature grid)
c       tempcs = array of scaled temperatures (on the temperature grid)
c       tmpcmx = the max norm of the tempeatures on the temperature grid
c       udbfmt = the format for reading a line of data on the
c                  temperature grid
c
c
c     Principal output:
c
c       atwt   = array of atomic weights
c       cdrs   = array of reaction coefficients
c       cess   = array of elemental composition coefficients
c       nat    = the number of aqueous species
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c       uaqsp  = array of aqueous species names
c       uelem  = array of names of chemical elements
c       uspec  = array of names of species
c       xlke   = array of log K values for the "Eh" reaction (on the
c                  temperature grid)
c       xlks   = array of log K values for reactions
c       zaqsp  = array of charge numbers of aqueous species
c       zchar  = array of electrical charge numbers of species
c
c     Workspace:
c
c       aamatr = matrix used to calculate the polynomial coefficients
c       apr    = array of polynomial coefficients (for all ranges)
c       avgrid = array containing the data on the temperature grid
c       cof    = array of fitted polynomial coefficients (for a
c                  single temperature range)
c       gmmatr = a copy of the amatr matrix
c       ipivot = the pivot vector, used in solving matrix equations
c       nacdpr = array containging the number of actual data points
c                  by range on the "log K" temperature grid; excludes
c       udbval = string array for reading data on the temperature grid
c       xdbval = holding space array for data on the temperature grid
c       xvec   = array of scaled temperatures corresponding to the
c                  data in the yvec array
c       yvec   = array of data to be fitted (for a single temperature
c                  range)
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipchmx,ipcvmx,narxmx,natmax,nbtmx1,nbtmx2,nctmax,
     $ ndbmax,ntprmx
c
      integer ndata1,ndat0s,ndat1f,noutpt,nslist,nttyo
c
      integer ipivot(narxmx),nacdpr(ntprmx),narxt(ntprmx),
     $ nentei(nctmax),nentri(nbtmx1)
c
      integer ipch,ipcv,itgenf,nat,nbt,nch,nco,nct,ndbptg,ndbptl,nerr,
     $ nmodwr,nsb,ntprt,nwarn
c
      logical qelect,q500fl
c
      character(len=24) uaqsp(natmax),udrsi(nbtmx1),uspec(nbtmx1)
      character(len=16) udbval(ndbmax)
      character(len=8) uelem(nctmax),uessi(nctmax)
c
      character(len=16) udbfmt
c
      real(8) atwt(nctmax),cdrs(nbtmx2,nbtmx1),cdrsi(nbtmx1),
     $ cess(nctmax,nbtmx1),cessi(nctmax),dhfe(narxmx,ntprmx,ipchmx),
     $ dhfs(narxmx,ntprmx,ipchmx,nbtmx1),dvfe(narxmx,ntprmx,ipcvmx),
     $ dvfs(narxmx,ntprmx,ipcvmx,nbtmx1),xhfe(narxmx,ntprmx),
     $ xhfs(narxmx,ntprmx,nbtmx1),xlke(narxmx,ntprmx),
     $ xlks(narxmx,ntprmx,nbtmx1),xvfe(narxmx,ntprmx),
     $ xvfs(narxmx,ntprmx,nbtmx1),zchar(nbtmx1),zaqsp(natmax)
c
      real(8) apr(narxmx,ntprmx),avgrid(narxmx,ntprmx)
      real(8) tempc(narxmx,ntprmx),tempcs(narxmx,ntprmx),tmpcmx(ntprmx)
      real(8) aamatr(narxmx,narxmx),gmmatr(narxmx,narxmx)
      real(8) cof(narxmx),xvec(narxmx),yvec(narxmx)
      real(8) xdbval(ndbmax),mtotr(nctmax)
c
      real(8) eps100
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ii,ipc,j,j2,j3,j4,j5,k,n,nbt1,nbw,nc,ncount,ncts,ndrsts,
     $ nmodx,nn,nnx,ns,nse,nsm1,nspnx,nt,ntpr,nxm
c
      integer ilnobl
c
      logical qblkes,qblkrs,qend,qerr,qnofes,qnofrs,qzeres,qzerrs,
     $ q500nd
c
      character(len=24) uspn(2)
c
      character(len=80) ulbufa,ulbufb,uline,ux80
      character(len=72) uterm,utermc
      character(len=56) ustrgr
      character(len=24) uaq24,uend24,ublk24,unone,usblkf,ux24
      character(len=16) ux16
      character(len=8) uaqu,uaux,ux8,ux8a,ux8b,ux8c,uendit,usol
c
      real(8) mwtss,zx
c
c-----------------------------------------------------------------------
c
      data ublk24 /'                        '/
      data uaq24 /'aqueous                 '/
      data unone /'none                    '/
      data uendit /'endit.  '/
      data uaux /'auxiliar'/
      data uaqu /'aqueous '/
      data usol /'solids  '/
c
c-----------------------------------------------------------------------
c
      uterm(1:48) = '+-----------------------------------------------'
      uterm(49:72) = '------------------------'
      utermc = uterm
      utermc(1:1) = '*'
c
c     The variable nn must be set to zero here to provide a proper
c     diagnostic if an early end-of-file or read format error occurs.
c
      nn = 0
c
      q500nd = q500fl
c
c     Set the expected index of H2O.
c
      nbw = 1
c
c     Skip 2 lines to the 'basis species' delimiter.
c
      read (ndat0s,1000,end=990,err=995) uline
      read (ndat0s,1000,end=990,err=995) uline
 1000 format(a)
c
c     Write label.
c
      usblkf = uaq24
      j3 = ilnobl(uaq24)
      write (ndata1) uaq24
      write (ndat1f,1010) uaq24(1:j3)
 1010 format(a)
      write (ndat1f,1010) utermc(1:72)
      write (noutpt,1020) uaq24(1:j3)
      write (nttyo,1020) uaq24(1:j3)
      write (nslist,1020) uaq24(1:j3)
 1020 format(//1x,a,/)
c
c     Initialize some variables.
c
      qelect = .false.
      uend24(1:8) = uendit(1:8)
      uend24(9:24) = ublk24(9:24)
      uspn(1) = unone
      uspn(2) = ublk24
      nspnx = 1
      nnx = -1
      nn = 1
      nmodx = 0
      nbt1 = nbt + 1
      nat = 0
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Note: the main loop returns here.
c
  100 ns = min(nn,nbt1)
      ncts = 0
      ndrsts = 0
c
      do nc = 1,nct
        cess(nc,ns) = 0.
        cessi(nc) = 0.
      enddo
c
      do nse = 1,nbt1
        cdrs(nse,ns) = 0.
        cdrsi(nse) = 0.
      enddo
      cdrs(nbt + 2,ns) = 0.
c
      call initcv(uessi,nct,' ')
      call initcv(udrsi,nbt1,' ')
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the first line of the block.
c
  110 continue
      read (ndat0s,1000,end=990,err=995) uline
      ux24 = uline(1:24)
      ux8 = ux24(1:8)
c
      if (ux8(1:8).eq.uaux(1:8) .or. ux8(1:8).eq.uaqu(1:8)) then
c
c       Skip the terminator line, read the next line.
c
        read (ndat0s,1000,end=990,err=995) uline
        go to 110
c
      elseif (ux8(1:8) .eq. usol(1:8)) then
c
c       Skip the terminator line.
c
        read (ndat0s,1000,end=990,err=995) uline
c
c       Finish and exit here.
c
        if (uspn(1)(1:24) .eq. unone(1:24)) then
          nnx = 0
          nn = 0
          write (nttyo,1140) nnx,unone(1:4)
          write (nslist,1140) nnx,unone(1:4)
 1140     format(1x,i5,2x,a)
          write (noutpt,1150) nn,unone(1:4)
 1150     format(1x,i5,1x,a)
        else
          nxm = nspnx - 1
          if (nxm .ge. 1) then
            nnx = nnx + 2
            if (nxm .eq. 1) then
              j3 = ilnobl(uspn(1))
              write (nttyo,1140) nnx,uspn(1)(1:j3)
              write (nslist,1140) nnx,uspn(1)(1:j3)
            else
              j3 = ilnobl(uspn(2))
              write (nttyo,1160) nnx,uspn(1),uspn(2)(1:j3)
              write (nslist,1160) nnx,uspn(1),uspn(2)(1:j3)
 1160         format(1x,i5,2x,a24,2x,a)
            endif
          elseif (nmodx .ne. 1) then
            j3 = ilnobl(uspn(2))
            write (nttyo,1160) nnx,uspn(1),uspn(2)(1:j3)
          endif
        endif
        write (ndata1) uend24,ublk24,ublk24
        j3 = ilnobl(uend24)
        write (ndat1f,1010) uend24(1:j3)
        write (ndat1f,1010) utermc(1:72)
        if (nerr .gt. 0) stop
        go to 999
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Have a species block.
c
      nat = nat + 1
c
      j2 = ilnobl(ux24)
      if (j2 .le. 0) then
        write (ux8a,'(i5)') nat
        call lejust(ux8a)
        j3 = ilnobl(ux8a)
        j4 = ilnobl(usblkf)
        write (noutpt,1240) ux8a(1:j3),usblkf(1:j4)
        write (nttyo,1240) ux8a(1:j3),usblkf(1:j4)
 1240   format(/' * Error - (EQPT/pcraq) Have encountered a blank',
     $  ' species name',/7x,'for species block ',a,' of the ',a,
     $  ' superblock.')
        if (nat .gt. 1) then
          ux24 = uaqsp(nat - 1)
          j5 = ilnobl(ux24)
          if (j5 .gt. 0) then
            write (noutpt,1250) ux24(1:j5)
            write (nttyo,1250) ux24(1:j5)
 1250       format(7x,'This block follows the one for ',a,'.')
          endif
        endif
        ux24 = '<blank>'
        nerr = nerr + 1
      endif
c
      uaqsp(nat) = ux24
      uspec(ns) = ux24
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Save the species name for screen and SLIST output.
c
      uspn(nspnx) = uspec(ns)
c
c     Write the species name on the OUTPUT file.
c
      j2 = ilnobl(uspec(ns))
      write (noutpt,1150) nn,uspec(ns)(1:j2)
c
c     Write species names two per line on the SLIST file.
c
      nspnx = nspnx + 1
      if (nspnx .gt. 2) then
        nspnx = 1
        nnx = nnx + 2
        nmodx = mod(nnx,nmodwr)
        if (nmodwr .eq. 1) nmodx = 1
        j3 = ilnobl(uspn(2))
        if (nmodx .eq. 1) write (nttyo,1160) nnx,uspn(1),uspn(2)(1:j3)
        write (nslist,1160) nnx,uspn(1),uspn(2)(1:j3)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Skip the obsolete 'sp.type =' and 'revised =' lines.
c     Read the electrical charge.
c
  130 read (ndat0s,1000,end=990,err=995) uline
      ii = index(uline,'charge')
      if (ii .eq. 0) go to 130
c
      ux80 = uline(ii + 6:80)
      ii = index(ux80,'=')
      ux16 = ux80(ii + 1:80)
      call lejust(ux16)
      read (ux16,'(f5.1)',err=995) zx
c1280 format(14x,f5.1)
      zaqsp(nat) = zx
      zchar(ns) = zx
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the number of chemical elements composing the species.
c
      read (ndat0s,1000,end=990,err=995) uline
      ux80 = uline
      call lejust(ux80)
      ii = index(ux80,'element(s)')
      if (ii .gt. 1) then
        ux16 = ux80(1:ii - 1)
        read (ux16,'(i5)',err=995) ncts
c1330   format(4x,i2)
      else
        ii = index(ux80,' ')
        if (ii .gt. 1) then
          ux16 = ux80(1:ii - 1)
          read (ux16,'(i5)',err=995) ncts
        else
          ncts = 0
        endif
      endif
c
      if (ncts .gt. nct) then
        j2 = ilnobl(uspec(ns))
        write (ux8a,'(i5)') ncts
        call lejust(ux8a)
        j3 = ilnobl(ux8a)
        write (ux8c,'(i5)') nct
        call lejust(ux8c)
        j5 = ilnobl(ux8c)
        write (noutpt,1350) uspec(ns)(1:j2),ux8a(1:j3),ux8c(1:j5)
        write (nttyo,1350) uspec(ns)(1:j2),ux8a(1:j3),ux8c(1:j5)
 1350   format(/' * Error - (EQPT/pcraq) Species "',a,'" is',
     $  ' composed of ',a,/7x,'chemical elements, but there',
     $  ' are only ',a,' elements on the data file.')
        nerr = nerr + 1
      endif
c
      if (ncts .le. 0) then
        if (uspec(ns)(1:3).ne.'e- ' .and. uspec(ns)(1:3).ne.'E- ') then
          j2 = ilnobl(uspec(ns))
          write (noutpt,1360) uspec(ns)(1:j2)
          write (nttyo,1360) uspec(ns)(1:j2)
 1360     format(/' * Error - (EQPT/pcraq) Species "',a,'" is not',
     $    ' composed of',/7x,'any chemical elements.')
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the names of the elements and the corresponding
c     compositional coefficients.
c
      n = 0
      do i = 1,ncts/3
        read (ndat0s,1000,end=990,err=995) uline
        ulbufa = uline
        do k = 1,3
          call lejust(ulbufa)
          ii = index(ulbufa,' ')
          if (ii .gt. 1) then
            ux16 = ulbufa(1:ii - 1)
            read (ux16,'(f8.4)',err=995) cessi(n + k)
          else
            cessi(n + k) = 0.
          endif
          ulbufb = ulbufa(ii + 1:80)
          call lejust(ulbufb)
          uessi(n + k) = ulbufb(1:8)
          if (k .lt. 3) ulbufa = ulbufb(9:80)
        enddo
c       read (uline,1370,err=995) (cessi(n + k),uessi(n + k), k = 1,3)
c1370   format((4x,3(f8.4,1x,a8,5x)))
        n = n + 3
      enddo
c
      j = mod(ncts,3)
      if (j .gt. 0) then
        read (ndat0s,1000,end=990,err=995) uline
        ulbufa = uline
        do k = 1,j
          call lejust(ulbufa)
          ii = index(ulbufa,' ')
          if (ii .gt. 1) then
            ux16 = ulbufa(1:ii - 1)
            read (ux16,'(f8.4)',err=995) cessi(n + k)
          else
            cessi(n + k) = 0.
          endif
          ulbufb = ulbufa(ii + 1:80)
          call lejust(ulbufb)
          uessi(n + k) = ulbufb(1:8)
          if (k .lt. j) ulbufa = ulbufb(9:80)
        enddo
c       read (uline,1370,err=995) (cessi(n + k),uessi(n + k), k = 1,j)
        n = n + j
      endif
c
c     Check for blank element names, duplicate element names, and
c     zero-valued stoichiometric coefficients.
c
      call elesck(cessi,nbtmx1,nctmax,ncts,nentei,nerr,noutpt,
     $ ns,nttyo,qblkes,qzeres,uessi,usblkf,uspec)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (ns .eq. nbw) then
c
c       Make sure that H2O is the first aqueous species.
c
        if (uspec(nbw)(1:4) .ne. 'H2O ') then
          j2 = ilnobl(uspec(nbw))
          write (noutpt,1420) uspec(nbw)(1:j2)
          write (nttyo,1420) uspec(nbw)(1:j2)
 1420     format(/' * Error - (EQPT/pcraq) The first strict basis',
     $    ' species on the data file',/7x,'is ',a,'. The first',
     $    ' strict basis species must be H2O.',/7x,'This is an',
     $    ' idiosyncrasy of EQ3/6.')
          nerr = nerr + 1
        endif
      endif
c
      if (ns .le. nsb) then
c
c       A strict basis species may be composed of only one chemical
c       element other than O or H.
c
        ncount = 0
        do i = 1,ncts
          if (cessi(i) .gt. 0.) then
            if (uessi(i)(1:2).ne.'O ' .and. uessi(i)(1:2).ne.'H ' .and.
     $      uessi(i)(1:7).ne.'<blank>') ncount = ncount + 1
          endif
        enddo
c
        if (ncount .gt. 1) then
          j2 = ilnobl(uspec(ns))
          write (noutpt,1430) uspec(ns)(1:j2)
          write (nttyo,1430) uspec(ns)(1:j2)
 1430     format(/' * Error - (EQPT/pcraq) The strict basis species ',
     $    a,' is composed',/7x,'of more than one chemical element',
     $    ' other than O and H.')
          nerr = nerr + 1
        endif
      endif
c
      if (ns .le. nct) then
c
c       Make sure that there is a 1:1 mapping to the chemical elements
c       for the first nct members of the strict basis set.
c
c       H2O (solvent water) is a special case. H2O always maps to O.
c       Since the first chemical element is required to be O, the first
c       aqueous species is required to  be H2O. Here it is sufficient
c       to make sure that that indeed is the case.
c
        if (ns .eq. 1) then
          if (uspec(ns)(1:4) .ne. 'H2O ') then
            j2 = ilnobl(uspec(ns))
            write (noutpt,1440) uspec(ns)(1:j2)
            write (nttyo,1440) uspec(ns)(1:j2)
 1440       format(/' * Error - (EQPT/pcraq) The first aqueous species',
     $      ' is ',a,'.',/7x,'The first aqueous species must be H2O.')
            nerr = nerr + 1
          endif
        endif
c
c       The hydrogen ion is also a special case. H+ always maps to H.
c
        if (uspec(ns)(1:3) .eq. 'H+ ') then
          nc = ns
          if (uelem(nc)(1:2) .ne. 'H ') then
            j2 = ilnobl(uspec(ns))
            write (noutpt,1450)
            write (nttyo,1450)
 1450       format(/' * Error - (EQPT/pcraq) The species H+ is',
     $      ' required to match',/7x,'the chemical element H. If the',
     $      ' species is the n-th member of',/7x,'the strict',
     $      ' basis set, the corresponding chemical element must be',
     $      /7x,'the n-th chemical element (there is one exception',
     $      ' to this rule,',/7x,"the redox species, which doesn't",
     $      ' correspond to any chemical element).')
            nerr = nerr + 1
          endif
        endif
c
c       Any strict basis species, other than the redox species,
c       must be composed of the chemical element to which it
c       formally corresponds.
c
        nc = ns
        do i = 1,ncts
          if (uessi(i)(1:8) .eq. uelem(nc)(1:8)) then
            if (cessi(i) .gt. 0.) go to 120
          endif
        enddo
c
        j2 = ilnobl(uspec(ns))
        j3 = ilnobl(uelem(nc))
        write (noutpt,1460) uspec(ns)(1:j2),uelem(nc)(1:j3)
        write (nttyo,1460) uspec(ns)(1:j2),uelem(nc)(1:j3)
 1460   format(/' * Error - (EQPT/pcraq) The strict basis',
     $  ' species ',a,' is not',/7x,'composed of the chemical',
     $  ' element ',a,' to which it must correspond.',
     $  /7x,'If the species is the n-th member of the strict',
     $  ' basis set,',/7x,'the, corresponding chemical',
     $  ' element must be the n-th chemical element.',
     $  /7x,'There is one exception to this rule, the',
     $  ' redox species. It must be',/7x,'the last strict',
     $  " basis species, if present. It doesn't correspond",
     $  /7x,'to any chemical element.')
        nerr = nerr + 1
  120   continue
      endif
c
c     Check out the redox species.
c
      if (ns .eq. nsb) then
        if (uspec(ns)(1:6).ne.'O2(g) ' .and.
     $    uspec(ns)(1:3).ne.'e- ' .and.
     $    uspec(ns)(1:3).ne.'E- ') then
          j2 = ilnobl(uspec(ns))
          write (noutpt,1470) uspec(ns)(1:j2)
          write (nttyo,1470) uspec(ns)(1:j2)
 1470     format(/' * Error - (EQPT/pcraq) The redox species is ',a,
     $    '. This must',/7x,'be either O2(g) or e-.')
          nerr = nerr + 1
        endif
      endif
c
      if (ns .eq. nsb) then
        if (nerr .gt. 0) stop
      endif
c
      if (ns .eq. nbt) then
        if (nerr .gt. 0) stop
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (ns .gt. nsb) then
c
c       Read number of species in the associated reaction.
c
        read (ndat0s,1000,end=990,err=995) uline
        ux80 = uline
        call lejust(ux80)
        ii = index(ux80,'species')
        if (ii .gt. 1) then
          ux16 = ux80(1:ii - 1)
          read (ux16,'(i5)',err=995) ndrsts
c1500   format(4x,i2)
        else
          ii = index(ux80,' ')
          if (ii .gt. 1) then
            ux16 = ux80(1:ii - 1)
            read (ux16,'(i5)',err=995) ndrsts
          else
            ndrsts = 0
          endif
        endif
c
        if (ndrsts .gt. nbt1) then
          j2 = ilnobl(uspec(ns))
          write (ux8a,'(i5)') ndrsts
          call lejust(ux8a)
          j3 = ilnobl(ux8a)
          write (ux8b,'(i5)') nbt
          call lejust(ux8b)
          j4 = ilnobl(ux8b)
          write (ux8c,'(i5)') nbt1
          call lejust(ux8c)
          j5 = ilnobl(ux8c)
          write (noutpt,1520) uspec(ns)(1:j2),ux8a(1:j3),ux8b(1:j4),
     $    ux8c(1:j5)
          write (nttyo,1520) uspec(ns)(1:j2),ux8a(1:j3),ux8b(1:j4),
     $    ux8c(1:j5)
 1520     format(/' * Error - (EQPT/pcraq) The reaction for the',
     $    /7x,'destruction of species "',a,'" includes ',a,
     $    /7x,'species, but there are only ',a,' basis species on the',
     $    /7x,'data file, so only ',a,' species may appear in the ',
     $    'reaction.')
          nerr = nerr + 1
        endif
c
        if (ndrsts .lt. 2) then
          j2 = ilnobl(uspec(ns))
          j4 = ilnobl(usblkf)
          write (noutpt,1530) uspec(ns)(1:j2),usblkf(1:j4)
          write (nttyo,1530) uspec(ns)(1:j2),usblkf(1:j4)
 1530     format(/' * Error - (EQPT/pcraq) The species ',a,
     $    ' appearing',/7x,'on the data file in the ',a,' superblock',
     $    ' has fewer than',/7x,'two species in its associated',
     $    ' reaction. This is not a',/7x,'valid reaction.')
          nerr = nerr + 1
        endif
c
c       Read the names of the species in the reaction and the
c       corresponding reaction coefficients.
c
        n = 0
        do i = 1,ndrsts/2
          read (ndat0s,1000,end=990,err=995) uline
          ulbufa = uline
          do k = 1,2
            call lejust(ulbufa)
            ii = index(ulbufa,' ')
            if (ii .gt. 1) then
              ux16 = ulbufa(1:ii - 1)
              read (ux16,'(f10.4)',err=995) cdrsi(n + k)
            else
              cdrsi(n + k) = 0.
            endif
            ulbufb = ulbufa(ii + 1:80)
            call lejust(ulbufb)
            udrsi(n + k) = ulbufb(1:24)
            if (k .lt. 2) ulbufa = ulbufb(25:80)
          enddo
c         read (uline,1540,err=995) (cdrsi(n + k),udrsi(n + k), k = 1,2)
c1540     format((2(1x,f10.4,2x,a24)))
          n = n + 2
        enddo
c
        j = mod(ndrsts,2)
        if (j .gt. 0) then
          read (ndat0s,1000,end=990,err=995) uline
          ulbufa = uline
          do k = 1,j
            call lejust(ulbufa)
            ii = index(ulbufa,' ')
            if (ii .gt. 1) then
              ux16 = ulbufa(1:ii - 1)
              read (ux16,'(f10.4)',err=995) cdrsi(n + k)
            else
              cdrsi(n + k) = 0.
            endif
            ulbufb = ulbufa(ii + 1:80)
            call lejust(ulbufb)
            udrsi(n + k) = ulbufb(1:24)
            if (k .lt. j) ulbufa = ulbufb(25:80)
          enddo
c         read (uline,1540,err=995) (cdrsi(n + k),udrsi(n + k), k = 1,j)
          n = n + j
        endif
c
c       Check for blank species names, duplicate species names, and
c       zero-valued reaction coefficients. Check that the reaction
c       coefficient of the species with which the reaction is
c       associated has a negative value.
c
        call rxnsck(nbtmx1,cdrsi,nct,ndrsts,nentri,nerr,noutpt,
     $  ns,nsb,nttyo,qblkrs,qzerrs,udrsi,usblkf,uspec)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c       Read the log K grid for the current species.
c       Return the data in the xdbval holding array.
c
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the xlks array.
c
c       Calling sequence substitutions:
c         ns for ipc
c         nbtmx1 for ipcmax
c         xlks for zdbval
c
        call ldbar3(ns,nbtmx1,nacdpr,narxmx,narxt,ndbmax,
     $  ntprmx,ntprt,xdbval,xlks)
c
        if (itgenf .ge. 0) then
c
c         Test the grid ranges for sparseness of actual data.
c
          ustrgr = 'the log K for ' // uspec(ns)
          call tegrid(itgenf,nacdpr,narxt,nerr,noutpt,ntprmx,
     $    ntprt,nttyo,nwarn,ustrgr)
        endif
      endif
c
c     In the case of a strict basis species (a species which has no
c     real associated reaction), xhfs is the partial molar enthalpy
c     of formation and xvfs is the partial molar volume. In the case
c     of all other species, there is a real associated reaction and
c     xhfs is then the partial molar enthalpy of reaction and xvfs
c     is the partial molar volume of reaction.
c
      if (ipch .ge. 0) then
c
c       Read the enthalpy function grid for the current species.
c       Return the data in the xdbval holding array.
c
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the xhfs array.
c
c       Calling sequence substitutions:
c         ns for ipc
c         nbtmx1 for ipcmax
c         xhfs for zdbval
c
        call ldbar3(ns,nbtmx1,nacdpr,narxmx,narxt,ndbmax,
     $  ntprmx,ntprt,xdbval,xhfs)
c
        if (itgenf .ge. 0) then
c
c         Test the grid ranges for sparseness of actual data.
c
          ustrgr = 'the enthalpy function for ' // uspec(ns)
          call tegrid(itgenf,nacdpr,narxt,nerr,noutpt,ntprmx,
     $    ntprt,nttyo,nwarn,ustrgr)
        endif
c
        do ipc = 1,ipch
c
c         Read the enthalpy function derivative grid for the current
c         species. Return the data in the xdbval holding array.
c
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the dhfs array.
c
c         Calling sequence substitutions:
c           ipchmx for ipcmax
c           dhfs for zdbval
c
          call ldbar4(ipc,ipchmx,nacdpr,narxmx,narxt,nbtmx1,
     $    ndbmax,ns,ntprmx,ntprt,xdbval,dhfs)
        enddo
      endif
c
      if (ipcv .ge. 0) then
c
c       Read the volume function grid for the current species.
c       Return the data in the xdbval holding array.
c
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the xvfs array.
c
c       Calling sequence substitutions:
c         ns for ipc
c         nbtmx1 for ipcmax
c         xvfs for zdbval
c
        call ldbar3(ns,nbtmx1,nacdpr,narxmx,narxt,ndbmax,
     $  ntprmx,ntprt,xdbval,xvfs)
c
        if (itgenf .ge. 0) then
c
c         Test the grid ranges for sparseness of actual data.
c
          ustrgr = 'the volume function for ' // uspec(ns)
          call tegrid(itgenf,nacdpr,narxt,nerr,noutpt,ntprmx,
     $    ntprt,nttyo,nwarn,ustrgr)
        endif
c
        do ipc = 1,ipcv
c
c         Read the volume function derivative grid for the current
c         species. Return the data in the xdbval holding array.
c
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the dvfs array.
c
c         Calling sequence substitutions:
c           ipcvmx for ipcmax
c           dvfs for zdbval
c
          call ldbar4(ipc,ipcvmx,nacdpr,narxmx,narxt,nbtmx1,
     $    ndbmax,ns,ntprmx,ntprt,xdbval,dvfs)
        enddo
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check the redox species in the strict basis set. Set the
c     appropriate flags.
c
      if (ns .eq. nsb) then
        qelect = uspec(ns)(1:3).eq.'e- '
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     If the strict basis redox species is e-, change it to O2(g).
c
      if (ns .eq. nsb) then
        if (qelect) then
          uspec(ns) = 'O2(g)'
          ncts = 1
          uessi(1) = 'O'
          cessi(1) = 2
          zchar(ns) = 0.
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     If the reaction is written in terms of e-, rewrite it in terms
c     of O2(g).
c
      if (qelect) then
        if (ns .gt. nsb) then
          call etoo2(cdrsi,dhfe,dhfs,dvfe,dvfs,ipch,ipchmx,ipcv,
     $    ipcvmx,narxmx,narxt,nbtmx1,ndrsts,ns,ntprmx,ntprt,udrsi,
     $    xhfe,xhfs,xlke,xlks,xvfe,xvfs)
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Process the species data.
c
      mwtss = 0.
      qnofes = .false.
      do n = 1,ncts
c
c       Search for element name in the uelem array.
c
        ux8 = uessi(n)(1:8)
        if (ux8(1:7) .ne. '<blank>') then
c
          do nc = 1,nct
            if (ux8(1:8) .eq. uelem(nc)(1:8)) then
              cess(nc,ns) = cess(nc,ns) + cessi(n)
              mwtss = mwtss + atwt(nc)*cessi(n)
              go to 220
            endif
          enddo
c
c         Error, not found.
c
          if (ns .gt. nsb) then
            j2 = ilnobl(uspec(ns))
            j3 = ilnobl(ux8)
            write (noutpt,1760) ux8(1:j3),uspec(ns)(1:j2)
            write (nttyo,1760) ux8(1:j3),uspec(ns)(1:j2)
 1760       format(/' * Error - (EQPT/pcraq) Unrecognized chemical',
     $      ' element "',a,'" is listed',/7x,'in the composition of',
     $      ' the species ',a,'.')
            nerr = nerr + 1
            qnofes = .true.
          endif
        endif
  220   continue
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      write (ndata1) uspec(ns),ncts,ndrsts
      write (ndat1f,1800) uspec(ns),ncts,ndrsts
 1800 format(a24,2x,2i5)
c
      write (ndata1) mwtss,zchar(ns)
      write (ndat1f,1810) mwtss,zchar(ns)
 1810 format(5x,f10.3,f5.0)
c
      if (ncts .gt. 0) then
        write (ndata1) (cessi(n),uessi(n), n = 1,ncts)
        n = 1
  230   continue
        if (n .eq. ncts) then
          j4 = ilnobl(uessi(n))
          write (ndat1f,1820) cessi(n),uessi(n)(1:j4)
 1820     format(1x,f10.4,2x,a)
          n = n + 1
        else
          j4 = ilnobl(uessi(n + 1))
          write (ndat1f,1830) cessi(n),uessi(n),
     $    cessi(n + 1),uessi(n + 1)(1:j4)
 1830     format(1x,f10.4,2x,a8,1x,f10.4,2x,a)
          n = n + 2
        endif
        if (n .le. ncts) go to 230
      endif
c
      if (ns .le. nsb) go to 270
c
      write (ndata1) (cdrsi(n),udrsi(n), n = 1,ndrsts)
      n = 1
c
  240 continue
      if (n .eq. ndrsts) then
        j4 = ilnobl(udrsi(n))
        write (ndat1f,1860) cdrsi(n),udrsi(n)(1:j4)
 1860   format(1x,f10.4,2x,a)
        n = n + 1
      else
        j4 = ilnobl(udrsi(n + 1))
        write (ndat1f,1870) cdrsi(n),udrsi(n),
     $  cdrsi(n + 1),udrsi(n + 1)(1:j4)
 1870   format(1x,f10.4,2x,a24,1x,f10.4,2x,a)
        n = n + 2
      endif
      if (n .le. ndrsts) go to 240
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      qnofrs = .false.
      cdrs(nbt1,ns) = cdrsi(1)
      do n = 2,ndrsts
c
c       Search for species name in the uspec array.
c
        ux24 = udrsi(n)
        if (ux24(1:7) .ne. '<blank>') then
c
          do nse = 1,nbt
            if (ux24 .eq. uspec(nse)) then
              cdrs(nse,ns) = cdrs(nse,ns) + cdrsi(n)
              go to 250
            endif
          enddo
c
c         Error, not found.
c
          j2 = ilnobl(uspec(ns))
          j3 = ilnobl(ux24)
          write (noutpt,1880) uspec(ns)(1:j2),ux24(1:j3)
          write (nttyo,1880) uspec(ns)(1:j2),ux24(1:j3)
 1880     format(/' * Error - (EQPT/pcraq) The reaction which destroys',
     $    /7x,'non-basis species ',a,' is written in terms of an',
     $     /7x,'unrecognized basis species "',a,'".')
          nerr = nerr + 1
          qnofrs = .true.
  250     continue
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Test the reaction for mass and charge balance.
c     Skip if there are already obvious problems.
c
      if (ndrsts .ge. 2) then
        if (.not.qblkes .and. .not.qnofes) then
          if (.not.qblkrs .and. .not.qnofrs) then
            call rxnchk(cdrs,cess,mtotr,nbt,nbtmx1,nbtmx2,nco,
     $      nct,nctmax,nerr,noutpt,ns,nsb,nttyo,uelem,uspec,zchar)
          endif
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Fit interpolating polynomials to the log K grid.
c
      do ntpr = 1,ntprt
        do n = 1,narxt(ntpr)
          avgrid(n,ntpr) = xlks(n,ntpr,ns)
        enddo
      enddo
c
      call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $ narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $ xvec,yvec)
c
      ux24 = 'Log K'
      j2 = ilnobl(ux24)
      write (ndata1) ux24
      write (ndat1f,1010) ux24(1:j2)
c
      do ntpr = 1,ntprt
        nt = narxt(ntpr)
        write (ndata1) (apr(i,ntpr), i = 1,nt)
        write (ndat1f,1890) (apr(i,ntpr), i = 1,nt)
 1890   format( 5(1pe16.9) )
      enddo
c
  270 continue
c
      if (ipch .ge. 0) then
c
c       Fit interpolating polynomials to the enthalpy function grid.
c
        do ntpr = 1,ntprt
          do n = 1,narxt(ntpr)
            avgrid(n,ntpr) = xhfs(n,ntpr,ns)
          enddo
        enddo
c
        call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'Enthalpy'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1890) (apr(i,ntpr), i = 1,nt)
        enddo
c
c       Fit interpolating polynomials to the grids for its
c       pressure derivatives.
c
        do ipc = 1,ipch
c
          do ntpr = 1,ntprt
            do n = 1,narxt(ntpr)
              avgrid(n,ntpr) = dhfs(n,ntpr,ipc,ns)
            enddo
          enddo
c
          call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'dhfs( )'
          write (ux24(6:6),'(i1)') ipc
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1890) (apr(i,ntpr), i = 1,nt)
          enddo
        enddo
      endif
c
      if (ipcv .ge. 0) then
c
c       Fit interpolating polynomials to the volume function grid.
c
        do ntpr = 1,ntprt
          do n = 1,narxt(ntpr)
            avgrid(n,ntpr) = xvfs(n,ntpr,ns)
          enddo
        enddo
c
        call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'Volume'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1890) (apr(i,ntpr), i = 1,nt)
        enddo
c
c       Fit interpolating polynomials to the grids for its
c       pressure derivatives.
c
        do ipc = 1,ipcv
c
          do ntpr = 1,ntprt
            do n = 1,narxt(ntpr)
              avgrid(n,ntpr) = dvfs(n,ntpr,ipc,ns)
            enddo
          enddo
c
          call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'dvfs( )'
          write (ux24(6:6),'(i1)') ipc
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1890) (apr(i,ntpr), i = 1,nt)
          enddo
        enddo
      endif
c
      write (ndat1f,1010) utermc(1:72)
c
c     Look for another species block or terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
      nn = nn + 1
      go to 100
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/pcraq) Unexpectedly encountered',
     $ /7x,'end-of-file while reading the DATA0 file.')
c
      write (noutpt,2010) nn
      write (nttyo,2010) nn
 2010 format(7x,'The value of the species block counter is ',i3,'.')
      if (ns .gt. 0) then
        j2 = ilnobl(uspec(ns))
        if (j2 .gt. 0) then
          write (noutpt,2020) uspec(ns)(1:j2)
          write (nttyo,2020) uspec(ns)(1:j2)
 2020     format(7x,'The last species name read was "',a,'".')
        else
          nsm1 = ns - 1
          if ((nsm1) .gt. 0) then
            j2 = ilnobl(uspec(nsm1))
            if (j2 .gt. 0) then
              write (noutpt,2020) uspec(nsm1)(1:j2)
              write (nttyo,2020) uspec(nsm1)(1:j2)
            endif
          endif
        endif
      endif
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,70)
        write (noutpt,2030) uline(1:j2)
        write (nttyo,2030) uline(1:j2)
 2030   format(7x,'The last line read was the following:',
     $  /7x,'"',a,'"')
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  995 write (noutpt,2040)
      write (nttyo,2040)
 2040 format(/' * Error - (EQPT/pcraq) Encountered a read format',
     $ /7x,'error while reading the DATA0 file.')
c
      write (noutpt,2010) nn
      write (nttyo,2010) nn
      if (ns .gt. 0) then
        j2 = ilnobl(uspec(ns))
        if (j2 .gt. 0) then
          write (noutpt,2020) uspec(ns)(1:j2)
          write (nttyo,2020) uspec(ns)(1:j2)
        else
          nsm1 = ns - 1
          if ((nsm1) .gt. 0) then
            j2 = ilnobl(uspec(nsm1))
            if (j2 .gt. 0) then
              write (noutpt,2020) uspec(nsm1)(1:j2)
              write (nttyo,2020) uspec(nsm1)(1:j2)
            endif
          endif
        endif
      endif
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,67)
        write (noutpt,2030) uline(1:j2)
        write (nttyo,2030) uline(1:j2)
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine pcrsg(aamatr,apr,atwt,avgrid,cdrs,cdrsi,cess,cessi,
     $ cof,dhfe,dhfs,dvfe,dvfs,eps100,gmmatr,ipch,ipchmx,ipcv,ipcvmx,
     $ ipivot,itgenf,mtotr,nacdpr,narxmx,narxt,nat,natmax,nbt,nbtmx1,
     $ nbtmx2,nch,nco,nct,nctmax,ndata1,ndat0s,ndat1f,ndbmax,ndbptg,
     $ ndbptl,nentei,nentri,nerr,ngt,ngtmax,nlt,nltmax,nmodwr,nmt,
     $ nmtmax,noutpt,nsb,nslist,ntprmx,ntprt,nttyo,nwarn,qelect,
     $ q500fl,tempc,tempcs,tmpcmx,udbfmt,udbval,udrsi,uelem,uessi,
     $ ugassp,uliqsp,uminsp,uspec,xdbval,xhfe,xhfs,xlke,xlks,xvfe,
     $ xvfs,xvec,yvec,zchar)
c
c     This subroutine reads data on solid and gas species from the
c     stripped DATA0 file, processes this data, and writes the results
c     on the DATA1 and DATA1F files. The counter nerr is incremented
c     by one for each error encountered. The counter nwarn is similarly
c     incremented for each warning.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       narxt  = array of numbers of coefficients in the temperature
c                  ranges
c       nbt    = the number of basis species
c       nct    = the number of chemical elements
c       ndata1 = unit number of the DATA1 file
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c       ndbptg = the number of distinct points on the temperature grid
c       ndbptl = the maximum number of points on the temperature grid
c                  per line
c       ntprt  = the number of temperature ranges on the standard
c                  temperature grid
c       qelect = flag denoting the use of "e-" instead of "O2(g)"
c                  in writing chemical reactions
c       tempc  = array of temperatures (on the temperature grid)
c       tempcs = array of scaled temperatures (on the temperature grid)
c       tmpcmx = the max norm of the tempeatures on the temperature grid
c       udbfmt = the format for reading a line of data on the
c                  temperature grid
c
c     Principal output:
c
c       atwt   = array of atomic weights
c       cdrs   = array of reaction coefficients
c       cess   = array of elemental composition coefficients
c       nerr   = cumulative error counter
c       ngt    = the number of gas species
c       nlt    = the number of pure liquid species
c       nmt    = the number of pure mineral species
c       nwarn  = cumulative warning counter
c       uelem  = array of names of chemical elements
c       ugassp = array of names of gas species
c       uliqsp = array of names of pure liquids
c       uminsp = array of names of pure minerals
c       uspec  = array of names of species
c       xlke   = array of log K values for the "Eh" reaction (on the
c                  temperature grid)
c       xlks   = array of log K values for reactions
c       zchar  = array of electrical charge numbers
c
c     Workspace:
c
c       aamatr = matrix used to calculate the polynomial coefficients
c       apr    = array of polynomial coefficients (for all ranges)
c       avgrid = array containing the data on the temperature grid
c       cof    = array of fitted polynomial coefficients (for a
c                  single temperature range)
c       gmmatr = a copy of the amatr matrix
c       ipivot = the pivot vector, used in solving matrix equations
c       nacdpr = array containging the number of actual data points
c                  by range on the "log K" temperature grid; excludes
c       udbval = string array for reading data on the temperature grid
c       xdbval = holding space array for data on the temperature grid
c       xvec   = array of scaled temperatures corresponding to the
c                  data in the yvec array
c       yvec   = array of data to be fitted (for a single temperature
c                  range)
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipchmx,ipcvmx,narxmx,natmax,nbtmx1,nbtmx2,nctmax,ndbmax,
     $ ngtmax,nltmax,nmtmax,ntprmx
c
      integer ndata1,ndat0s,ndat1f,noutpt,nslist,nttyo
c
      integer ipivot(narxmx),nacdpr(ntprmx),narxt(ntprmx),
     $ nentei(nctmax),nentri(nbtmx1)
c
      integer ipch,ipcv,itgenf,nat,nbt,nch,nco,nct,ndbptg,ndbptl,nerr,
     $ ngt,nlt,nmodwr,nmt,nsb,ntprt,nwarn
c
      logical qelect,q500fl
c
      character(len=24) udrsi(nbtmx1),uspec(nbtmx1)
      character(len=24) ugassp(ngtmax),uliqsp(nltmax),uminsp(nmtmax)
      character(len=16) udbval(ndbmax)
      character(len=8) uelem(nctmax),uessi(nctmax)
c
      character(len=16) udbfmt
c
      real(8) atwt(nctmax),cdrs(nbtmx2,nbtmx1),cdrsi(nbtmx1),
     $ cess(nctmax,nbtmx1),cessi(nctmax),dhfe(narxmx,ntprmx,ipchmx),
     $ dhfs(narxmx,ntprmx,ipchmx,nbtmx1),dvfe(narxmx,ntprmx,ipcvmx),
     $ dvfs(narxmx,ntprmx,ipcvmx,nbtmx1),xhfe(narxmx,ntprmx),
     $ xhfs(narxmx,ntprmx,nbtmx1),xlke(narxmx,ntprmx),
     $ xlks(narxmx,ntprmx,nbtmx1),xvfe(narxmx,ntprmx),
     $ xvfs(narxmx,ntprmx,nbtmx1),zchar(nbtmx1)
c
      real(8) apr(narxmx,ntprmx),avgrid(narxmx,ntprmx)
      real(8) tempc(narxmx,ntprmx),tempcs(narxmx,ntprmx),tmpcmx(ntprmx)
      real(8) aamatr(narxmx,narxmx),gmmatr(narxmx,narxmx)
      real(8) cof(narxmx),xvec(narxmx),yvec(narxmx)
      real(8) xdbval(ndbmax),mtotr(nctmax)
c
      real(8) eps100
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ii,ipc,j,j2,j3,j4,j5,k,n,nbt1,nblk,nc,ncts,ndrsts,
     $ nmodx,nn,nnx,ns,nsm1,nse,nspnx,nt,ntpr,nxm
c
      integer ilnobl
c
      logical qblkes,qblkrs,qend,qerr,qliq,qnofes,qnofrs,qzeres,
     $ qzerrs,q500nd
c
      character(len=24) uspn(2)
c
      character(len=80) ulbufa,ulbufb,uline,ux80
      character(len=72) uterm,utermc
      character(len=56) ustrgr
      character(len=24) uend24,ublk24,uliq24,ugas24,umin24,unone,
     $ usblkf,ux24
      character(len=16) ux16
      character(len=8) uendit,uliq,ugas,uss,ux8,ux8a,ux8b,ux8c
c
      real(8) mwtss,vol
c
c-----------------------------------------------------------------------
c
      data uendit /'endit.  '/
      data ugas24 /'gases                   '/
      data umin24 /'minerals                '/
      data uliq24 /'liquids                 '/
      data ublk24 /'                        '/
      data unone  /'none                    '/
      data uliq   /'liquids '/
      data ugas   /'gases   '/
      data uss    /'solid so'/
c
c-----------------------------------------------------------------------
c
      uterm(1:48) = '+-----------------------------------------------'
      uterm(49:72) = '------------------------'
      utermc = uterm
      utermc(1:1) = '*'
c
c     Write label for minerals.
c
      usblkf = umin24
      j3 = ilnobl(umin24)
      write (ndata1) umin24
      write (ndat1f,1010) umin24(1:j3)
 1010 format(a)
      write (ndat1f,1010) utermc(1:72)
      write (noutpt,1020) umin24(1:j3)
      write (nttyo,1020) umin24(1:j3)
      write (nslist,1020) umin24(1:j3)
 1020 format(//1x,a,/)
c
c     Initialize some variables.
c
      uend24(1:8) = uendit(1:8)
      uend24(9:24)=ublk24(9:24)
      uspn(1) = unone
      uspn(2) = ublk24
      nspnx = 1
      nnx = -1
      nn = 1
      nmodx = 0
      nbt1 = nbt + 1
      ns = nbt1
      zchar(ns) = 0.
      qliq = .false.
      nmt = 0
      nblk = 0
      q500nd = q500fl
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Note: the main loop returns here.
c
  100 mwtss = 0.
      ncts = 0
      ndrsts = 0
c
      do nc = 1,nct
        cess(nc,ns) = 0.
        cessi(nc) = 0.
      enddo
c
      do nse = 1,nbt1
        cdrs(nse,ns) = 0.
        cdrsi(nse) = 0.
      enddo
      cdrs(nbt + 2,ns) = 0.
c
      call initcv(uessi,nct,' ')
      call initcv(udrsi,nbt1,' ')
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c      Read the first line of the block.
c
  110 continue
      read (ndat0s,1000,end=990,err=995) uline
 1000 format(a)
      ux24 = uline(1:24)
      ux8 = ux24(1:8)
c
      if (ux8(1:8).eq.uliq(1:8) .or. ux8(1:8).eq.ugas(1:8)
     $ .or. ux8(1:8).eq.uss(1:8)) then
c
c       Finish with the current set of species blocks.
c
        if (uspn(1)(1:24) .eq. unone(1:24)) then
          nnx = 0
          nn = 0
          write (nttyo,1140) nnx,unone(1:4)
          write (nslist,1140) nnx,unone(1:4)
 1140     format(1x,i5,2x,a)
          write (noutpt,1150) nn,unone(1:4)
 1150     format(1x,i5,1x,a)
        else
          nxm = nspnx - 1
          if (nxm .ge. 1) then
            nnx = nnx + 2
            if (nxm .eq. 1) then
              j3 = ilnobl(uspn(1))
              write (nttyo,1140) nnx,uspn(1)(1:j3)
              write (nslist,1140) nnx,uspn(1)(1:j3)
            else
              j3 = ilnobl(uspn(2))
              write (nttyo,1160) nnx,uspn(1),uspn(2)(1:j3)
              write (nslist,1160) nnx,uspn(1),uspn(2)(1:j3)
 1160         format(1x,i5,2x,a24,2x,a)
            endif
          elseif (nmodx .ne. 1) then
            j3 = ilnobl(uspn(2))
            write (nttyo,1160) nnx,uspn(1),uspn(2)(1:j3)
          endif
        endif
c
        if (qliq) then
          qliq = .false.
          write (nttyo,1170)
          write (nslist,1170)
          write (noutpt,1170)
 1170     format(/' * Note - (EQPT/pcrsg) The pure liquids block has',
     $    /7x,'not been written on the DATA1 and DATA1F files,',
     $    /7x,'because the EQ3NR and EQ6 codes presently do not',
     $    /7x,'treat non-aqeuous liquids.')
        else
          write (ndata1) uend24,ublk24,ublk24
          j3 = ilnobl(uend24)
          write (ndat1f,1010) uend24(1:j3)
          write (ndat1f,1010) utermc(1:72)
        endif
c
        if (ux8(1:8) .eq. uss(1:8)) then
c
c         Skip the terminator line.
c
          read (ndat0s,1000,end=990,err=995) uline
          go to 999
        else
          read (ndat0s,1000,end=990,err=995) uline
          if (ux8(1:8) .eq. ugas(1:8)) then
c
c           Have found the gas species superblock.
c
            ngt = 0
            nblk = 0
            usblkf = ugas24
            j3 = ilnobl(ugas24)
            write (ndata1) ugas24
            write (ndat1f,1010) ugas24(1:j3)
            write (ndat1f,1010) utermc(1:72)
            write (noutpt,1020) ugas24(1:j3)
            write (nttyo,1020) ugas24(1:j3)
            write (nslist,1020) ugas24(1:j3)
          elseif (ux8 .eq. uliq) then
c
c           Have found the pure liquid superblock.
c
c           Note- EQ3NR and EQ6 presently do not treat non-aqueous
c           liquids.  Do not write liquid data on DATA1 and DATA1F.
c           Set 'qliq' flag to avoid writing such data on these files.
c
            nlt = 0
            nblk = 0
            usblkf = uliq24
            j3 = ilnobl(uliq24)
c           write (ndata1) uliq24
c           write (ndat1f,1010) uliq24
c           write (ndat1f,1010) utermc(1:72)
            qliq = .true.
c
            write (noutpt,1020) uliq24(1:j3)
            write (nttyo,1020) uliq24(1:j3)
            write (nslist,1020) uliq24(1:j3)
          endif
          uspn(1) = unone
          uspn(2) = ublk24
          nspnx = 1
          nnx = -1
          nn = 1
          nmodx = 0
          go to 110
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Have a species block.
c
      nblk = nblk + 1
c
      j2 = ilnobl(ux24)
      if (j2 .le. 0) then
        write (ux8a,'(i5)') nblk
        call lejust(ux8a)
        j3 = ilnobl(ux8a)
        j4 = ilnobl(usblkf)
        write (noutpt,1240) ux8a(1:j3),usblkf(1:j4)
        write (nttyo,1240) ux8a(1:j3),usblkf(1:j4)
 1240   format(/' * Error - (EQPT/pcraq) Have encountered a blank',
     $  ' species name',/7x,'for species block ',a,' of the ',a,
     $  ' superblock.')
        if (nblk .gt. 1) then
          if (usblkf(1:24) .eq. umin24(1:24)) then
            ux24 = uminsp(nmt - 1)
          elseif (usblkf(1:24) .eq. uliq24(1:24)) then
            ux24 = uliqsp(nlt - 1)
          elseif (usblkf(1:24) .eq. ugas24(1:24)) then
            ux24 = ugassp(ngt - 1)
          endif
          j5 = ilnobl(ux24)
          if (j5 .gt. 0) then
            write (noutpt,1250) ux24(1:j5)
            write (nttyo,1250) ux24(1:j5)
 1250       format(7x,'This block follows the one for ',a,'.')
          endif
        endif
        ux24 = '<blank>'
        nerr = nerr + 1
      endif
c
      if (usblkf(1:24) .eq. umin24(1:24)) then
        nmt = nmt + 1
        uminsp(nmt) = ux24
      elseif (usblkf(1:24) .eq. uliq24(1:24)) then
        nlt = nlt + 1
        uliqsp(nlt) = ux24
      elseif (usblkf(1:24) .eq. ugas24(1:24)) then
        ngt = ngt + 1
        ugassp(ngt) = ux24
      endif
c
      uspec(ns) = ux24
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Save the species name for screen and SLIST output.
c
      uspn(nspnx) = uspec(ns)
c
c     Write the species name on the output file.
c
      j2 = ilnobl(uspec(ns))
      write (noutpt,1150) nn,uspec(ns)(1:j2)
c
c     Write species names two per line on the SLIST file.
c
      nspnx = nspnx + 1
      if (nspnx .gt. 2) then
        nspnx = 1
        nnx = nnx + 2
        nmodx = mod(nnx,nmodwr)
        if (nmodwr .eq. 1) nmodx = 1
        j3 = ilnobl(uspn(2))
        if (nmodx .eq. 1) write (nttyo,1160) nnx,uspn(1),uspn(2)(1:j3)
        write (nslist,1160) nnx,uspn(1),uspn(2)(1:j3)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Skip the obsolete 'sp.type =' and 'revised =' lines.
c     Read the molar volume. The electrical charge is zero
c     for all species types read by this subroutine.
c
  130 read (ndat0s,1000,end=990,err=995) uline
      ii = index(uline,'V0PrTr')
      if (ii .eq. 0) go to 130
c
      ux80 = uline(ii + 6:80)
      ii = index(ux80,'=')
      ux16 = ux80(ii + 1:80)
      call lejust(ux16)
      ii = index(ux16,' ')
      if (ii .gt. 0) ux16(ii:16) = ' '
      read (ux16,'(f9.3)',err=995) vol
c1280 format(16x,f9.3)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the number of chemical elements composing the species.
c
      read (ndat0s,1000,end=990,err=995) uline
      ux80 = uline
      call lejust(ux80)
      ii = index(ux80,'element(s)')
      if (ii .gt. 1) then
        ux16 = ux80(1:ii - 1)
        read (ux16,'(i5)',err=995) ncts
c1330   format(4x,i2)
      else
        ii = index(ux80,' ')
        if (ii .gt. 1) then
          ux16 = ux80(1:ii - 1)
          read (ux16,'(i5)',err=995) ncts
        else
          ncts = 0
        endif
      endif
c
      if (ncts .gt. nct) then
        j2 = ilnobl(uspec(ns))
        write (ux8a,'(i5)') ncts
        call lejust(ux8a)
        j3 = ilnobl(ux8a)
        write (ux8c,'(i5)') nct
        call lejust(ux8c)
        j5 = ilnobl(ux8c)
        write (noutpt,1350) uspec(ns)(1:j2),ux8a(1:j3),ux8c(1:j5)
        write (nttyo,1350) uspec(ns)(1:j2),ux8a(1:j3),ux8c(1:j5)
 1350   format(/' * Error - (EQPT/pcrsg) Species "',a,'" is',
     $  ' composed of ',a,/7x,'chemical elements, but there',
     $  ' are only ',a,' elements on the data file.')
        nerr = nerr + 1
      endif
c
      if (ncts .le. 0) then
        if (uspec(ns)(1:3).ne.'e- ' .and. uspec(ns)(1:3).ne.'E- ') then
          j2 = ilnobl(uspec(ns))
          write (noutpt,1360) uspec(ns)(1:j2)
          write (nttyo,1360) uspec(ns)(1:j2)
 1360     format(/' * Error - (EQPT/pcrsg) Species "',a,'" is not',
     $    ' composed of',/7x,'any chemical elements.')
          nerr = nerr + 1
        endif
      endif
c
c     Read the names of the elements and the corresponding
c     compositional coefficients.
c
      n = 0
      do i = 1,ncts/3
        read (ndat0s,1000,end=990,err=995) uline
        ulbufa = uline
        do k = 1,3
          call lejust(ulbufa)
          ii = index(ulbufa,' ')
          if (ii .gt. 1) then
            ux16 = ulbufa(1:ii - 1)
            read (ux16,'(f8.4)',err=995) cessi(n + k)
          else
            cessi(n + k) = 0.
          endif
          ulbufb = ulbufa(ii + 1:80)
          call lejust(ulbufb)
          uessi(n + k) = ulbufb(1:8)
          if (k .lt. 3) ulbufa = ulbufb(9:80)
        enddo
c       read (uline,1370,err=995) (cessi(n + k),uessi(n + k), k = 1,3)
c1370   format((4x,3(f8.4,1x,a8,5x)))
        n = n + 3
      enddo
c
      j = mod(ncts,3)
      if (j .gt. 0) then
        read (ndat0s,1000,end=990,err=995) uline
        ulbufa = uline
        do k = 1,j
          call lejust(ulbufa)
          ii = index(ulbufa,' ')
          if (ii .gt. 1) then
            ux16 = ulbufa(1:ii - 1)
            read (ux16,'(f8.4)',err=995) cessi(n + k)
          else
            cessi(n + k) = 0.
          endif
          ulbufb = ulbufa(ii + 1:80)
          call lejust(ulbufb)
          uessi(n + k) = ulbufb(1:8)
          if (k .lt. j) ulbufa = ulbufb(9:80)
        enddo
c       read (uline,1370,err=995) (cessi(n + k),uessi(n + k), k = 1,3)
c1370   format((4x,3(f8.4,1x,a8,5x)))
        n = n + j
      endif
c
c     Check for blank element names, duplicate element names, and
c     zero-valued stoichiometric coefficients.
c
      call elesck(cessi,nbtmx1,nctmax,ncts,nentei,nerr,noutpt,
     $ ns,nttyo,qblkes,qzeres,uessi,usblkf,uspec)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (ns .gt. nsb) then
c
c       Read the number of species in the associated reaction.
c
        read (ndat0s,1000,end=990,err=995) uline
        ux80 = uline
        call lejust(ux80)
        ii = index(ux80,'species')
        if (ii .gt. 1) then
          ux16 = ux80(1:ii - 1)
          read (ux16,'(i5)',err=995) ndrsts
c1500   format(4x,i2)
        else
          ii = index(ux80,' ')
          if (ii .gt. 1) then
            ux16 = ux80(1:ii - 1)
            read (ux16,'(i5)',err=995) ndrsts
          else
            ndrsts = 0
          endif
        endif
c
        if (ndrsts .gt. nbt1) then
          j2 = ilnobl(uspec(ns))
          write (ux8a,'(i5)') ndrsts
          call lejust(ux8a)
          j3 = ilnobl(ux8a)
          write (ux8b,'(i5)') nbt
          call lejust(ux8b)
          j4 = ilnobl(ux8b)
          write (ux8c,'(i5)') nbt1
          call lejust(ux8c)
          j5 = ilnobl(ux8c)
          write (noutpt,1520) uspec(ns)(1:j2),ux8a(1:j3),ux8b(1:j4),
     $    ux8c(1:j5)
          write (nttyo,1520) uspec(ns)(1:j2),ux8a(1:j3),ux8b(1:j4),
     $    ux8c(1:j5)
 1520     format(/' * Error - (EQPT/pcrsg) The reaction for the',
     $    /7x,'destruction of species "',a,'" includes ',a,
     $    /7x,'species, but there are only ',a,' basis species on the',
     $    /7x,'data file, so only ',a,' species may appear in the ',
     $    'reaction.')
          nerr = nerr + 1
        endif
c
        if (ndrsts .lt. 2) then
          j2 = ilnobl(uspec(ns))
          j4 = ilnobl(usblkf)
          write (noutpt,1530) uspec(ns)(1:j2),usblkf(1:j4)
          write (nttyo,1530) uspec(ns)(1:j2),usblkf(1:j4)
 1530     format(/' * Error - (EQPT/pcrsg) The species ',a,
     $    ' appearing',/7x,'on the data file in the ',a,' superblock',
     $    ' has fewer than',/7x,'two species in its associated',
     $    ' reaction. This is not a',/7x,'valid reaction.')
          nerr = nerr + 1
        endif
c
c       Read the names of the species in the reaction and the
c       corresponding reaction coefficients.
c
        n = 0
        do i = 1,ndrsts/2
          read (ndat0s,1000,end=990,err=995) uline
          ulbufa = uline
          do k = 1,2
            call lejust(ulbufa)
            ii = index(ulbufa,' ')
            if (ii .gt. 1) then
              ux16 = ulbufa(1:ii - 1)
              read (ux16,'(f10.4)',err=995) cdrsi(n + k)
            else
              cdrsi(n + k) = 0.
            endif
            ulbufb = ulbufa(ii + 1:80)
            call lejust(ulbufb)
            udrsi(n + k) = ulbufb(1:24)
            if (k .lt. 2) ulbufa = ulbufb(25:80)
          enddo
c         read (uline,1540,err=995) (cdrsi(n + k),udrsi(n + k), k = 1,2)
c1540     format((2(1x,f10.4,2x,a24)))
          n = n + 2
        enddo
c
        j = mod(ndrsts,2)
        if (j .gt. 0) then
          read (ndat0s,1000,end=990,err=995) uline
          ulbufa = uline
          do k = 1,j
            call lejust(ulbufa)
            ii = index(ulbufa,' ')
            if (ii .gt. 1) then
              ux16 = ulbufa(1:ii - 1)
              read (ux16,'(f10.4)',err=995) cdrsi(n + k)
            else
              cdrsi(n + k) = 0.
            endif
            ulbufb = ulbufa(ii + 1:80)
            call lejust(ulbufb)
            udrsi(n + k) = ulbufb(1:24)
            if (k .lt. j) ulbufa = ulbufb(25:80)
          enddo
c         read (uline,1540,err=995) (cdrsi(n + k),udrsi(n + k), k = 1,j)
          n = n + j
        endif
c
c       Check for blank species names, duplicate species names, and
c       zero-valued reaction coefficients. Check that the reaction
c       coefficient of the species with which the reaction is
c       associated has a negative value.
c
        call rxnsck(nbtmx1,cdrsi,nct,ndrsts,nentri,nerr,noutpt,
     $  ns,nsb,nttyo,qblkrs,qzerrs,udrsi,usblkf,uspec)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c       Read the log K grid for the current species.
c       Return the data in the xdbval holding array.
c
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the xlks array.
c
c       Calling sequence substitutions:
c         ns for ipc
c         nbtmx1 for ipcmax
c         xlks for zdbval
c
        call ldbar3(ns,nbtmx1,nacdpr,narxmx,narxt,ndbmax,
     $  ntprmx,ntprt,xdbval,xlks)
c
        if (itgenf .ge. 0) then
c
c         Test the grid ranges for sparseness of actual data.
c
          ustrgr = 'the log K for ' // uspec(ns)
          call tegrid(itgenf,nacdpr,narxt,nerr,noutpt,ntprmx,
     $    ntprt,nttyo,nwarn,ustrgr)
        endif
c
        if (ipch .ge. 0) then
c
c         Read the enthalpy function grid for the current species.
c         Return the data in the xdbval holding array.
c
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the xhfs array.
c
c         Calling sequence substitutions:
c           ns for ipc
c           nbtmx1 for ipcmax
c           xhfs for zdbval
c
          call ldbar3(ns,nbtmx1,nacdpr,narxmx,narxt,ndbmax,
     $    ntprmx,ntprt,xdbval,xhfs)
c
          if (itgenf .ge. 0) then
c
c           Test the grid ranges for sparseness of actual data.
c
            ustrgr = 'the enthalpy function for ' // uspec(ns)
            call tegrid(itgenf,nacdpr,narxt,nerr,noutpt,ntprmx,
     $      ntprt,nttyo,nwarn,ustrgr)
          endif
c
          do ipc = 1,ipch
c
c           Read the enthalpy function derivative grid for the current
c           species. Return the data in the xdbval holding array.
c
            call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $      udbval,xdbval)
            if (qend) go to 990
            if (qerr) go to 995
c
c           Load the data into the dhfs array.
c
c           Calling sequence substitutions:
c             ipchmx for ipcmax
c             dhfs for zdbval
c
            call ldbar4(ipc,ipchmx,nacdpr,narxmx,narxt,nbtmx1,
     $      ndbmax,ns,ntprmx,ntprt,xdbval,dhfs)
          enddo
        endif
c
        if (ipcv .ge. 0) then
c
c         Read the volume function grid for the current species.
c         Return the data in the xdbval holding array.
c
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the xvfs array.
c
c         Calling sequence substitutions:
c           ns for ipc
c           nbtmx1 for ipcmax
c           xvfs for zdbval
c
          call ldbar3(ns,nbtmx1,nacdpr,narxmx,narxt,ndbmax,
     $    ntprmx,ntprt,xdbval,xvfs)
c
          if (itgenf .ge. 0) then
c
c           Test the grid ranges for sparseness of actual data.
c
            ustrgr = 'the volume function for ' // uspec(ns)
            call tegrid(itgenf,nacdpr,narxt,nerr,noutpt,ntprmx,
     $      ntprt,nttyo,nwarn,ustrgr)
          endif
c
          do ipc = 1,ipcv
c
c           Read the volume function derivative grid for the current
c           species. Return the data in the xdbval holding array.
c
            call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $      udbval,xdbval)
            if (qend) go to 990
            if (qerr) go to 995
c
c           Load the data into the dvfs array.
c
c           Calling sequence substitutions:
c             ipcvmx for ipcmax
c             dvfs for zdbval
c
            call ldbar4(ipc,ipcvmx,nacdpr,narxmx,narxt,nbtmx1,
     $      ndbmax,ns,ntprmx,ntprt,xdbval,dvfs)
          enddo
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     If the reaction is written in terms of e-, rewrite it in terms
c     of O2(g).
c
      if (qelect) then
        call etoo2(cdrsi,dhfe,dhfs,dvfe,dvfs,ipch,ipchmx,ipcv,
     $  ipcvmx,narxmx,narxt,nbtmx1,ndrsts,ns,ntprmx,ntprt,udrsi,
     $  xhfe,xhfs,xlke,xlks,xvfe,xvfs)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Process the species data.
c
      mwtss = 0.
      qnofes = .false.
      do n = 1,ncts
c
c       Search for element name in the uelem array.
c
        ux8 = uessi(n)(1:8)
        if (ux8(1:7) .ne. '<blank>') then
c
          do nc = 1,nct
            if (ux8(1:8) .eq. uelem(nc)(1:8)) then
              mwtss = mwtss + atwt(nc)*cessi(n)
              cess(nc,ns) = cess(nc,ns) + cessi(n)
              go to 220
            endif
          enddo
c
c         Error, not found.
c
          j3 = ilnobl(ux8)
          write (noutpt,1760) ux8(1:j3),uspec(ns)(1:j2)
          write (nttyo,1760) ux8(1:j3),uspec(ns)(1:j2)
 1760     format(/' * Error - (EQPT/pcrsg) Unrecognized chemical',
     $    ' element "',a,'" is listed',/7x,'in the composition of',
     $    ' the species ',a,'.')
          nerr = nerr + 1
          qnofes = .true.
c
  220     continue
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (.not.qliq) then
        write (ndata1) uspec(ns),ncts,ndrsts
        write (ndat1f,1800) uspec(ns),ncts,ndrsts
 1800   format(a24,2x,2i5)
c
        write (ndata1) mwtss,zchar(ns),vol
        write (ndat1f,1810) mwtss,zchar(ns),vol
 1810   format(5x,f10.3,f5.0,f9.3)
c
        if (ncts .gt. 0) then
          write (ndata1) (cessi(n),uessi(n), n = 1,ncts)
          n = 1
  230     continue
          if (n .eq. ncts) then
            j4 = ilnobl(uessi(n))
            write (ndat1f,1820) cessi(n),uessi(n)(1:j4)
 1820       format(1x,f10.4,2x,a)
            n = n + 1
          else
            j4 = ilnobl(uessi(n + 1))
            write (ndat1f,1830) cessi(n),uessi(n),
     $      cessi(n + 1),uessi(n + 1)(1:j4)
 1830       format(1x,f10.4,2x,a8,1x,f10.4,2x,a)
            n = n + 2
          endif
          if (n .le. ncts) go to 230
        endif
      endif
c
      if (.not.qliq) then
        write (ndata1) (cdrsi(n),udrsi(n), n = 1,ndrsts)
        n = 1
  240   continue
        if (n .eq. ndrsts) then
          j4 = ilnobl(udrsi(n))
          write (ndat1f,1860) cdrsi(n),udrsi(n)(1:j4)
 1860     format(1x,f10.4,2x,a)
          n = n + 1
        else
          j4 = ilnobl(udrsi(n + 1))
          write (ndat1f,1870) cdrsi(n),udrsi(n),
     $    cdrsi(n + 1),udrsi(n + 1)(1:j4)
 1870     format(1x,f10.4,2x,a24,1x,f10.4,2x,a)
          n = n + 2
        endif
        if (n .le. ndrsts) go to 240
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      qnofrs = .false.
      cdrs(nbt1,ns) = cdrsi(1)
      do n = 2,ndrsts
c
c       Search for species name in the uspec array.
c
        ux24 = udrsi(n)
        if (ux24(1:7) .ne. '<blank>') then
c
          do nse = 1,nbt
            if (ux24 .eq. uspec(nse)) then
              cdrs(nse,ns) = cdrs(nse,ns) + cdrsi(n)
              go to 250
            endif
          enddo
c
c         Error, not found.
c
          j3 = ilnobl(ux24)
          write (noutpt,1880) uspec(ns)(1:j2),ux24(1:j3)
          write (nttyo,1880) uspec(ns)(1:j2),ux24(1:j3)
 1880     format(/' * Error - (EQPT/pcrsg) The reaction which destroys',
     $     /7x,'non-basis species ',a,' is written in terms of an',
     $     /7x,'unrecognized basis species "',a,'".')
          nerr = nerr + 1
          qnofrs = .true.
  250     continue
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Test the reaction for mass and charge balance.
c     Skip if there are already obvious problems.
c
      if (ndrsts .ge. 2) then
        if (.not.qblkes .and. .not.qnofes) then
          if (.not.qblkrs .and. .not.qnofrs) then
            call rxnchk(cdrs,cess,mtotr,nbt,nbtmx1,nbtmx2,nco,
     $      nct,nctmax,nerr,noutpt,ns,nsb,nttyo,uelem,uspec,zchar)
          endif
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (qliq) go to 300
c
c     Fit interpolating polynomials to the log K grid.
c
      do ntpr = 1,ntprt
        do n = 1,narxt(ntpr)
          avgrid(n,ntpr) = xlks(n,ntpr,ns)
        enddo
      enddo
c
      call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $ narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $ xvec,yvec)
c
      ux24 = 'Log K'
      j2 = ilnobl(ux24)
      write (ndata1) ux24
      write (ndat1f,1010) ux24(1:j2)
c
      do ntpr = 1,ntprt
        nt = narxt(ntpr)
        write (ndata1) (apr(i,ntpr), i = 1,nt)
        write (ndat1f,1890) (apr(i,ntpr), i = 1,nt)
 1890   format( 5(1pe16.9) )
      enddo
c
      if (ipch .ge. 0) then
c
c       Fit interpolating polynomials to the enthalpy function grid.
c
        do ntpr = 1,ntprt
          do n = 1,narxt(ntpr)
            avgrid(n,ntpr) = xhfs(n,ntpr,ns)
          enddo
        enddo
c
        call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'Enthalpy'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1890) (apr(i,ntpr), i = 1,nt)
        enddo
c
        do ipc = 1,ipch
c
          do ntpr = 1,ntprt
            do n = 1,narxt(ntpr)
              avgrid(n,ntpr) = dhfs(n,ntpr,ipc,ns)
            enddo
          enddo
c
          call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'dhfs( )'
          write (ux24(6:6),'(i1)') ipc
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1890) (apr(i,ntpr), i = 1,nt)
          enddo
        enddo
      endif
c
      if (ipcv .ge. 0) then
c
c       Fit interpolating polynomials to the volume function grid.
c
        do ntpr = 1,ntprt
          do n = 1,narxt(ntpr)
            avgrid(n,ntpr) = xvfs(n,ntpr,ns)
          enddo
        enddo
c
        call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'Volume'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1890) (apr(i,ntpr), i = 1,nt)
        enddo
c
        do ipc = 1,ipcv
c
          do ntpr = 1,ntprt
            do n = 1,narxt(ntpr)
              avgrid(n,ntpr) = dvfs(n,ntpr,ipc,ns)
            enddo
          enddo
c
          call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'dvfs( )'
          write (ux24(6:6),'(i1)') ipc
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1890) (apr(i,ntpr), i = 1,nt)
          enddo
        enddo
      endif
c
      write (ndat1f,1010) utermc(1:72)
  300 continue
c
c     Look for another species block or terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
      nn = nn + 1
      go to 100
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/pcrsg) Unexpectedly encountered',
     $ /7x,'end-of-file while reading the DATA0 file.')
c
      write (noutpt,2010) nn
      write (nttyo,2010) nn
 2010 format(7x,'The value of the species block counter is ',i3,'.')
      if (ns .gt. 0) then
        j2 = ilnobl(uspec(ns))
        if (j2 .gt. 0) then
          write (noutpt,2020) uspec(ns)(1:j2)
          write (nttyo,2020) uspec(ns)(1:j2)
 2020     format(7x,'The last species name read was "',a,'".')
        else
          nsm1 = ns - 1
          if ((nsm1) .gt. 0) then
            j2 = ilnobl(uspec(nsm1))
            if (j2 .gt. 0) then
              write (noutpt,2020) uspec(nsm1)(1:j2)
              write (nttyo,2020) uspec(nsm1)(1:j2)
            endif
          endif
        endif
      endif
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,70)
        write (noutpt,2030) uline(1:j2)
        write (nttyo,2030) uline(1:j2)
 2030   format(7x,'The last line read was the following:',
     $  /7x,'"',a,'"')
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  995 write (noutpt,2040)
      write (nttyo,2040)
 2040 format(/' * Error - (EQPT/pcrsg) Encountered a read format',
     $ /7x,'error while reading the DATA0 file.')
c
      write (noutpt,2010) nn
      write (nttyo,2010) nn
      if (ns .gt. 0) then
        j2 = ilnobl(uspec(ns))
        if (j2 .gt. 0) then
          write (noutpt,2020) uspec(ns)(1:j2)
          write (nttyo,2020) uspec(ns)(1:j2)
        else
          nsm1 = ns - 1
          if ((nsm1) .gt. 0) then
            j2 = ilnobl(uspec(nsm1))
            if (j2 .gt. 0) then
              write (noutpt,2020) uspec(nsm1)(1:j2)
              write (nttyo,2020) uspec(nsm1)(1:j2)
            endif
          endif
        endif
      endif
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,67)
        write (noutpt,2030) uline(1:j2)
        write (nttyo,2030) uline(1:j2)
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine pcrss(apx,bpx,iapxmx,ibpxmx,iktmax,issot,nbtmx1,
     $ ndata1,ndat0s,ndat1f,nerr,nmodwr,nmt,nmtmax,noutpt,nslist,
     $ nttyo,nxt,nxtmax,uminsp,ussosp,ussoph)
c
c     This subroutine reads data on solid solutions from the stripped
c     DATA0 file, processes this data, and writes the results
c     on the DATA1 and DATA1F files. The counter "nerr" is incremented
c     by one for each error encountered.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndata1 = unit number of the DATA1 file
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c       nerr   = cumulative error counter
c
c     Principal output:
c
c       apx    = array of interaction coefficients for computing
c                  activity coefficients in solid solutions
c       bpx    = array of site-mixing parameters for computing
c                  activity coefficients in solid solutions
c       nerr   = cumulative error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer iapxmx,ibpxmx,iktmax,nbtmx1,nmtmax,nxtmax
c
      integer ndata1,ndat0s,ndat1f,noutpt,nslist,nttyo,nxt
c
      integer nerr,nmodwr,nmt
c
      integer issot(nxtmax)
c
      character*24 uminsp(nmtmax),ussosp(iktmax,nxtmax),ussoph(nxtmax)
c
      real*8 apx(iapxmx),bpx(ibpxmx)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,iapxt,ibpxt,ii,ikt,j,jsol,j2,j3,j4,j5,k,n,nmodx
c
      integer ilnobl
c
      character*80 uline
      character*72 uterm,utermc
      character*24 usolid,ux24,ux24a
      character*24 uend24,ublk24,unone
      character*8 uendit,uref,ux8,ux8a
c
c-----------------------------------------------------------------------
c
      data ublk24 /'                        '/
      data usolid /'solid solutions         '/
      data unone  /'none                    '/
      data uendit /'endit.  '/
      data uref  /'referenc'/
c
c-----------------------------------------------------------------------
c
      uterm(1:48) = '+-----------------------------------------------'
      uterm(49:72) = '------------------------'
      utermc = uterm
      utermc(1:1) = '*'
c
      uend24(1:8) = uendit(1:8)
      uend24(9:24) = ublk24(9:24)
      nxt = 0
      ikt = 0
      nmodx = 0
c
      j2 =ilnobl(usolid)
      write (ndata1) usolid
      write (ndat1f,1000) usolid(1:j2)
 1000 format(a)
      write (ndat1f,1000) utermc(1:72)
      write (noutpt,1010) usolid(1:j2)
      write (nttyo,1010) usolid(1:j2)
      write (nslist,1010) usolid(1:j2)
 1010 format(//1x,a,/)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Note: the main loop returns here.
c
  100 read (ndat0s,1020,end=990,err=995) uline
 1020 format(a)
      ux24 = uline(1:24)
      ux8 = uline(1:8)
      call locase(ux8)
      if (ux8(1:8) .eq. uref(1:8)) then
c
c       Found the 'references' superblock header. Finish and exit here.
c
        if (nxt .le. 0) then
c
c         No solid solutions were found on the data file.
c
          write (nttyo,1030) nxt,unone(1:4)
          write (nslist,1030) nxt,unone(1:4)
          write (noutpt,1030) nxt,unone(1:4)
 1030     format(1x,i5,2x,a)
        endif
c
        if (nxt.gt.0 .and. nmodx.ne.1) then
c
c         The last solid solution was not previously echoed
c         to the screen. Do this now. The echo consists of the
c         name of the solid solution and the names of its
c         end-member components.
c
          j2 = ilnobl(ussoph(nxt))
          write (nttyo,1030) nxt,ussoph(nxt)(1:j2)
c
          i = 1
  120     continue
          if (i .eq. ikt) then
            j2 = ilnobl(ussosp(i,nxt))
            write (nttyo,1040) ussosp(i,nxt)
 1040       format(12x,a)
            i = i + 1
          else
            j2 = ilnobl(ussosp(i + 1,nxt))
            write (nttyo,1050) ussosp(i,nxt),ussosp(i + 1,nxt)(1:j2)
 1050       format(12x,a24,2x,a)
            i = i + 2
          endif
          if (i .le. ikt) go to 120
        endif
c
        write (ndata1) uend24,ublk24,ublk24
        j2 = ilnobl(uend24)
        write (ndat1f,1000) uend24(1:j2)
        write (ndat1f,1000) utermc(1:72)
c
c       Skip the terminator line.
c
        read (ndat0s,1020,end=990,err=995) uline
        go to 999
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      nxt = nxt + 1
c
c     Check for a blank solid solution name.
c
      j2 = ilnobl(ux24)
      if (j2 .le. 0) then
        write (ux8a,'(i5)') nxt
        call lejust(ux8a)
        j3 = ilnobl(ux8a)
        j4 = ilnobl(usolid)
        write (noutpt,1080) ux8a(1:j3),usolid(1:j4)
        write (nttyo,1080) ux8a(1:j3),usolid(1:j4)
 1080   format(/' * Error - (EQPT/pcrss) Have encountered a blank',
     $  ' phase name',/7x,'for phase block ',a,' of the ',a,
     $  ' superblock.')
        if (nxt .gt. 1) then
          ux24a = ussoph(nxt - 1)
          if (ux24a(1:7) .ne. '<blank>') then
            j5 = ilnobl(ux24a)
            write (noutpt,1090) ux24a(1:j5)
            write (nttyo,1090) ux24a(1:j5)
 1090       format(7x,'This block follows the one for ',a,'.')
          endif
        endif
        ux24 = '<blank>'
        nerr = nerr + 1
      endif
c
      ussoph(nxt) = uline(1:24)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      nmodx = mod(nxt,nmodwr)
      if (nmodwr .eq. 1) nmodx = 1
      j2 = ilnobl(ussoph(nxt))
      if (nmodx .eq. 1) write (nttyo,1030) nxt,ussoph(nxt)(1:j2)
      write (nslist,1030) nxt,ussoph(nxt)(1:j2)
c
c     Skip the 'entered by' and 'keys' lines.
c
      read (ndat0s,1020,end=990,err=995) uline
      read (ndat0s,1020,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read number of end members.
c
      read (ndat0s,1020,end=990,err=995) uline
      read (uline,1150,err=995) ikt
 1150 format(i3)
c
      if (ikt .le. 0) then
        j2 = ilnobl(ussoph(nxt))
        write (noutpt,1160) ussoph(nxt)(1:j2)
        write (nttyo,1160) ussoph(nxt)(1:j2)
 1160   format(/' * Error - (EQPT/pcrss) Solid solution "',a,'" is',
     $  ' not',/7x,'comprised of any end-members.')
        nerr = nerr + 1
      endif
c
      if (ikt .eq. 1) then
        j2 = ilnobl(ussoph(nxt))
        write (noutpt,1170) ussoph(nxt)(1:j2)
        write (nttyo,1170) ussoph(nxt)(1:j2)
 1170   format(/' * Error - (EQPT/pcrss) Solid solution "',a,'" is',
     $  ' comprised',/7x,'of only one end-member. Two or more',
     $  ' end-members are required.')
        nerr = nerr + 1
      endif
c
      if (ikt. gt. iktmax) then
        j2 = ilnobl(ussoph(nxt))
        write (noutpt,1180) ussoph(nxt)(1:j2),ikt,iktmax
        write (nttyo,1180) ussoph(nxt)(1:j2),ikt,iktmax
 1180   format(/' * Error - (EQPT/pcrss) Solid solution ',a,
     $  /7x,'is composed of ',i3,' end-members, which exceeds the',
     $  /7x,'maximum dimension (iktpar) of ',i3,'.')
        nerr = nerr + 1
      endif
c
      issot(nxt) = ikt
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (ikt .gt. 0) then
        n = 0
        do ii = 1,ikt/2
          read (ndat0s,1020,end=990,err=995) uline
          read (uline,1190,err=995) (ussosp(n + k,nxt), k = 1,2)
 1190     format((13x,a24,13x,a24))
          n = n + 2
        enddo
        j = mod(ikt,2)
        if (j .gt. 0) then
        read (ndat0s,1020,end=990,err=995) uline
        read (uline,1190,err=995) (ussosp(n + k,nxt), k = 1,j)
        n = n + j
        endif
c
        i = 1
  130   continue
        if (i .eq. ikt) then
          j2 = ilnobl(ussosp(i,nxt))
          if (nmodx .eq. 1) write (nttyo,1040) ussosp(i,nxt)(1:j2)
          write (nslist,1040) ussosp(i,nxt)(1:j2)
          i = i + 1
        else
          j2 = ilnobl(ussosp(i + 1,nxt))
          if (nmodx .eq. 1)
     $    write (nttyo,1050) ussosp(i,nxt),ussosp(i + 1,nxt)(1:j2)
          write (nslist,1050) ussosp(i,nxt),ussosp(i + 1,nxt)(1:j2)
          i = i + 2
        endif
        if (i .le. ikt) go to 130
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check the end-member names for blanks.
c
      do i = 1,ikt
        ux24 = ussosp(i,nxt)
        j3 = ilnobl(ux24)
        if (j3 .le. 0) then
          j2 = ilnobl(ussoph(nxt))
          write (ux8,'(i5)') i
          call lejust(ux8)
          j4 = ilnobl(ux8)
          write (noutpt,1210) ussoph(nxt)(1:j2),ux8(1:j4)
          write (nttyo,1210) ussoph(nxt)(1:j2),ux8(1:j4)
 1210     format(/' * Error - (EQPT/pcrss) Solid solution "',a,'"',
     $    /7x,'has a blank name for end-member number ',a,'.')
          if (i .gt. 1) then
            ux24a = ussosp(i - 1,nxt)
            if (ux24a(1:7) .ne. '<blank>') then
              j5 = ilnobl(ux24a)
              write (noutpt,1220) ux24a(1:j5)
              write (nttyo,1220) ux24a(1:j5)
 1220         format(7x,'This follows the end-member ',a,'.')
            endif
          endif
          ussosp(i,nxt) = '<blank>'
          nerr = nerr + 1
        endif
      enddo
c
c     Note: the end-members names are checked for duplicates by
c     nxspck.f, and validated against pure mineral names by vxspck.f.
c     These subroutines are called by eqpt.f.
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the activity coefficient code.
c
      read (ndat0s,1020,end=990,err=995) uline
      read (uline,1250,err=995) jsol
 1250 format(10x,i1)
c
      call initaz(apx,iapxmx)
      call initaz(bpx,ibpxmx)
c
c     Read the number of interaction coefficients for computing
c     activity coefficients in this solid solution.
c
      read (ndat0s,1020,end=990,err=995) uline
      read (uline,1270,err=995) iapxt
 1270 format(i3)
c
      if (iapxt .gt. 0) then
        n = 0
        do ii = 1,iapxt/6
          read (ndat0s,1020,end=990,err=995) uline
          read (uline,1280,err=995) (apx(n + k), k = 1,6)
 1280     format(6f6.3)
          n = n + 6
        enddo
        j = mod(ikt,6)
        if (j .gt. 0) then
          read (ndat0s,1020,end=990,err=995) uline
          read (uline,1280,err=995) (apx(n + k), k = 1,j)
          n = n + j
        endif
      endif
c
c     Read the number of site-mixing parameters for computing
c     activity coefficients in this solid solution.
c
      read (ndat0s,1270,end=990,err=995) ibpxt
c
      if (ibpxt .gt. 0) then
        n = 0
        do ii = 1,ibpxt/6
          read (ndat0s,1020,end=990,err=995) uline
          read (uline,1280,err=995) (bpx(n + k), k = 1,6)
          n = n + 6
        enddo
        j = mod(ikt,6)
        if (j .gt. 0) then
          read (ndat0s,1020,end=990,err=995) uline
          read (uline,1280,err=995) (bpx(n + k), k = 1,j)
          n = n + j
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write block on the DATA1 and DATA1F files.
c
      write (ndata1) ussoph(nxt),ikt,jsol
      write (ndata1) (ussosp(i,nxt), i = 1,ikt)
      write (ndata1) iapxt
      if (iapxt .gt. 0) write (ndata1) (apx(i), i = 1,iapxt)
      write (ndata1) ibpxt
      if (ibpxt .gt. 0) write (ndata1) (bpx(i), i = 1,ibpxt)
c
      write (ndat1f,1330) ussoph(nxt),ikt,jsol
 1330 format(a24,2x,2i5)
c
      i = 1
  250 continue
      if (i .eq. ikt) then
        j2 = ilnobl(ussosp(i,nxt))
        write (ndat1f,1340) ussosp(i,nxt)(1:j2)
 1340   format(5x,a)
        i = i + 1
      else
        j2 = ilnobl(ussosp(i + 1,nxt))
        write (ndat1f,1350) ussosp(i,nxt),ussosp(i + 1,nxt)(1:j2)
 1350   format(5x,a24,5x,a)
        i = i + 2
      endif
      if (i .le. ikt) go to 250
c
      write (ndat1f,1360) iapxt
 1360 format(i3)
      if (iapxt .gt. 0) write (ndat1f,1370) (apx(i), i = 1,iapxt)
 1370   format(6f6.3)
      write (ndat1f,1360) ibpxt
      if (ibpxt .gt. 0) write (ndat1f,1370) (bpx(i), i = 1,ibpxt)
c
      j2 = ilnobl(ussoph(nxt))
      write (noutpt,1380) ussoph(nxt)(1:j2),ikt,jsol
 1380 format(1x,a,/5x,'Number of components= ',i3,2x,
     $ 'Activity coefficient code= ',i3)
c
      i = 1
  260 continue
      if (i .eq. ikt) then
        j2 = ilnobl(ussosp(i,nxt))
        write (noutpt,1040) ussosp(i,nxt)(1:j2)
        i = i + 1
      else
        j2 = ilnobl(ussosp(i + 1,nxt))
        write (noutpt,1050) ussosp(i,nxt),ussosp(i + 1,nxt)(1:j2)
        i = i + 2
      endif
      if (i .le. ikt) go to 260
c
      write (ndat1f,1000) utermc(1:72)
c
c     Skip to the terminator.
c
  170 continue
      read (ndat0s,1020,end=990,err=995) uline
      ux8 = uline(1:8)
      if(ux8(1:8) .ne. uterm(1:8)) go to 170
      go to 100
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/pcrss) Unexpectedly encountered',
     $ /7x,'end-of-file while reading the DATA0 file.')
c
      write (noutpt,2010) nxt
      write (nttyo,2010) nxt
 2010 format(7x,'The value of the solid solution block counter is ',
     $ i3,'.')
c
      if (nxt .gt. 0) then
        j2 = ilnobl(ussoph(nxt))
        write (noutpt,2020) ussoph(nxt)(1:j2)
        write (nttyo,2020) ussoph(nxt)(1:j2)
 2020   format(7x,'The last solid solution name read was "',a,'".')
      else
        write (noutpt,2030) unone(1:j2)
        write (nttyo,2030) unone(1:j2)
 2030   format(7x,'No solid solutions were read.')
      endif
c
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,70)
        write (noutpt,2040) uline(1:j2)
        write (nttyo,2040) uline(1:j2)
 2040   format(7x,'The last line read was the following:',
     $  /7x,'"',a,'"')
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  995 write (noutpt,2050)
      write (nttyo,2050)
 2050 format(/' * Error - (EQPT/pcrss) Encountered a read format',
     $ /7x,'error while reading the DATA0 file.')
c
      write (noutpt,2010) nxt
      write (nttyo,2010) nxt
      if (nxt .gt. 0) then
        j2 = ilnobl(ussoph(nxt))
        write (noutpt,2020) ussoph(nxt)(1:j2)
        write (nttyo,2020) ussoph(nxt)(1:j2)
      else
        write (noutpt,2030)
        write (nttyo,2030)
      endif
c
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,70)
        write (noutpt,2040) uline(1:j2)
        write (nttyo,2040) uline(1:j2)
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine prrecy(cdrs,nbtmx1,nbtmx2,nbt,ns,nfile,uspec)
c
c     This subroutine writes the reaction associated with the ns-th
c     species on the file whose unit number is nfile. This subroutine
c     is virtually identical in function to EQLIB/prreac.f, but
c     deals with data that is structured somewhat differently.
c
c     This subroutine is called by:
c
c       EQPT/rxnchk.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       cdrs   = array of reaction coefficients
c       ns     = species whose reaction is to be printed
c       nfile  = unit number of the file to write on
c       uspec  = array of species names
c
c     Principal input:
c
c       None
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer nbtmx1,nbtmx2
c
      integer nbt,nfile,ns
c
      character*24 uspec(nbtmx1)
c
      real*8 cdrs(nbtmx2,nbtmx1)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer j2,nj,nb,nbt1
c
      integer ilnobl
c
      real*8 cx
c
c-----------------------------------------------------------------------
c
      nbt1 = nbt + 1
      cx = -cdrs(nbt1,ns)
      j2 = ilnobl(uspec(ns))
      write (nfile,1000) cx,uspec(ns)(1:j2)
 1000 format(/21x,f10.5,2x,a)
c
      do nb = 1,nbt
        cx = -cdrs(nb,ns)
        if (cx .gt. 0.) then
          j2 = ilnobl(uspec(nb))
          write (nfile,1010) cx,uspec(nb)(1:j2)
 1010     format(18x,' + ',f10.5,2x,a)
        endif
      enddo
c
      write (nfile,1020)
 1020 format(/31x,'='/)
c
      nj = 0
      do nb = 1,nbt
        cx = cdrs(nb,ns)
        if (cx .gt. 0.) then
          j2 = ilnobl(uspec(nb))
          if (nj .le. 0) then
            write (nfile,1030) cx,uspec(nb)(1:j2)
 1030       format(21x,f10.5,2x,a)
            nj = 1
          else
            write (nfile,1010) cx,uspec(nb)(1:j2)
          endif
        endif
      enddo
c
      end
      subroutine rdazp(azero,insgf,nazt,naztmx,ndat0s,nerr,noutpt,
     $ nttyo,uazp)
c
c     This subroutine reads hard core diamaters and related parameters
c     used in the B-dot equation from the DATA0 file. This data
c     consists of aqueous species names, hard core diameter
c     values, and an integer flag to indicate whether a species that
c     is electrically neutral should be considered polar (set log
c     gamma = 0) or non-polar (log gamma = log gamma for CO2(aq)).
c     The data are returned in the uazp, azero, and insgf arrays. They
c     are later written on the DATA1 and DATA1F files by EQPT/wrazp.f.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c
c     Principal output:
c
c       nazt   = the number of specified hard core diameters
c       uazp   = array of aqueous species names used to specify
c                  hard core diamters on the data file
c       azero  = array of corresponding hard core diameters
c       insgf  = array of corresponding neutral species
c                  activity coefficient flags
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer naztmx
c
      integer ndat0s,noutpt,nttyo
c
      integer nazt,nerr
c
      integer insgf(naztmx)
c
      character*24 uazp(naztmx)
c
      real*8 azero(naztmx)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer j2,j3,j4
c
      integer ilnobl
c
      character*80 uline
      character*24 ux24
      character*8 ubdot,uterm,ux8
c
c-----------------------------------------------------------------------
c
      data ubdot / 'bdot par' /
      data uterm / '+-------' /
c
c-----------------------------------------------------------------------
c
      nazt = 0
c
c     Advance to bdot header.
c
  100 continue
      read (ndat0s,1000,end=990,err=995) uline
 1000 format(a)
      ux8 = uline(1:8)
      if (ux8(1:8) .ne. ubdot(1:8)) go to 100
c
c     Skip the terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c     Read in the azero ('bdot') data.
c
  110 continue
      read (ndat0s,1000,end=990,err=995) uline
      ux8 = uline(1:8)
c
      if (ux8(1:8) .eq. uterm(1:8)) then
c
c       Have found the block terminator. Skip past the element
c       header.
c
        read (ndat0s,1000,end=990,err=995) uline
c
        go to 999
      endif
c
c     Found another entry. Read the data from the line.
c
      nazt = nazt + 1
      read(uline,1010,err=998) uazp(nazt),azero(nazt),insgf(nazt)
 1010 format(a24,7x,f7.1,4x,i2)
c
      j2 = ilnobl(uazp(nazt))
      if (j2 .le. 0) then
        write (ux8,'(i5)') nazt
        call lejust(ux8)
        j3 = ilnobl(ux8)
        write (noutpt,1030) ux8(1:j3)
        write (nttyo,1030) ux8(1:j3)
 1030   format(/' * Error - (EQPT/rdazp) Have encountered a blank',
     $  ' species name on line ',a,/7x,'of the block of hard core',
     $  ' diameter values for aqueous species.')
        if (nazt .gt. 1) then
          ux24 = uazp(nazt - 1)
          if (ux24(1:7) .ne. '<blank>') then
            j4 = ilnobl(ux24)
            write (noutpt,1040) ux24(1:j4)
            write (nttyo,1040) ux24(1:j4)
 1040       format(7x,'This line follows the one for ',a,'.')
          endif
        endif
        uazp(nazt) = '<blank>'
        nerr = nerr + 1
      endif
c
      go to 110
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/rdazp) Unexpectedly encountered',
     $ /7x,'end-of-file while reading the DATA0 file.')
c
      write (noutpt,2010) nazt
      write (nttyo,2010) nazt
 2010 format(7x,'The value of the local block line counter is ',i4,'.')
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,70)
        write (noutpt,2030) uline(1:j2)
        write (nttyo,2030) uline(1:j2)
 2030   format(7x,'The last line read was the following:',
     $  /7x,'"',a,'"')
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  995 write (noutpt,2040)
      write (nttyo,2040)
 2040 format(/' * Error - (EQPT/rdazp) Encountered a read format',
     $ /7x,'error while reading the DATA0 file.')
c
      write (noutpt,2010) nazt
      write (nttyo,2010) nazt
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,70)
        write (noutpt,2030) uline(1:j2)
        write (nttyo,2030) uline(1:j2)
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  998 write (noutpt,2050)
      write (nttyo,2050)
 2050 format(/' * Error - (EQPT/rdazp) Encountered a read format error',
     $ /7x,'while reading data from lines read from the DATA0 file.')
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,70)
        write (noutpt,2060) uline(1:j2)
        write (nttyo,2060) uline(1:j2)
 2060   format(7x,'The line with the problem is:',
     $  /7x,'"',a,'"')
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $ udbval,xdbval)
c
c     This subroutine reads data from the standard log K temperature
c     grid. Other kinds of data are read from such grids.
c
c     This suboutine is called by:
c
c       EQPT/rdpar.f
c       EQPT/pcraq.f
c       EQPT/pcrsg.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndbptg = the number of points on the grid
c       ndbptl = the maximum number of points on a single line
c
c     Principal output:
c
c       qend   = logical flag, = .true. if end-of-file was encountered
c       qerr   = logical flag, = .true. if a read format error was
c                  encountered
c       udbval = string array, the equivalent of xdbval
c       xdbval = array containing the data read from the grid
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ndbmax
c
      integer ndat0s
c
      integer ndbptg,ndbptl
c
      logical qend,qerr,q500nd
c
      character(len=16) udbval(ndbmax)
c
      real(8) xdbval(ndbmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ii,j,jj,k,n
c
      character(len=80) uline,ulbufa,ulbufb
      character(len=16) ux16
c
c-----------------------------------------------------------------------
c
      qend = .false.
      qerr = .false.
c
c     Note: the following coding generally assumes that a blank
c     space trails all but the last number on a line. If a blank
c     space is not found, it is assumed that a number ends after
c     four decimal places.
c
      n = 0
      do i = 1,ndbptg/ndbptl
        read (ndat0s,'(a)',end=990,err=995) uline
        ulbufa = uline
        do k = 1,ndbptl
          call lejust(ulbufa)
          ii = index(ulbufa,' ')
          jj = index(ulbufa,'.')
          if (jj .eq. 0) then
            jj = 80
          else
            jj = jj + 5
          endif
          ii = min(ii,jj)
          if (ii .gt. 1) then
            ux16 = ulbufa(1:ii - 1)
            call locase(ux16)
            udbval(n + k) = ux16
            if (ux16(1:7) .eq. 'no_data') then
              xdbval(n + k) = 9999999.
            else
              read (ux16,'(f10.4)',err=995) xdbval(n + k)
            endif
          else
            udbval(n + k) = ' '
            xdbval(n + k) = 0.
          endif
          if (k .lt. ndbptl) then
            ulbufb = ulbufa(ii:80)
            ulbufa = ulbufb
          endif
        enddo
c       read (uline,udbfmt,err=995) (xdbval(n + k), k = 1,ndbptl)
c       Note: udbfmt = '( (5x,6f10.4) )' with the "6" repeat
c       count replaced by ndbptl.
        n = n + ndbptl
      enddo
c
      j = mod(ndbptg,ndbptl)
      if (j .gt. 0) then
        read (ndat0s,'(a)',end=990,err=995) uline
        ulbufa = uline
        do k = 1,j
          call lejust(ulbufa)
          ii = index(ulbufa,' ')
          jj = index(ulbufa,'.')
          if (jj .eq. 0) then
            jj = 80
          else
            jj = jj + 5
          endif
          ii = min(ii,jj)
          if (ii .gt. 1) then
            ux16 = ulbufa(1:ii - 1)
            call locase(ux16)
            udbval(n + k) = ux16
            if (ux16(1:7) .eq. 'no_data') then
              xdbval(n + k) = 9999999.
            else
              read (ux16,'(f10.4)',err=995) xdbval(n + k)
            endif
          else
            udbval(n + k) = ' '
            xdbval(n + k) = 0.
          endif
          if (k .lt. j) then
            ulbufb = ulbufa(ii:80)
            ulbufa = ulbufb
          endif
        enddo
c       read (uline,udbfmt,err=995) (xdbval(n + k), k = 1,j)
        n = n + j
      endif
c
      if (q500nd) then
c
c       Apply the following filter. Treat values of "500.0000" as
c       "no data". This accommodates older EQ3/6 data files which
c       use "500.0000" to mean no data.
c
        do i = 1,ndbptg
          if (xdbval(i).gt.499.9999 .and. xdbval(i).lt.500.0001) then
            udbval(i) = 'no_data'
            xdbval(i) = 9999999.
          endif
        enddo
      endif
c
      go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 qend = .true.
      go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  995 qerr = .true.
      go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rdpar(adh,adhh,adhv,aphi,bdh,bdhh,bdhv,bdot,bdoth,
     $ bdotv,cco2,dadhh,dadhv,dbdhh,dbdhv,dbdth,dbdtv,dhfe,dvfe,
     $ ipch,ipchmx,ipcv,ipcvmx,itgenf,nacdpr,narxmx,narxt,ndat0s,
     $ ndbmax,ndbptg,ndbptl,nerr,noutpt,ntprmx,ntprt,nttyo,nwarn,
     $ prehw,presg,q500fl,tdamax,tdamin,tempc,uakey,udbfmt,udbval,
     $ xdbval,xhfe,xlke,xvfe)
c
c     This subroutine reads the data describing the temperature grid
c     and data for miscellaneous parameters which are represented
c     on this grid from the DATA0 file. Such parameters include the
c     pressure, the Debye-Huckel parameters A(gamma,10), B(gamma),
c     and A(phi), the B-dot parameter of Helgeson (1969), and the
c     equilibrium constant for the "Eh" reaction. Depending on the
c     values of the ipch and ipcv flags, pressure derivatives of
c     various order of these parameters may also be read. If pressure
c     corrections are available, a grid for the half-width of the
c     pressure correction band is also read. This subroutine also
c     reads the nominal temperature limits for the data file. These
c     limits are written on the DATA1 and DATA1F files. This suboutine
c     also reads the coefficients needed to calculate the acivity
c     coefficient of CO2(aq) using the Drummond (1981) equation.
c
c     The counter nerr is incremented by one for each error encountered.
c     The counter nwarn is similarly incremented for each warning.
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ipch   = enthalpy functions data grid flag:
c                  -1 = no enthalpy grids
c                   0 = enthalpy grids present
c                   1 = grids present for the enthalpy and its first
c                         pressure derivative
c                   2 = grids present for the enthalpy and its first
c                         and second pressure derivatives
c       ipcv   = volume functions data flag:
c                  -1 = no volume grids
c                   0 = volume grids present
c                   1 = grids present for the volume and its first
c                         pressure derivative
c                   2 = grids present for the volume and its first
c                         and second pressure derivatives
c       ndat0s = unit number of the stripped DATA0 file
c       narxt  = array of numbers of coefficients in the temperature
c                  ranges
c       ntprt  = the number of temperature ranges on the standard
c                  temperature grid
c       uakey  = string specifying the type of data file ("SEDH" or
c                  "Pitzer") being processed
c
c     Principal output:
c
c       adh    = array of A(gamma,10) values on the standard
c                  temperature grid
c       adhh   = array of A(H) values on the standard temperature
c                  grid; A(H) contains but is not equal to
c                  dA(gamma,10)/dT
c       adhv   = array of A(V) values on the standard temperature
c                  grid; A(V) contains but is not equal to
c                  dA(gamma,10)/dP
c       aphi   = array of A(phi) values on the standard temperature
c                  grid; A(phi) = A(gamma,e)/3 = 2.303A(gamma,10)/3,
c                  so the pressure derivatives of A(phi) are obtained
c                  from A(V) and dnA(V)/dPn.
c       bdh    = array of B(gamma) values on the standard temperature
c                  grid
c       bdhh   = array of B(H) values on the standard temperature grid
c       bdhv   = array of B(V) values on the standard temperature grid
c       bdot   = array of B-dot values on the standard temperature
c                  grid
c       bdoth  = array of B-dot(H)values on the standard temperature
c                  grid
c       bdotv  = array of B-dot(V) values on the standard temperature
c                  grid
c       cco2   = array of coefficients for the Drummond (1981)
c                  equation
c       dadhh  = array of dnA(H)/dPn values on the standard temperature
c                  grid
c       dadhv  = array of dnA(V)/dPn values on the standard temperature
c                  grid
c       dbdhh  = array of dnB(H)/dPn values on the standard temperature
c                  grid
c       dbdhv  = array of dnA(V)/dPn values on the standard temperature
c                  grid
c       dbdth  = array of dnB-dot(H)/dPn values on the standard
c                  temperature grid
c       dbdtv  = array of dnB-dot(V)/dPn values on the standard
c                  temperature grid
c       dhfe   = array of pressure derivatives of the enthalpy of
c                  reaction for the "Eh" reaction on the standard
c                  temperature grid
c       dvfe   = array of pressure derivatives of the volume of
c                  reaction for the "Eh" reaction on the standard
c                  temperature grid
c       ndbptg = the number of distinct points on the standard
c                  temperature grid.
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c       presg  = array of standard pressures on the standard
c                  temperature grid
c       prehw  = array of half-width values for the standard pressure
c                  envelope on the standard temperature grid
c       tdamax = the nominal maximum temperature (C) for which the
c                  data file is valid
c       tdamin = the nominal minimum temperature (C) for which the
c                  data file is valid
c       tempc  = array of temperatures defining the standard
c                  temperature grid
c       udbfmt = the format used when reading a line of data on the
c                  standard temperature grid
c       xlke   = array of log K values for the "Eh" reaction
c                  on the standard temperature grid
c       xhfe   = array of enthalpy of reaction values for the "Eh"
c                  reaction hon the standard temperature grid
c       xvfe   = array of volume of reaction values for the "Eh"
c                  reaction on the standard temperature grid
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipchmx,ipcvmx,narxmx,ndbmax,ntprmx
c
      integer ndat0s,noutpt,nttyo
c
      integer nacdpr(ntprmx),narxt(ntprmx)
c
      integer ipch,ipcv,itgenf,ndbptg,ndbptl,nerr,ntprt,nwarn
c
      logical q500fl
c
      character(len=16) udbval(ndbmax)
c
      character(len=16) udbfmt
      character(len=8) uakey
c
      real(8) tdamax,tdamin
c
      real(8) cco2(5)
c
      real(8) adh(narxmx,ntprmx),adhh(narxmx,ntprmx),
     $ adhv(narxmx,ntprmx),aphi(narxmx,ntprmx),bdh(narxmx,ntprmx),
     $ bdhh(narxmx,ntprmx),bdhv(narxmx,ntprmx),bdot(narxmx,ntprmx),
     $ bdoth(narxmx,ntprmx),bdotv(narxmx,ntprmx),
     $ dadhh(narxmx,ntprmx,ipchmx),dadhv(narxmx,ntprmx,ipcvmx),
     $ dbdhh(narxmx,ntprmx,ipchmx),dbdhv(narxmx,ntprmx,ipcvmx),
     $ dbdth(narxmx,ntprmx,ipchmx),dbdtv(narxmx,ntprmx,ipcvmx),
     $ dhfe(narxmx,ntprmx,ipchmx),dvfe(narxmx,ntprmx,ipcvmx),
     $ prehw(narxmx,ntprmx),presg(narxmx,ntprmx),tempc(narxmx,ntprmx),
     $ xdbval(ndbmax),xhfe(narxmx,ntprmx),xlke(narxmx,ntprmx),
     $ xvfe(narxmx,ntprmx)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ipc,j2,j3,n,ndbloc,ntpr
c
      integer ilnobl
c
      logical qend,qerr,q500nd
c
      character(len=24) ux24,ux24lc
      character(len=80) ulbufa,ulbufb,uline,ustr80
c
c-----------------------------------------------------------------------
c
c     Skip to the 'Temperature limits' line.
c
      ux24 = 'Temperature limits (degC'
      ux24lc = ux24
      call locase(ux24lc)
  100 read (ndat0s,1000,end=110,err=995) ustr80
 1000 format(a)
      call lejust(ustr80)
      call locase(ustr80)
      if (ustr80(1:24) .ne. ux24lc(1:24)) go to 100
      go to 120
c
  110 j2 = ilnobl(ux24)
      write (noutpt,1010) ux24(1:j2)
      write (nttyo,1010) ux24(1:j2)
 1010 format(/' * Error - (EQPT/rdpar) Unexpectedly encountered',
     $ ' end-of-file',/7x,'while searching the DATA0 file for the',
     $ ' find the line containing',/7x,'"',a,'".')
      stop
  120 continue
c
c     Read in the parameters. First, read the nominal temperature
c     limits.
c
      read (ndat0s,1002,end=990,err=995) tdamin,tdamax
 1002 format(5x,2f10.4)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the standard temperature grid. The format of this grid will
c     be analyzed and will serve as a template for that of subsequent
c     data presented on this grid. The original EQ3/6 format was
c     four points per line. Up to six points per line are now possible.
c     The format will be determined by counting the number of data
c     points on the first line.
c
c       ndbptl = maximum number of data points per line (1-6)
c       ndbptg = number of data points in the entire grid
c       ndbloc = number of lines containing the grid
c
      ndbptg = narxt(1)
      do ntpr = 2,ntprt
        ndbptg = ndbptg + narxt(ntpr) - 1
      enddo
c
      ux24 = 'Temperatures            '
      ux24lc = ux24
      call locase(ux24lc)
      read (ndat0s,1000,end=990,err=995) ustr80
      call lejust(ustr80)
      call locase(ustr80)
      if (ustr80(1:24) .ne. ux24lc(1:24)) then
        ux24 = 'Temperature grid (degC) '
        ux24lc = ux24
        call locase(ux24lc)
      endif
      if (ustr80(1:24) .ne. ux24lc(1:24)) then
        ux24 = 'Temperature grid (C)    '
        ux24lc = ux24
        call locase(ux24lc)
      endif
c
      if (ustr80(1:24) .ne. ux24lc(1:24)) then
        j2 = ilnobl(ux24)
        j3 = ilnobl(ustr80)
        j3 = min(j3,24)
        write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
        write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
 1020   format(/' * Error - (EQPT/rdpar) Found the string "',a,'"',
     $  /7x,'on the DATA0 file where the string "',a,'"',
     $  /7x,'was expected.')
        stop
      endif
c
c     Analyze the grid format.
c
      read (ndat0s,1030,end=990,err=995) uline
 1030 format(a80)
      backspace(ndat0s)
c
      ulbufa = uline
      ulbufb = ' '
      ndbptl = 0
      do n = 1,6
        call lejust(ulbufa)
        i = index(ulbufa,' ')
        if (i .le. 1) go to 130
        ndbptl = ndbptl + 1
        ulbufb = ulbufa(i:80)
        ulbufa = ulbufb
      enddo
  130 continue
c
      ndbloc = ndbptg/ndbptl
      if (mod(ndbptg,ndbptl) .gt. 0) ndbloc = ndbloc + 1
      udbfmt = '( (5x,6f10.4) )'
      write (udbfmt(7:7),'(i1)') ndbptl
c
c     The format analysis is complete.
c     Read the temperatures on the log K temperature grid.
c     Return the data in the xdbval holding array.
c
      q500nd = .false.
      call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $ udbval,xdbval)
      if (qend) go to 990
      if (qerr) go to 995
c     read (ndat0s,udbfmt,end=990,err=995) (xdbval(i), i = 1,ndbptg)
c
c     Load the data into the tempc array.
c
c     Calling sequence substitutions:
c       tempc for zdbval
c
      call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $ xdbval,tempc)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the standard pressure grid.
c
      ux24 = 'Pressures               '
      ux24lc = ux24
      call locase(ux24lc)
      read (ndat0s,1000,end=990,err=995) ustr80
      call lejust(ustr80)
      call locase(ustr80)
      if (ustr80(1:24) .ne. ux24lc(1:24)) then
        ux24 = 'Pressure grid (bars)    '
        ux24lc = ux24
        call locase(ux24lc)
      endif
c
      if (ustr80(1:24) .ne. ux24lc(1:24)) then
        j2 = ilnobl(ux24)
        j3 = ilnobl(ustr80)
        j3 = min(j3,24)
        write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
        write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
        stop
      endif
c
c     Read the pressures on the log K temperature grid.
c     Return the data in the xdbval holding array.
c
      q500nd = .false.
      call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $ udbval,xdbval)
      if (qend) go to 990
      if (qerr) go to 995
c
c     Load the data into the presg array.
c
c     Calling sequence substitutions:
c       presg for zdbval
c
      call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $ xdbval,presg)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (ipcv .ge. 0) then
c
c       Read the standard pressure envelope half-width.
c
        ux24 = 'Pressure envelope half-w'
        ux24lc = ux24
        call locase(ux24lc)
        read (ndat0s,1000,end=990,err=995) ustr80
        call lejust(ustr80)
        call locase(ustr80)
c
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          j2 = ilnobl(ux24)
          j3 = ilnobl(ustr80)
          j3 = min(j3,24)
          write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
          write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
          stop
        endif
c
c       Read the pressure half-widths on the log K temperature grid.
c       Return the data in the xdbval holding array.
c
        q500nd = .false.
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the prehw array.
c
c       Calling sequence substitutions:
c         prehw for zdbval
c
        call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $  xdbval,prehw)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (uakey(1:8) .eq .'SEDH    ') then
c
c       Read the grid for the Debye-Huckel A(gamma,10) parameter and
c       the grids for related parameters.
c
        ux24 = 'Debye Huckel A (ADH)    '
        ux24lc = ux24
        call locase(ux24lc)
        read (ndat0s,1000,end=990,err=995) ustr80
        call lejust(ustr80)
        call locase(ustr80)
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          ux24 = 'Debye-Huckel A_gamma (kg'
          ux24lc = ux24
          call locase(ux24lc)
        endif
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          ux24 = 'Debye-Huckel A_gamma    '
          ux24lc = ux24
          call locase(ux24lc)
        endif
c
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          j2 = ilnobl(ux24)
          j3 = ilnobl(ustr80)
          j3 = min(j3,24)
          write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
          write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
          stop
        endif
c
c       Read the Debye-Huckel A(gamma,10) values on the log K
c       temperature grid. Return the data in the xdbval holding array.
c
        q500nd = q500fl
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the adh array.
c
c       Calling sequence substitutions:
c         adh for zdbval
c
        call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $  xdbval,adh)
c
        if (ipch .ge. 0) then
c
c         Read the grid for the Debye-Huckel A(H) parameter.
c
          ux24 = 'Debye-Huckel A_H (kcal*k'
          ux24lc = ux24
          call locase(ux24lc)
          read (ndat0s,1000,end=990,err=995) ustr80
          call lejust(ustr80)
          call locase(ustr80)
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            ux24 = 'Debye-Huckel A_H        '
            ux24lc = ux24
            call locase(ux24lc)
          endif
c
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            j2 = ilnobl(ux24)
            j3 = ilnobl(ustr80)
            j3 = min(j3,24)
            write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
            write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
            stop
          endif
c
c         Read the Debye-Huckel A(H) values on the log K temperature
c         grid. Return the data in the xdbval holding array.
c
          q500nd = q500fl
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the adhh array.
c
c         Calling sequence substitutions:
c           adhh for zdbval
c
          call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $    xdbval,adhh)
c
          do ipc = 1,ipch
c
            read (ndat0s,1000,end=990,err=995) ustr80
c
c           Read the Debye-Huckel A(H) pressure derivatives on the
c           log K temperature grid. Return the data in the xdbval
c           holding array.
c
            q500nd = q500fl
            call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $      udbval,xdbval)
            if (qend) go to 990
            if (qerr) go to 995
c
c           Load the data into the dadhh array.
c
c           Calling sequence substitutions:
c             dadhh for zdbval
c             ipchmx for ipcmax
c
            call ldbar3(ipc,ipchmx,nacdpr,narxmx,narxt,ndbmax,
     $      ntprmx,ntprt,xdbval,dadhh)
          enddo
        endif
c
        if (ipcv .ge. 0) then
c
c         Read the grid for the Debye-Huckel A(V) parameter.
c
          ux24 = 'Debye-Huckel A_V (cm**3*'
          ux24lc = ux24
          call locase(ux24lc)
          read (ndat0s,1000,end=990,err=995) ustr80
          call lejust(ustr80)
          call locase(ustr80)
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            ux24 = 'Debye-Huckel A_V        '
            ux24lc = ux24
            call locase(ux24lc)
          endif
c
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            j2 = ilnobl(ux24)
            j3 = ilnobl(ustr80)
            j3 = min(j3,24)
            write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
            write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
            stop
          endif
c
c         Read the Debye-Huckel A(V) values on the log K temperature
c         grid. Return the data in the xdbval holding array.
c
          q500nd = q500fl
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the adhv array.
c
c         Calling sequence substitutions:
c           adhv for zdbval
c
          call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $    xdbval,adhv)
c
          do ipc = 1,ipcv
c
            read (ndat0s,1000,end=990,err=995) ustr80
c
c           Read the Debye-Huckel A(V) pressure derivatives on the
c           log K temperature grid. Return the data in the xdbval
c           holding array.
c
            q500nd = q500fl
            call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $      udbval,xdbval)
            if (qend) go to 990
            if (qerr) go to 995
c
c           Load the data into the dadhv array.
c
c           Calling sequence substitutions:
c             dadhv for zdbval
c             ipcvmx for ipcmax
c
            call ldbar3(ipc,ipcvmx,nacdpr,narxmx,narxt,ndbmax,
     $      ntprmx,ntprt,xdbval,dadhv)
          enddo
        endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c       Read the grid for the Debye-Huckel B(gamma) parameter and
c
        ux24 = 'Debye Huckel B (BDH)    '
        ux24lc = ux24
        call locase(ux24lc)
        read (ndat0s,1000,end=990,err=995) ustr80
        call lejust(ustr80)
        call locase(ustr80)
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          ux24 = 'Debye-Huckel B_gamma (kg'
          ux24lc = ux24
          call locase(ux24lc)
        endif
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          ux24 = 'Debye-Huckel B_gamma    '
          ux24lc = ux24
          call locase(ux24lc)
        endif
c
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          j2 = ilnobl(ux24)
          j3 = ilnobl(ustr80)
          j3 = min(j3,24)
          write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
          write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
          stop
        endif
c
c       Read the Debye-Huckel B(gamma) values on the log K temperature
c       grid. Return the data in the xdbval holding array.
c
        q500nd = q500fl
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the bdh array.
c
c       Calling sequence substitutions:
c         bdh for zdbval
c
        call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $  xdbval,bdh)
c
        if (ipch .ge. 0) then
c
c         Read the grid for the Debye-Huckel B(H) parameter.
c
          ux24 = 'Debye-Huckel B_H (cal*kg'
          ux24lc = ux24
          call locase(ux24lc)
          read (ndat0s,1000,end=990,err=995) ustr80
          call lejust(ustr80)
          call locase(ustr80)
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            ux24 = 'Debye-Huckel B_H        '
            ux24lc = ux24
            call locase(ux24lc)
          endif
c
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            j2 = ilnobl(ux24)
            j3 = ilnobl(ustr80)
            j3 = min(j3,24)
            write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
            write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
            stop
          endif
c
c         Read the Debye-Huckel B(H) values on the log K temperature
c         grid. Return the data in the xdbval holding array.
c
          q500nd = q500fl
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the bdhh array.
c
c         Calling sequence substitutions:
c           bdhh for zdbval
c
          call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $    xdbval,bdhh)
c
          do ipc = 1,ipch
c
            read (ndat0s,1000,end=990,err=995) ustr80
c
c           Read the Debye-Huckel B(H) pressure derivatives on the
c           log K temperature grid. Return the data in the xdbval
c           holding array.
c
            q500nd = q500fl
            call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $      udbval,xdbval)
            if (qend) go to 990
            if (qerr) go to 995
c
c           Load the data into the dbdhh array.
c
c           Calling sequence substitutions:
c             dbdhh for zdbval
c             ipchmx for ipcmax
c
            call ldbar3(ipc,ipchmx,nacdpr,narxmx,narxt,ndbmax,
     $      ntprmx,ntprt,xdbval,dbdhh)
          enddo
        endif
c
        if (ipcv .ge. 0) then
c
c         Read the grid for the Debye-Huckel B(V) parameter.
c
          ux24 = 'Debye-Huckel B_V (cm**2*'
          ux24lc = ux24
          call locase(ux24lc)
          read (ndat0s,1000,end=990,err=995) ustr80
          call lejust(ustr80)
          call locase(ustr80)
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            ux24 = 'Debye-Huckel B_V        '
            ux24lc = ux24
            call locase(ux24lc)
          endif
c
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            j2 = ilnobl(ux24)
            j3 = ilnobl(ustr80)
            j3 = min(j3,24)
            write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
            write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
            stop
          endif
c
c         Read the Debye-Huckel B(V) values on the log K temperature
c         grid. Return the data in the xdbval holding array.
c
          q500nd = q500fl
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the bdhv array.
c
c         Calling sequence substitutions:
c           bdhv for zdbval
c
          call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $    xdbval,bdhv)
c
          do ipc = 1,ipcv
c
            read (ndat0s,1000,end=990,err=995) ustr80
c
c           Read the Debye-Huckel B(V) pressure derivatives on the
c           log K temperature grid. Return the data in the xdbval
c           holding array.
c
            q500nd = q500fl
            call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $      udbval,xdbval)
            if (qend) go to 990
            if (qerr) go to 995
c
c           Load the data into the dbdhv array.
c
c           Calling sequence substitutions:
c             dbdhv for zdbval
c             ipcvmx for ipcmax
c
            call ldbar3(ipc,ipcvmx,nacdpr,narxmx,narxt,ndbmax,
     $      ntprmx,ntprt,xdbval,dbdhv)
          enddo
        endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c       Read the grid for the B-dot parameter and the grids for
c       related parameters.
c
        ux24 = 'Bdot                    '
        ux24lc = ux24
        call locase(ux24lc)
        read (ndat0s,1000,end=990,err=995) ustr80
        call lejust(ustr80)
        call locase(ustr80)
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          ux24 = 'B-dot                   '
          ux24lc = ux24
          call locase(ux24lc)
        endif
c
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          j2 = ilnobl(ux24)
          j3 = ilnobl(ustr80)
          j3 = min(j3,24)
          write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
          write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
          stop
        endif
c
c       Read the B-dot values on the log K temperature grid.
c       Return the data in the xdbval holding array.
c
        q500nd = q500fl
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the bdot array.
c
c       Calling sequence substitutions:
c         bdot for zdbval
c
        call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $  xdbval,bdot)
c
        if (ipch .ge. 0) then
c
c         Read the grid for the B-dot(H) parameter.
c
          ux24 = 'B-dot_H                 '
          ux24lc = ux24
          call locase(ux24lc)
          read (ndat0s,1000,end=990,err=995) ustr80
          call lejust(ustr80)
          call locase(ustr80)
c
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            j2 = ilnobl(ux24)
            j3 = ilnobl(ustr80)
            j3 = min(j3,24)
            write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
            write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
            stop
          endif
c
c         Read the B-dot(H) values on the log K temperature grid
c         Return the data in the xdbval holding array.
c
          q500nd = q500fl
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the bdoth array.
c
c         Calling sequence substitutions:
c           bdoth for zdbval
c
          call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $    xdbval,bdoth)
c
          do ipc = 1,ipch
c
            read (ndat0s,1000,end=990,err=995) ustr80
c
c           Read the B-dot(H) pressure derivatives on the
c           log K temperature grid. Return the data in the xdbval
c           holding array.
c
            q500nd = q500fl
            call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $      udbval,xdbval)
            if (qend) go to 990
            if (qerr) go to 995
c
c           Load the data into the dbdth array.
c
c           Calling sequence substitutions:
c             dbdth for zdbval
c             ipchmx for ipcmax
c
            call ldbar3(ipc,ipchmx,nacdpr,narxmx,narxt,ndbmax,
     $      ntprmx,ntprt,xdbval,dbdth)
          enddo
        endif
c
        if (ipcv .ge. 0) then
c
c         Read the grid for the B-dot(V) parameter.
c
          ux24 = 'B-dot_V                 '
          ux24lc = ux24
          call locase(ux24lc)
          read (ndat0s,1000,end=990,err=995) ustr80
          call lejust(ustr80)
          call locase(ustr80)
c
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            j2 = ilnobl(ux24)
            j3 = ilnobl(ustr80)
            j3 = min(j3,24)
            write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
            write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
            stop
          endif
c
c         Read the B-dot(V) values on the log K temperature
c         grid. Return the data in the xdbval holding array.
c
          q500nd = q500fl
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the bdotv array.
c
c         Calling sequence substitutions:
c           bdotv for zdbval
c
          call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $    xdbval,bdotv)
c
          do ipc = 1,ipcv
c
            read (ndat0s,1000,end=990,err=995) ustr80
c
c           Read the B-dot(V) pressure derivatives on the
c           log K temperature grid. Return the data in the xdbval
c           holding array.
c
            q500nd = q500fl
            call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $      udbval,xdbval)
            if (qend) go to 990
            if (qerr) go to 995
c
c           Load the data into the dbdtv array.
c
c           Calling sequence substitutions:
c             dbdtv for zdbval
c             ipcvmx for ipcmax
c
            call ldbar3(ipc,ipcvmx,nacdpr,narxmx,narxt,ndbmax,
     $      ntprmx,ntprt,xdbval,dbdtv)
          enddo
        endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c       Read the coefficients for computing the activity coefficient
c       of CO2(aq) from the Drummond (1981) equation.
c
        ux24 = 'Cco2   (coefficients for'
        ux24lc = ux24
        call locase(ux24lc)
        read (ndat0s,1000,end=990,err=995) ustr80
        call lejust(ustr80)
        call locase(ustr80)
c
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          ux24 = 'Cco2                    '
          ux24lc = ux24
          call locase(ux24lc)
        endif
c
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          j2 = ilnobl(ux24)
          j3 = ilnobl(ustr80)
          j3 = min(j3,24)
          write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
          write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
          stop
        endif
c
        read (ndat0s,1060,end=990,err=995) (cco2(n), n = 1,5)
 1060   format(5x,f10.4,11x,f12.7,/10x,f5.1,11x,f12.4,/5x,f10.6)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (uakey(1:8) .eq .'Pitzer  ') then
c
c       Read the grid for the Debye-Huckel A(phi) parameter and
c       the grids for related parameters.
c
        ux24 = 'Debye Huckel Aphi       '
        ux24lc = ux24
        call locase(ux24lc)
        read (ndat0s,1000,end=990,err=995) ustr80
        call lejust(ustr80)
        call locase(ustr80)
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          ux24 = 'Debye_Huckel A_phi      '
          ux24lc = ux24
          call locase(ux24lc)
        endif
c
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          j2 = ilnobl(ux24)
          j3 = ilnobl(ustr80)
          j3 = min(j3,24)
          write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
          write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
          stop
        endif
c
c       Read the Debye-Huckel A(phi) values on the log K temperature
c       grid. Return the data in the xdbval holding array.
c
        q500nd = q500fl
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the aphi array.
c
c       Calling sequence substitutions:
c         aphi for zdbval
c
        call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $  xdbval,aphi)
c
        if (ipch .ge. 0) then
c
c         Read the grid for the Debye-Huckel A(H) parameter.
c
          ux24 = 'Debye-Huckel A_H (kcal*k'
          ux24lc = ux24
          call locase(ux24lc)
          read (ndat0s,1000,end=990,err=995) ustr80
          call lejust(ustr80)
          call locase(ustr80)
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            ux24 = 'Debye-Huckel A_H        '
            ux24lc = ux24
            call locase(ux24lc)
          endif
c
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            j2 = ilnobl(ux24)
            j3 = ilnobl(ustr80)
            j3 = min(j3,24)
            write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
            write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
            stop
          endif
c
c         Read the Debye-Huckel A(H) values on the log K temperature
c         grid. Return the data in the xdbval holding array.
c
          q500nd = q500fl
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the adhh array.
c
c         Calling sequence substitutions:
c           adhh for zdbval
c
          call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $    xdbval,adhh)
c
          do ipc = 1,ipch
c
            read (ndat0s,1000,end=990,err=995) ustr80
c
c           Read the Debye-Huckel A(H) pressure derivatives on the
c           log K temperature grid. Return the data in the xdbval
c           holding array.
c
            q500nd = q500fl
            call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $      udbval,xdbval)
            if (qend) go to 990
            if (qerr) go to 995
c
c           Load the data into the dadhh array.
c
c           Calling sequence substitutions:
c             dadhh for zdbval
c             ipchmx for ipcmax
c
            call ldbar3(ipc,ipchmx,nacdpr,narxmx,narxt,ndbmax,
     $      ntprmx,ntprt,xdbval,dadhh)
          enddo
        endif
c
        if (ipcv .ge. 0) then
c
c         Read the grid for the Debye-Huckel A(V) parameter.
c
          ux24 = 'Debye-Huckel A_V (cm**3*'
          ux24lc = ux24
          call locase(ux24lc)
          read (ndat0s,1000,end=990,err=995) ustr80
          call lejust(ustr80)
          call locase(ustr80)
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            ux24 = 'Debye-Huckel A_V        '
            ux24lc = ux24
            call locase(ux24lc)
          endif
c
          if (ustr80(1:24) .ne. ux24lc(1:24)) then
            j2 = ilnobl(ux24)
            j3 = ilnobl(ustr80)
            j3 = min(j3,24)
            write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
            write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
            stop
          endif
c
c         Read the Debye-Huckel A(V) values on the log K temperature
c         grid. Return the data in the xdbval holding array.
c
          q500nd = q500fl
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the adhv array.
c
c         Calling sequence substitutions:
c           adhv for zdbval
c
          call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $    xdbval,adhv)
c
          do ipc = 1,ipcv
c
            read (ndat0s,1000,end=990,err=995) ustr80
c
c           Read the Debye-Huckel A(V) pressure derivatives on the
c           log K temperature grid. Return the data in the xdbval
c           holding array.
c
            q500nd = q500fl
            call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $      udbval,xdbval)
            if (qend) go to 990
            if (qerr) go to 995
c
c           Load the data into the dadhv array.
c
c           Calling sequence substitutions:
c             dadhv for zdbval
c             ipcvmx for ipcmax
c
            call ldbar3(ipc,ipcvmx,nacdpr,narxmx,narxt,ndbmax,
     $      ntprmx,ntprt,xdbval,dadhv)
          enddo
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the grid for the log K of the "Eh" reaction and the grids
c     for related parameters.
c
      ux24 = 'log k for eh reaction   '
      ux24lc = ux24
      call locase(ux24lc)
      read (ndat0s,1000,end=990,err=995) ustr80
      call lejust(ustr80)
      call locase(ustr80)
      if (ustr80(1:24) .ne. ux24lc(1:24)) then
        ux24 = 'Eh reaction: logKr (2H2O'
        ux24lc = ux24
        call locase(ux24lc)
      endif
      if (ustr80(1:24) .ne. ux24lc(1:24)) then
        ux24 = 'Eh reaction: logKr      '
        ux24lc = ux24
        call locase(ux24lc)
      endif
c
      if (ustr80(1:24) .ne. ux24lc(1:24)) then
        j2 = ilnobl(ux24)
        j3 = ilnobl(ustr80)
        j3 = min(j3,24)
        write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
        write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
        stop
      endif
c
c     Read the "Eh" reaction log K values on the log K temperature
c     grid. Return the data in the xdbval holding array.
c
      q500nd = q500fl
      call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $ udbval,xdbval)
      if (qend) go to 990
      if (qerr) go to 995
c
c     Load the data into the xlke array.
c
c     Calling sequence substitutions:
c       xlke for zdbval
c
      call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $ xdbval,xlke)
c
      if (ipch .ge. 0) then
c
c       Read the grid for the enthalpy of reaction of the "Eh"
c       reaction.
c
        ux24 = 'Eh reaction: delh0r (kca'
        ux24lc = ux24
        call locase(ux24lc)
        read (ndat0s,1000,end=990,err=995) ustr80
        call lejust(ustr80)
        call locase(ustr80)
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          ux24 = 'Eh reaction: delH0r     '
          ux24lc = ux24
          call locase(ux24lc)
        endif
c
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          j2 = ilnobl(ux24)
          j3 = ilnobl(ustr80)
          j3 = min(j3,24)
          write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
          write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
          stop
        endif
c
c       Read the "Eh" reaction enthalpy function values on the
c       log K temperature grid. Return the data in the xdbval
c       holding array.
c
        q500nd = q500fl
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the xhfe array.
c
c       Calling sequence substitutions:
c         xhfe for zdbval
c
        call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $  xdbval,xhfe)
c
        do ipc = 1,ipch
c
          read (ndat0s,1000,end=990,err=995) ustr80
c
c         Read the "Eh" reaction enthalpy function derivatives on
c         the log K temperature grid. Return the data in the xdbval
c         holding array.
c
          q500nd = q500fl
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the dhfe array.
c
c         Calling sequence substitutions:
c           dhfe for zdbval
c           ipchmx for ipcmax
c
          call ldbar3(ipc,ipchmx,nacdpr,narxmx,narxt,ndbmax,
     $    ntprmx,ntprt,xdbval,dhfe)
        enddo
      endif
c
      if (ipcv .ge. 0) then
c
c       Read the grid for the volume of reaction of the "Eh"
c       reaction.
c
        ux24 = 'Eh reaction: delv0r (cm*'
        ux24lc = ux24
        call locase(ux24lc)
        read (ndat0s,1000,end=990,err=995) ustr80
        call lejust(ustr80)
        call locase(ustr80)
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          ux24 = 'Eh reaction: delV0r     '
          ux24lc = ux24
          call locase(ux24lc)
        endif
c
        if (ustr80(1:24) .ne. ux24lc(1:24)) then
          j2 = ilnobl(ux24)
          j3 = ilnobl(ustr80)
          j3 = min(j3,24)
          write (noutpt,1020) ustr80(1:j3),ux24(1:j2)
          write (nttyo,1020) ustr80(1:j3),ux24(1:j2)
          stop
        endif
c
c       Read the "Eh" reaction volume function values on the
c       log K temperature grid. Return the data in the xdbval
c       holding array.
c
        q500nd = q500fl
        call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $  udbval,xdbval)
        if (qend) go to 990
        if (qerr) go to 995
c
c       Load the data into the xvfe array.
c
c       Calling sequence substitutions:
c         xvfe for zdbval
c
        call ldbar2(nacdpr,narxmx,narxt,ndbmax,ntprmx,ntprt,
     $  xdbval,xvfe)
c
        do ipc = 1,ipcv
c
          read (ndat0s,1000,end=990,err=995) ustr80
c
c         Read the "Eh" reaction volume function derivatives on
c         the log K temperature grid. Return the data in the xdbval
c         holding array.
c
          q500nd = q500fl
          call rdgrid(ndat0s,ndbmax,ndbptg,ndbptl,qend,qerr,q500nd,
     $    udbval,xdbval)
          if (qend) go to 990
          if (qerr) go to 995
c
c         Load the data into the dvfe array.
c
c         Calling sequence substitutions:
c           dvfe for zdbval
c           ipcvmx for ipcmax
c
          call ldbar3(ipc,ipcvmx,nacdpr,narxmx,narxt,ndbmax,ntprmx,
     $    ntprt,xdbval,dvfe)
        enddo
      endif
c
      read (ndat0s,1000,end=990,err=995) ustr80
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/rdpar) Unexpectedly encountered',
     $ /7x,'end-of-file while reading the DATA0 file.')
      stop
c
  995 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdpar) Encountered a read format',
     $ /7x,'error while reading the DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rdpca(abeta,alpha,acphi,ipbtmx,jpfcmx,nat,natmax,
     $ ndat0s,nerr,noutpt,npxca,npx2mx,npx2t,nttyo,nwarn,uaqsp,
     $ upair,zaqsp)
c
c     This subroutine reads from the DATA1 file the coefficients
c     required to compute those Pitzer interaction parameters
c     associated with cation-anion (ca) pairs. This particular
c     set of interaction coefficients includes the following:
c
c       1. beta(0)(ca), beta(1),(ca) and beta(2)(ca)
c       2. Cphi(ca)
c
c     The alpha(1) and alpha(2) parameters which go with the beta
c     parameters are also read to allow increased flexibility over
c     simple assignment according to ca-pair type.
c
c     Coefficients required to compute Pitzer interaction coefficients
c     associated with other pair types or with triplets are not read
c     by this subroutine. This subroutine is one of several that
c     replace rdpz2.f and rdpz3.f.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c
c     Principal output:
c
c       alpha  = array of Pitzer alpha constants
c       acphi  = array of coefficients for computing Cphi parameters
c       abeta  = array of coefficients for computing beta parameters
c       nerr   = cumulative error counter
c       npxca  = the number of ca pairs for which Pitzer parameters
c                  were read from the data file
c       npx2t  = the number of pairs of all species types for which
c                  Pitzer parameters were read from the data file.
c       nwarn  = cumulative warning counter
c       uaqsp  = array of names of aqueous species
c       upair  = array of species names for species pairs
c       uaqsp  = array of electrical charge numbers of aqueous species
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,npx2mx
c
      integer ndat0s,noutpt,nttyo
c
      integer nat,nerr,npxca,npx2t,nwarn
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real(8) abeta(jpfcmx,0:ipbtmx,npx2mx),alpha(ipbtmx,npx2mx),
     $ acphi(jpfcmx,npx2mx),zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ier,iz1,iz2,j,j2,j3,j4,j5,j6,npx2,npx2te,n1,n2
c
      integer ilnobl
c
      character(len=80) udastr,uline,ux80
      character(len=24) unam1,unam2,ux24a,ux24b
      character(len=24) uhdca,uhdnxt
      character(len=16) ustr16
      character(len=8) uterm,ux8
c
      real(8) var,z1,z2
c
c-----------------------------------------------------------------------
c
      data uterm  /'+-------'/
      data uhdca  /"ca combinations: beta(n)"/
      data uhdnxt /"cc' and aa' combinations"/
c
c-----------------------------------------------------------------------
c
      npx2te = npx2t
      npx2 = npx2te
      j2 = 0
      j3 = 0
c
c     Advance to the start of the superblock for these parameters.
c
  100 read (ndat0s,1000,end=990,err=995) uline
 1000 format(a80)
      if (uline(1:24) .ne. uhdca(1:24)) go to 100
c
c     Skip the terminator.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the names of the species comprising a pair.
c
  110 read (ndat0s,1010,end=990,err=995) unam1,unam2
 1010 format(a24,2x,a24)
c
      if (unam1(1:24) .eq. uhdnxt(1:24)) then
c
c       Found the header for the next superblock of Pitzer parameters.
c       Back up one line and terminate reading the current superblock.
c
        npxca = npx2 - npx2te
        npx2t = npx2
        backspace(ndat0s)
        go to 999
      endif
c
      npx2 = npx2 + 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Setup up some string data for error messages.
c
      j2 = ilnobl(unam1)
      if (j2 .le. 0) then
        unam1 = '<blank>'
        j2 = ilnobl(unam1)
      endif
c
      j3 = ilnobl(unam2)
      if (j3 .le. 0) then
        unam2 = '<blank>'
        j3 = ilnobl(unam2)
      endif
c
      write (ux8,'(i5)') npx2
      call lejust(ux8)
      j4 = ilnobl(ux8)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for blank names.
c
      if (j2.le.0 .or. j3.le.0) then
        write (noutpt,1020) ux8(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1020) ux8(1:j4),unam1(1:j2),unam2(1:j3)
 1020   format(/' * Error - (EQPT/rdpca) Have encountered a blank',
     $  ' species name',/7x,'in the species pair for block ',a,
     $  ' of the superblock for',/7x,'Pitzer ca parameter data.',
     $  ' The offending pair shows as ',a,', ',a,'.')
c
        if (npx2 .gt. (npx2te + 1)) then
          ux24a = upair(1,npx2 - 1)
          ux24b = upair(2,npx2 - 1)
          if (ux24a(1:7).ne.'<blank>' .or.
     $      ux24b(1:7).ne.'<blank>') then
            j5 = ilnobl(ux24a)
            j6 = ilnobl(ux24b)
            write (noutpt,1030) ux24a(1:j5),ux24b(1:j6)
            write (nttyo,1030) ux24a(1:j5),ux24b(1:j6)
 1030       format(7x,'This block follows the one for ',a,
     $      ', ',a,'.')
          endif
        endif
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the indices of the two species (n1, n2). These
c     indices point to the data read from the previously
c     read species blocks.
c
c     Calling sequence substitutions:
c       n1 for na
c       unam1 for unams
c
      call gspidx(ier,n1,nat,natmax,uaqsp,unam1)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          write (noutpt,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
 1100     format(/' * Error - (EQPT/rdpca) The aqueous species ',
     $    a,' appearing in',/7x,'the Pitzer ca parameter data block',
     $    ' for the species pair',/7x,a,', ',a,' does not appear',
     $    ' in an aqueous species',/7x,'data block.')
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n2 for na
c       unam2 for unams
c
      call gspidx(ier,n2,nat,natmax,uaqsp,unam2)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          write (noutpt,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for illegal appearance of solvent water.
c
      if (unam1(1:4).eq.'H2O ' .or. unam2(1:4).eq.'H2O ' .or.
     $  n1.eq.1 .or. n2.eq.1) then
        write (noutpt,1200) unam1(1:j2),unam2(1:j3)
        write (nttyo,1200) unam1(1:j2),unam2(1:j3)
 1200   format(/' * Error - (EQPT/rdpca) Have found an illegal',
     $  ' data block for the',/7x,'species pair ',a,', ',a,
     $  ' in the superblock of Pitzer data',/7x,'for ca pairs.',
     $  ' Solvent water may not appear in such a pair.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the electrical charges of the species.
c
      z1 = 0.
      z2 = 0.
      iz1 = 0
      iz2 = 0
      if (n1 .gt. 0) then
        z1 = zaqsp(n1)
        iz1 = nint(z1)
      endif
      if (n2 .gt. 0) then
        z2 = zaqsp(n2)
        iz2 = nint(z2)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.gt.0 .and. n2.gt.0) then
c
c       Make sure that the species pair is appropriate for the
c       current superblock. It must be of type ca. Other pair types
c       such as cc', aa', nc, na, nn, and nn' are not permitted here.
c
        if (.not.((iz1*iz2) .lt. 0)) then
c
c         The current data block is in the wrong superblock.
c
          write (noutpt,1230) unam1(1:j2),unam2(1:j3)
          write (nttyo,1230) unam1(1:j2),unam2(1:j3)
 1230     format(/' * Error - (EQPT/rdpca) Have found an',
     $    ' illegal data block for the',/7x,'species pair ',
     $    a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $    ' ca pairs. The present pair type',/7x,'may not appear',
     $    ' in the current superblock.')
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Species pair storage rules:
c
c       1. neutral < cation < anion
c
c       2. If both species are of the same charge type,
c          store alphabetically.
c
c     Here: the cation comes first.
c
      if (iz1 .gt .0) then
c
c       The first species is the cation.
c
        upair(1,npx2) = unam1
        upair(2,npx2) = unam2
      else
c
c       The second species is the cation.
c
        upair(1,npx2) = unam2
        upair(2,npx2) = unam1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the coefficients for the beta and Cphi parameters.
c
c     First peek ahead to see if alpha parameters are also specified
c     in the current data block.
c
      read (ndat0s,1000,end=990,err=995) uline
      backspace(ndat0s)
      j4 = ilnobl(uline)
      j4 = min(j4,70)
      ux80 = uline
      call lejust(ux80)
c
      if (ux80(1:4).ne.'beta' .and. ux80(1:5).ne.'alpha') then
        write (noutpt,1310) uline(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1310) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1310   format(/' * Error - (EQPT/rdpca) Have found a line',
     $  ' starting with:',/7x,'"',a,'"',/7x,'where an "alpha" or',
     $  ' "beta" header was expected in the block for',/7x,'the',
     $  ' species pair ',a,', ',a,' in the',/7x,'superblock of',
     $  ' Pitzer data for ca pairs.')
        nerr = nerr + 1
        go to 999
      endif
c
      if (ux80(1:4) .eq. 'beta') then
c
c       Have found data for the beta(n) parameters. The associated
c       alpha parameters are not specified. Assign standard alpha
c       values according the charge combination.
c
        call adalph(alpha,ipbtmx,iz1,iz2,npx2,npx2mx)
      else
c
c       The line did not contain a beta(n) parameter header.
c       Read optional values for the associated alpha parameters.
c       Note that a full set of alpha parameters must be specified
c       if any alpha data are present.
c
        do i = 1,ipbtmx
          read (ndat0s,1000,end=990,err=995) uline
          j4 = ilnobl(uline)
          j4 = min(j4,70)
          ux80 = uline
          call lejust(ux80)
          ustr16 = 'alpha( ) ='
          j5 = 10
          write (ustr16(7:7),'(i1)') i
          if (ux80(1:j5) .eq. ustr16(1:j5)) then
            udastr = ux80
            udastr(1:j5) = ' '
            call g1dat(ier,noutpt,nttyo,udastr,var)
            if (ier .gt. 0) then
              write (noutpt,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
              write (nttyo,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1320         format(/' * Error - (EQPT/rdpca) Have found a line',
     $        ' starting with:',/7x,'"',a,'"',/7x,'containing an',
     $        ' expected numerical field that could not be read.',
     $        /7x,'This occurred in the block for the species pair',
     $        /7x,a,', ',a,' in the superblock of Pitzer data',
     $        /7x,'for ca pairs.')
              nerr = nerr + 1
              go to 999
            endif
            alpha(i,npx2) = var
          else
            write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $      unam2(1:j3)
            write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $      unam2(1:j3)
 1330       format(/' * Error - (EQPT/rdpca) Have found a line',
     $      ' starting with:',/7x,'"',a,'"',/7x,'where "',a,'" was',
     $      ' expected in the block for the species',/7x,'pair ',
     $      a,', ',a,' in the superblock of Pitzer data',
     $      /7x,'for ca pairs.')
            nerr = nerr + 1
            go to 999
          endif
        enddo
      endif
c
c     Read the beta(n) data.
c
      do i = 0,ipbtmx
c
c       Check the required parameter header.
c
        read (ndat0s,1000,end=990,err=995) uline
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        ux80 = uline
        call lejust(ux80)
        ustr16 = 'beta( )'
        j5 = 7
        write (ustr16(6:6),'(i1)') i
        if (ux80(1:j5) .ne. ustr16(1:j5)) then
          write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          nerr = nerr + 1
          go to 999
        endif
c
c       Read the coefficients for the associated temperature function.
c
        do j = 1,jpfcmx
          read (ndat0s,1000,end=990,err=995) uline
          j4 = ilnobl(uline)
          j4 = min(j4,70)
          ux80 = uline
          call lejust(ux80)
          ustr16 = 'a  ='
          j5 = 4
          write (ustr16(2:2),'(i1)') j
          if (ux80(1:j5) .eq. ustr16(1:j5)) then
            udastr = ux80
            udastr(1:j5) = ' '
            call g1dat(ier,noutpt,nttyo,udastr,var)
            if (ier .gt. 0) then
              write (noutpt,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
              write (nttyo,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
              nerr = nerr + 1
              go to 999
            endif
            abeta(j,i,npx2) = var
          else
            write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $      unam2(1:j3)
            write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $      unam2(1:j3)
            nerr = nerr + 1
            go to 999
          endif
        enddo
      enddo
c
c     Now read the Cphi data.
c
c     Check the required parameter header.
c
      read (ndat0s,1000,end=990,err=995) uline
      j4 = ilnobl(uline)
      j4 = min(j4,70)
      ux80 = uline
      call lejust(ux80)
      ustr16 = 'Cphi'
      j5 = 4
      if (ux80(1:j5) .ne. ustr16(1:j5)) then
        write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
        write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
        nerr = nerr + 1
        go to 999
      endif
c
c     Read the coefficients for the associated temperature function.
c
      do j = 1,jpfcmx
        read (ndat0s,1000,end=990,err=995) uline
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        ux80 = uline
        call lejust(ux80)
        ustr16 = 'a  ='
        j5 = 4
        write (ustr16(2:2),'(i1)') j
        if (ux80(1:j5) .eq. ustr16(1:j5)) then
          udastr = ux80
          udastr(1:j5) = ' '
          call g1dat(ier,noutpt,nttyo,udastr,var)
          if (ier .gt. 0) then
            write (noutpt,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
            write (nttyo,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
            nerr = nerr + 1
            go to 999
          endif
          acphi(j,npx2) = var
        else
          write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          nerr = nerr + 1
          go to 999
        endif
      enddo
c
c     Skip past the block delimiter line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
      if (uline(1:8) .ne. uterm(1:8)) then
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        write (noutpt,1470) uline(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1470) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1470   format(/' * Error - (EQPT/rdpca) Have found a line starting',
     $  ' with:',/7x,'"',a,'"',/7x,' in the data block for the species',
     $  ' pair ',a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $  ' ca pairs. Should have found the',/7x,'delimiter line',
     $  ' marking the end of the block.')
        nerr = nerr + 1
        go to 999
      endif
c
c     Process the next data block.
c
      go to 110
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdpca) Unexpectedly encountered',
     $ /7x,'an end-of-file error while reading the ca superblock',
     $ /7x,'of the DATA0 file.')
      stop
c
  995 write (noutpt,2020)
      write (nttyo,2020)
 2020 format(/' * Error - (EQPT/rdpca) Encountered a read format',
     $ /7x,'error while reading the ca superblock of the',
     $ /7x,'DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rdpn2(abeta,acphi,ipbtmx,jpfcmx,nat,natmax,
     $ ndat0s,nerr,noutpt,npxn2,npx2mx,npx2t,nttyo,nwarn,
     $ uaqsp,upair,zaqsp)
c
c     This subroutine reads from the DATA1 file the coefficients
c     required to compute those Pitzer interaction parameters
c     associated with neutral-same neutral pairs (the pair
c     business is really a formalism maintained for consistency
c     with other parameter sets , as just the neutral n itself
c     is sufficient to identify the set). This particular
c     set of interaction coefficients includes the following:
c
c       1. lambda(nn), mu(nnn)
c
c     Coefficients required to compute Pitzer interaction coefficients
c     associated with other pair types or with triplets are not read
c     by this subroutine. This subroutine is one of several that
c     replace rdpz2.f and rdpz3.f.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c
c     Principal output:
c
c       abeta  = array of coefficients for computing beta parameters
c       acphi  = array of coefficients for computing Cphi parameters
c       nerr   = cumulative error counter
c       npxn2  = the number of nn pairs for which Pitzer parameters
c                  were read from the data file
c       npx2t  = the number of pairs of all species types for which
c                  Pitzer parameters were read from the data file.
c       nwarn  = cumulative warning counter
c       uaqsp  = array of names of aqueous species
c       upair  = array of species names for species pairs
c       uaqsp  = array of electrical charge numbers of aqueous species
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,npx2mx
c
      integer ndat0s,noutpt,nttyo
c
      integer nat,nerr,npxn2,npx2t,nwarn
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real(8) abeta(jpfcmx,0:ipbtmx,npx2mx),acphi(jpfcmx,npx2mx),
     $ zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer ier,iz1,iz2,j,j2,j3,j4,j5,j6,npx2,npx2te,n1,n2
c
      integer ilnobl
c
      character(len=80) udastr,uline,ux80
      character(len=24) unam1,unam2,ux24a,ux24b
      character(len=24) uhdn2,uhdnxt
      character(len=16) ustr16
      character(len=8) uterm,ux8
c
      real(8) var,z1,z2
c
c-----------------------------------------------------------------------
c
      data uterm  /'+-------'/
      data uhdn2  /"nn combinations: lambda("/
      data uhdnxt /"nn' combinations: lambda"/
c
c-----------------------------------------------------------------------
c
      npx2te = npx2t
      npx2 = npx2te
      j2 = 0
      j3 = 0
c
c     Advance to the start of the superblock for these parameters.
c
  100 read (ndat0s,1000,end=990,err=995) uline
 1000 format(a80)
      if (uline(1:24) .ne. uhdn2(1:24)) go to 100
c
c     Skip the terminator.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the names of the species comprising a pair.
c
  110 read (ndat0s,1010,end=990,err=995) unam1,unam2
 1010 format(a24,2x,a24)
c
      if (unam1(1:24) .eq. uhdnxt(1:24)) then
c
c       Found the header for the next superblock of Pitzer parameters.
c       Back up one line and terminate reading the current superblock.
c
        npxn2 = npx2 - npx2te
        npx2t = npx2
        backspace(ndat0s)
        go to 999
      endif
c
      npx2 = npx2 + 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Setup up some string data for error messages.
c
c     Note that for nn pairs, the species name need not be repeated.
c     If unam2 is blank, it is merely set to unam1.
c
      j2 = ilnobl(unam1)
      if (j2 .le. 0) then
        unam1 = '<blank>'
        j2 = ilnobl(unam1)
      endif
c
      j3 = ilnobl(unam2)
      if (j3 .le. 0) then
        unam2 = unam1
        j3 = j2
      endif
c
      write (ux8,'(i5)') npx2
      call lejust(ux8)
      j4 = ilnobl(ux8)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for blank names.
c
      if (j2.le.0 .or. j3.le.0) then
        write (noutpt,1020) ux8(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1020) ux8(1:j4),unam1(1:j2),unam2(1:j3)
 1020   format(/' * Error - (EQPT/rdpn2) Have encountered a blank',
     $  ' species name',/7x,'in the species pair for block ',a,
     $  ' of the superblock for',/7x,'Pitzer nn parameter data.',
     $  ' The offending pair shows as ',a,', ',a,'.')
c
        if (npx2 .gt. (npx2te + 1)) then
          ux24a = upair(1,npx2 - 1)
          ux24b = upair(2,npx2 - 1)
          if (ux24a(1:7).ne.'<blank>' .or.
     $      ux24b(1:7).ne.'<blank>') then
            j5 = ilnobl(ux24a)
            j6 = ilnobl(ux24b)
            write (noutpt,1030) ux24a(1:j5),ux24b(1:j6)
            write (nttyo,1030) ux24a(1:j5),ux24b(1:j6)
 1030       format(7x,'This block follows the one for ',a,
     $      ', ',a,'.')
          endif
        endif
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the indices of the two species (n1, n2). These
c     indices point to the data read from the previously
c     read species blocks.
c
c     Calling sequence substitutions:
c       n1 for na
c       unam1 for unams
c
      call gspidx(ier,n1,nat,natmax,uaqsp,unam1)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          write (noutpt,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
 1100     format(/' * Error - (EQPT/rdpn2) The aqueous species ',
     $    a,' appearing in',/7x,'the Pitzer nn parameter data block',
     $    ' for the species pair',/7x,a,', ',a,' does not appear',
     $    ' in an aqueous species',/7x,'data block.')
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n2 for na
c       unam2 for unams
c
      call gspidx(ier,n2,nat,natmax,uaqsp,unam2)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          write (noutpt,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for illegal appearance of solvent water.
c
      if (unam1(1:4).eq.'H2O ' .or. unam2(1:4).eq.'H2O ' .or.
     $  n1.eq.1 .or. n2.eq.1) then
        write (noutpt,1200) unam1(1:j2),unam2(1:j3)
        write (nttyo,1200) unam1(1:j2),unam2(1:j3)
 1200   format(/' * Error - (EQPT/rdpn2) Have found an illegal',
     $  ' data block for the',/7x,'species pair ',a,', ',a,
     $  ' in the superblock of Pitzer data',/7x,"for nn pairs.",
     $  ' Solvent water may not appear in such a pair.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the electrical charges of the species.
c
      z1 = 0.
      z2 = 0.
      iz1 = 0
      iz2 = 0
      if (n1 .gt. 0) then
        z1 = zaqsp(n1)
        iz1 = nint(z1)
      endif
      if (n2 .gt. 0) then
        z2 = zaqsp(n2)
        iz2 = nint(z2)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.gt.0 .and. n2.gt.0) then
c
c       Make sure that the species pair is appropriate for the
c       current superblock. It must be of type nn. Other pair
c       pair types such as ca, cc', aa', nc, na, and nn' are not
c       permitted here.
c
        if (n1.ne.n2 .or. iz1.ne.0 .or. iz2.ne.0) then
c
c         The current data block is in the wrong superblock.
c
          write (noutpt,1230) unam1(1:j2),unam2(1:j3)
          write (nttyo,1230) unam1(1:j2),unam2(1:j3)
 1230     format(/' * Error - (EQPT/rdpn2) Have found an',
     $    ' illegal data block for the',/7x,'species pair ',
     $    a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $    " nn pairs.",/7x,'The present pair type',
     $    ' may not appear in the current superblock.')
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Species pair storage rules:
c
c       1. neutral < cation < anion
c
c       2. If both species are of the same charge type,
c          store alphabetically.
c
c     Here: just one species in the pair.
c
      upair(1,npx2) = unam1
      upair(2,npx2) = unam1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the coefficients for the lambda(nn) parameters.
c     Store the lambda data as beta(0) data.
c
c     Check the required parameter header.
c
      read (ndat0s,1000,end=990,err=995) uline
      j4 = ilnobl(uline)
      j4 = min(j4,70)
      ux80 = uline
      call lejust(ux80)
      ustr16 = 'lambda'
      j5 = 6
      if (ux80(1:j5) .ne. ustr16(1:j5)) then
        write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
        write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
 1330   format(/' * Error - (EQPT/rdpn2) Have found a line',
     $  ' starting with:',/7x,'"',a,'"',/7x,'where "',a,'" was',
     $  ' expected in the block for the species',/7x,'pair ',
     $  a,', ',a,' in the superblock of Pitzer data',
     $  /7x,"for nn pairs.")
        nerr = nerr + 1
        go to 999
      endif
c
c     Read the coefficients for the associated temperature function.
c
      do j = 1,jpfcmx
        read (ndat0s,1000,end=990,err=995) uline
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        ux80 = uline
        call lejust(ux80)
        ustr16 = 'a  ='
        j5 = 4
        write (ustr16(2:2),'(i1)') j
        if (ux80(1:j5) .eq. ustr16(1:j5)) then
          udastr = ux80
          udastr(1:j5) = ' '
          call g1dat(ier,noutpt,nttyo,udastr,var)
          if (ier .gt. 0) then
            write (noutpt,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
            write (nttyo,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1320       format(/' * Error - (EQPT/rdpn2) Have found a line',
     $      ' starting with:',/7x,'"',a,'"',/7x,'containing an',
     $      ' expected numerical field that could not be read.',
     $      /7x,'This occurred in the block for the species pair',
     $      /7x,a,', ',a,' in the superblock of Pitzer data',
     $      /7x,"for nn pairs.")
            nerr = nerr + 1
            go to 999
          endif
          abeta(j,0,npx2) = var
        else
          write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          nerr = nerr + 1
          go to 999
        endif
      enddo
c
c     Now read the mu data. Store the mu data as Cphi data.
c
c     Check the required parameter header.
c
      read (ndat0s,1000,end=990,err=995) uline
      j4 = ilnobl(uline)
      j4 = min(j4,70)
      ux80 = uline
      call lejust(ux80)
      ustr16 = 'mu'
      j5 = 2
      if (ux80(1:j5) .ne. ustr16(1:j5)) then
        write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
        write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
        nerr = nerr + 1
        go to 999
      endif
c
c     Read the coefficients for the associated temperature function.
c
      do j = 1,jpfcmx
        read (ndat0s,1000,end=990,err=995) uline
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        ux80 = uline
        call lejust(ux80)
        ustr16 = 'a  ='
        j5 = 4
        write (ustr16(2:2),'(i1)') j
        if (ux80(1:j5) .eq. ustr16(1:j5)) then
          udastr = ux80
          udastr(1:j5) = ' '
          call g1dat(ier,noutpt,nttyo,udastr,var)
          if (ier .gt. 0) then
            write (noutpt,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
            write (nttyo,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
            nerr = nerr + 1
            go to 999
          endif
          acphi(j,npx2) = var
        else
          write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          nerr = nerr + 1
          go to 999
        endif
      enddo
c
c     Skip past the block delimiter line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
      if (uline(1:8) .ne. uterm(1:8)) then
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        write (noutpt,1470) uline(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1470) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1470   format(/' * Error - (EQPT/rdpn2) Have found a line starting',
     $  ' with:',/7x,'"',a,'"',/7x,' in the data block for the species',
     $  ' pair ',a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $  " nn pairs. Should have",/7x,'found the delimiter line',
     $  ' marking the end of the block.')
        nerr = nerr + 1
        go to 999
      endif
c
c     Process the next data block.
c
      go to 110
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdpn2) Unexpectedly encountered',
     $ /7x,"an end-of-file error while reading the nn (lambda, mu)",
     $ /7x,'superblock of the DATA0 file.')
      stop
c
  995 write (noutpt,2020)
      write (nttyo,2020)
 2020 format(/' * Error - (EQPT/rdpn2) Encountered a read format',
     $ /7x,"error while reading the nn (lambda, mu) superblock",
     $ /7x,'of the DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rdpn2n(apsi,jpfcmx,nat,natmax,ndat0s,nerr,noutpt,
     $ npxn2n,npx3mx,npx3t,nttyo,nwarn,uaqsp,utripl,zaqsp)
c
c     This subroutine reads from the DATA1 file the coefficients
c     required to compute those Pitzer interaction parameters
c     associated with neutral-neutral-different neutral (nnn')
c     triplets. This particular set of interaction coefficients
c     includes the following:
c
c       1. mu(nnn')
c
c     Note that to have both mu(nnn') and mu(n'n'n), there must
c     be a data block for each of the nnn' and n'n'n combinations.
c
c     Coefficients required to compute Pitzer interaction coefficients
c     associated with other triplet types or with pairs are not read
c     by this subroutine. This subroutine is one of several that
c     replace rdpz2.f and rdpz3.f.
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c
c     Principal output:
c
c       apsi   = array of coefficients for computing psi parameters
c       nerr   = cumulative error counter
c       npxn2n = the number of nnn' triplets for which Pitzer
c                 parameters were read from the data file
c       npx3t  = the number of triplets of all species types for which
c                  Pitzer parameters were read from the data file.
c       nwarn  = cumulative warning counter
c       uaqsp  = array of names of aqueous species
c       utripl = array of species names for species triplets
c       uaqsp  = array of electrical charge numbers of aqueous species
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer jpfcmx,natmax,npx3mx
c
      integer ndat0s,noutpt,nttyo
c
      integer nat,nerr,npxn2n,npx3t,nwarn
c
      character(len=24) uaqsp(natmax),utripl(3,npx3mx)
c
      real(8) apsi(jpfcmx,npx3mx),zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer ier,iz1,iz2,iz3,j,j2,j3,j4,j5,j6,j7,j8,j9,
     $ na,nc,nn,npx3,npx3te,n1,n2,n3
c
      integer ilnobl
c
      logical qdupan,qdup1p,qdup12,qdup13,qdup23
c
      character(len=80) udastr,uline,ux80
      character(len=24) unam1,unam2,unam3,ux24a,ux24b,ux24c,u1,u2,u3
      character(len=24) uhdn2n,uhdnxt
      character(len=16) ustr16
      character(len=8) uterm,ux8
c
      real(8) var,z1,z2,z3
c
c-----------------------------------------------------------------------
c
      data uterm  /'+-------'/
      data uhdn2n /"nnn' combinations: mu(nn"/
      data uhdnxt /"elements                "/
c
c-----------------------------------------------------------------------
c
      npx3te = npx3t
      npx3 = npx3te
      j2 = 0
      j3 = 0
      j4 = 0
c
c     Advance to the start of the superblock for these parameters.
c
  100 read (ndat0s,1000,end=990,err=995) uline
 1000 format(a80)
      if (uline(1:24) .ne. uhdn2n(1:24)) go to 100
c
c     Skip the terminator.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the names of the species comprising a triplet.
c
  110 read (ndat0s,1010,end=990,err=995) unam1,unam2,unam3
 1010 format(a24,2x,a24,2x,a24)
c
      if (unam1(1:24) .eq. uhdnxt(1:24)) then
c
c       Found the header for the next superblock of Pitzer parameters.
c       Back up one line and terminate reading the current superblock.
c
        npxn2n = npx3 - npx3te
        npx3t = npx3
        backspace(ndat0s)
        go to 999
      endif
c
      npx3 = npx3 + 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Setup up some string data for error messages.
c
      j2 = ilnobl(unam1)
      if (j2 .le. 0) then
        unam1 = '<blank>'
        j2 = ilnobl(unam1)
      endif
c
      j3 = ilnobl(unam2)
      if (j3 .le. 0) then
        unam2 = '<blank>'
        j3 = ilnobl(unam2)
      endif
c
      j4 = ilnobl(unam3)
      if (j4 .le. 0) then
        unam3 = '<blank>'
        j4 = ilnobl(unam3)
      endif
c
      write (ux8,'(i5)') npx3
      call lejust(ux8)
      j5 = ilnobl(ux8)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for blank names.
c
      if (j2.le.0 .or. j3.le.0 .or. j4.le.0) then
        write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j3)
        write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j3)
 1020   format(/' * Error - (EQPT/rdpn2n) Have encountered a blank',
     $  ' species name',/7x,'in the species triplet for block ',a,
     $  ' of the superblock for',/7x,"Pitzer nnn' parameter data.",
     $  ' The offending triplet shows as',/7x,a,', ',a,', ',a,'.')
c
        if (npx3 .gt. (npx3te + 1)) then
          ux24a = utripl(1,npx3 - 1)
          ux24b = utripl(2,npx3 - 1)
          ux24c = utripl(3,npx3 - 1)
          if (ux24a(1:7).ne.'<blank>' .or.
     $      ux24b(1:7).ne.'<blank>' .or. ux24c(1:7).ne.'<blank>') then
            j7 = ilnobl(ux24a)
            j8 = ilnobl(ux24b)
            j9 = ilnobl(ux24c)
            write (noutpt,1030) ux24a(1:j7),ux24b(1:j8),ux24c(1:j9)
            write (nttyo,1030) ux24a(1:j7),ux24b(1:j8),ux24c(1:j9)
 1030       format(7x,'This block follows the one for ',a,
     $      ', ',a,', ',a,'.')
          endif
        endif
        nerr = nerr + 1
      endif
c
cXXXXXXXXX
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the indices of the three species (n1, n2, n3). These
c     indices point to the data read from the previously read
c     species blocks.
c
c     Calling sequence substitutions:
c       n1 for na
c       unam1 for unams
c
      call gspidx(ier,n1,nat,natmax,uaqsp,unam1)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
          write (noutpt,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          write (nttyo,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
 1100     format(/' * Error - (EQPT/rdpn2n) The aqueous species ',
     $    a,' appearing in',/7x,"the Pitzer nnn' parameter data",
     $    ' block for the species triplet',/7x,a,', ',a,', ',a,
     $    ' does not appear in an',/7x,'aqueous species data block.')
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n2 for na
c       unam2 for unams
c
      call gspidx(ier,n2,nat,natmax,uaqsp,unam2)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
          write (noutpt,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          write (nttyo,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n3 for na
c       unam3 for unams
c
      call gspidx(ier,n3,nat,natmax,uaqsp,unam3)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
          write (noutpt,1100) unam3(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          write (nttyo,1100) unam3(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for illegal appearance of solvent water.
c
      if (unam1(1:4) .eq.'H2O ' .or. unam2(1:4) .eq.'H2O ' .or.
     $  unam3(1:4).eq.'H2O ' .or. n1.eq.1 .or. n2.eq.1 .or.
     $  n3.eq.1) then
        write (noutpt,1200) unam1(1:j2),unam2(1:j3),unam3(1:j4)
        write (nttyo,1200) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1200   format(/' * Error - (EQPT/rdpn2n) Have found an illegal data',
     $  ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $  ' in the superblock',/7x,"of Pitzer data for nnn' triplets.",
     $  ' Solvent water may not',/7x,'appear in such a triplet.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the electrical charges of the species.
c
      z1 = 0.
      z2 = 0.
      z3 = 0.
      iz1 = 0
      iz2 = 0
      iz3 = 0
      if (n1 .gt. 0) then
        z1 = zaqsp(n1)
        iz1 = nint(z1)
      endif
      if (n2 .gt. 0) then
        z2 = zaqsp(n2)
        iz2 = nint(z2)
      endif
      if (n3 .gt. 0) then
        z3 = zaqsp(n3)
        iz3 = nint(z3)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.ne.0 .and. n2.ne.0 .and. n3.ne.0) then
c
c       Make sure that the species triplet is appropriate for the
c       current superblock. It must be of type nnn'. Other triplet
c       types such as cc'a, aa'c, nnn, nnn', and nn'n' are not
c       permitted here.
c
c       Count the neutral species.
c
        nn = 0
        if (iz1 .eq. 0) nn = 1
        if (iz2 .eq. 0) nn = nn + 1
        if (iz3 .eq. 0) nn = nn + 1
c
c       Count the cations.
c
        nc = 0
        if (iz1 .gt. 0) nc = 1
        if (iz2 .gt. 0) nc = nc + 1
        if (iz3 .gt. 0) nc = nc + 1
c
c       Count the anions.
c
        na = 0
        if (iz1 .lt. 0) na = 1
        if (iz2 .lt. 0) na = na + 1
        if (iz3 .lt. 0) na = na + 1
c
c       Check for duplications.
c
        qdup12 = unam1(1:24) .eq. unam2(1:24)
        qdup13 = unam1(1:24) .eq. unam3(1:24)
        qdup23 = unam2(1:24) .eq. unam3(1:24)
        qdupan = qdup12 .or. qdup23 .or. qdup13
        qdup1p = (qdup12 .and. .not.qdup23 .and. .not.qdup13)
     $  .or. (qdup23 .and. .not.qdup12 .and. .not.qdup13)
     $  .or. (qdup13 .and. .not.qdup23 .and. .not.qdup12)
c
        if (nc.eq.3 .or. na.eq.3
     $    .or. (nc.eq.2 .and. nn.eq.1)
     $    .or. (na.eq.2 .and. nn.eq.1)
     $    .or. (nn.eq.2 .and. nc.eq.1)
     $    .or. (nn.eq.2 .and. na.eq.1)
     $    .or. (nc.eq.2 .and. na.eq.1 .and. qdupan)
     $    .or. (na.eq.2 .and. nc.eq.1 .and. qdupan)) then
c
c         The current data block refers to a triplet combination
c         that is not valid in the Pitzer framework.
c
          write (noutpt,1220) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1220) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1220     format(/' * Error - (EQPT/rdpn2n Have found an',
     $    ' illegal data block for the',/7x,'species triplet ',
     $    a,', ',a,', ',a,' in the',/7x,'superblock of Pitzer',
     $    " data for nnn' triplets.",/7x,'The present triplet',
     $    ' type is not valid in the Pitzer framework.')
          nerr = nerr + 1
        elseif (.not.(nn.eq.3 .and. qdup1p)) then
c
c         The current data block is in the wrong superblock.
c
          write (noutpt,1230) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1230) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1230     format(/' * Error - (EQPT/rdpn2n Have found an',
     $    ' illegal data block for the',/7x,'species triplet ',
     $    a,', ',a,', ',a,' in the',/7x,'superblock of Pitzer',
     $    " data nnn' triplets. The present",/7x,'triplet type',
     $    ' may not appear in the current superblock.')
          nerr = nerr + 1
        endif
c
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Species triplet storage rules:
c
c       nnn : neutral, neutral, neutral
c       nnn': neutral 1, neutral1, neutral 2
c       nca : neutral, cation, anion
c       cc'a: cation 1, cation 2, anion
c       aa'c: anion 1, anion 2, cation
c
c       A duplicated species appears first.
c
c       Otherwise, if two species are of the same charge type,
c       store alphabetically.
c
c     Here: neutral, cation, anion.
c
c     Copy the names before rearranging for storage.
c
      u1 = unam1
      u2 = unam2
      u3 = unam3
c
c     Rearrange according to the storage rules. Note that
c     n1, n2, n3, z1, z2, z3, iz1, iz2, iz3 are all changed
c     in addtion to u1, u2, u3. Note that unam1, unam2, and
c     unam3 are not changed.
c
      call artrip(iz1,iz2,iz3,na,nc,nn,n1,n2,n3,
     $ u1,u2,u3,z1,z2,z3)
c
c     Store the triplet names in the order required by the
c     storage rules. The triplet in the original order is
c     preserved in unam1, unam2, unam3 for use in error messages
c     and such.
c
      utripl(1,npx3) = u1
      utripl(2,npx3) = u2
      utripl(3,npx3) = u3
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the coefficients for the mu(nnn') parameters. Store the
c     mu data as psi data.
c
c     Check the required parameter header.
c
      read (ndat0s,1000,end=990,err=995) uline
      j5 = ilnobl(uline)
      j5 = min(j5,70)
      ux80 = uline
      call lejust(ux80)
      ustr16 = 'mu'
      j6 = 2
      if (ux80(1:j6) .ne. ustr16(1:j6)) then
        write (noutpt,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $  unam2(1:j3),unam3(1:j4)
        write (nttyo,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $  unam2(1:j3),unam3(1:j4)
 1330   format(/' * Error - (EQPT/rdpn2n) Have found a line',
     $  ' starting with:',/7x,'"',a,'"',/7x,'where "',a,'" was',
     $  ' expected in the block for the species',/7x,'triplet ',
     $  a,', ',a,', ',a,' in the superblock of Pitzer data',
     $  /7x,"for nnn' triplets.")
        nerr = nerr + 1
        go to 999
      endif
c
c     Read the coefficients for the associated temperature function.
c
      do j = 1,jpfcmx
        read (ndat0s,1000,end=990,err=995) uline
        j5 = ilnobl(uline)
        j5 = min(j5,70)
        ux80 = uline
        call lejust(ux80)
        ustr16 = 'a  ='
        j6 = 4
        write (ustr16(2:2),'(i1)') j
        if (ux80(1:j6) .eq. ustr16(1:j6)) then
          udastr = ux80
          udastr(1:j6) = ' '
          call g1dat(ier,noutpt,nttyo,udastr,var)
          if (ier .gt. 0) then
            write (noutpt,1320) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $      unam3(1:j4)
            write (nttyo,1320) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $      unam3(1:j4)
 1320       format(/' * Error - (EQPT/rdpn2n) Have found a line',
     $      ' starting with:',/7x,'"',a,'"',/7x,'containing an',
     $      ' expected numerical field that could not be read.',
     $      /7x,'This occurred in the block for the species triplet',
     $      /7x,a,', ',a,', ',a,' in the superblock of Pitzer data',
     $      /7x,"for nnn' triplets.")
            nerr = nerr + 1
            go to 999
          endif
          apsi(j,npx3) = var
        else
          write (noutpt,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $    unam2(1:j3),unam3(1:j4)
          write (nttyo,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $    unam2(1:j3),unam3(1:j4)
          nerr = nerr + 1
          go to 999
        endif
      enddo
c
c     Skip past the block delimiter line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
      if (uline(1:8) .ne. uterm(1:8)) then
        j5 = ilnobl(uline)
        j5 = min(j5,70)
        write (noutpt,1470) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j4)
        write (nttyo,1470) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j4)
 1470   format(/' * Error - (EQPT/rdpn2n) Have found a line starting',
     $  ' with:',/7x,'"',a,'"',/7x,' in the data block for the species',
     $  ' triplet ',a,', ',a,', ',a,/7x,'in the superblock of',
     $  " Pitzer data for nnn' triplets. Should have",
     $  /7x,'found the delimiter line marking the end of the block.')
        nerr = nerr + 1
        go to 999
      endif
c
c     Process the next data block.
c
      go to 110
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdpn2n) Unexpectedly encountered',
     $ /7x,"an end-of-file error while reading the nnn' (mu)",
     $ /7x,'superblock of the DATA0 file.')
      stop
c
  995 write (noutpt,2020)
      write (nttyo,2020)
 2020 format(/' * Error - (EQPT/rdpn2n) Encountered a read format',
     $ /7x,"error while reading the nnn' (mu) superblock of",
     $ /7x,'the DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
c
      end
      subroutine rdpni(abeta,ipbtmx,jpfcmx,nat,natmax,ndat0s,nerr,
     $ noutpt,npxni,npx2mx,npx2t,nttyo,nwarn,uaqsp,upair,zaqsp)
c
c     This subroutine reads from the DATA1 file the coefficients
c     required to compute those Pitzer interaction parameters
c     associated with neutral-cation (nc) and neutral-anion (na)
c     pairs. This particular set of interaction coefficients
c     includes the following:
c
c       1. lambda(nc), lambda(na)
c
c     Coefficients required to compute Pitzer interaction coefficients
c     associated with other pair types or with triplets are not read
c     by this subroutine. This subroutine is one of several that
c     replace rdpz2.f and rdpz3.f.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c
c     Principal output:
c
c       abeta  = array of coefficients for computing beta parameters
c       nerr   = cumulative error counter
c       npxni  = the number of nc and na pairs for which Pitzer
c                  parameters were read from the data file
c       npx2t  = the number of pairs of all species types for which
c                  Pitzer parameters were read from the data file.
c       nwarn  = cumulative warning counter
c       uaqsp  = array of names of aqueous species
c       upair  = array of species names for species pairs
c       uaqsp  = array of electrical charge numbers of aqueous species
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,npx2mx
c
      integer ndat0s,noutpt,nttyo
c
      integer nat,nerr,npxni,npx2t,nwarn
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real(8) abeta(jpfcmx,0:ipbtmx,npx2mx),zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer ier,iz1,iz2,j,j2,j3,j4,j5,j6,npx2,npx2te,n1,n2
c
      integer ilnobl
c
      character(len=80) udastr,uline,ux80
      character(len=24) unam1,unam2,ux24a,ux24b
      character(len=24) uhdni,uhdnxt
      character(len=16) ustr16
      character(len=8) uterm,ux8
c
      real(8) var,z1,z2
c
c-----------------------------------------------------------------------
c
      data uterm  /'+-------'/
      data uhdni  /"nc and na combinations: "/
      data uhdnxt /"nn combinations: lambda("/
c
c-----------------------------------------------------------------------
c
      npx2te = npx2t
      npx2 = npx2te
      j2 = 0
      j3 = 0
c
c     Advance to the start of the superblock for these parameters.
c
  100 read (ndat0s,1000,end=990,err=995) uline
 1000 format(a80)
      if (uline(1:24) .ne. uhdni(1:24)) go to 100
c
c     Skip the terminator.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the names of the species comprising a pair.
c
  110 read (ndat0s,1010,end=990,err=995) unam1,unam2
 1010 format(a24,2x,a24)
c
      if (unam1(1:24) .eq. uhdnxt(1:24)) then
c
c       Found the header for the next superblock of Pitzer parameters.
c       Back up one line and terminate reading the current superblock.
c
        npxni = npx2 - npx2t
        npx2t = npx2
        backspace(ndat0s)
        go to 999
      endif
c
      npx2 = npx2 + 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Setup up some string data for error messages.
c
      j2 = ilnobl(unam1)
      if (j2 .le. 0) then
        unam1 = '<blank>'
        j2 = ilnobl(unam1)
      endif
c
      j3 = ilnobl(unam2)
      if (j3 .le. 0) then
        unam2 = '<blank>'
        j3 = ilnobl(unam2)
      endif
c
      write (ux8,'(i5)') npx2
      call lejust(ux8)
      j4 = ilnobl(ux8)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for blank names.
c
      if (j2.le.0 .or. j3.le.0) then
        write (noutpt,1020) ux8(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1020) ux8(1:j4),unam1(1:j2),unam2(1:j3)
 1020   format(/' * Error - (EQPT/rdpni) Have encountered a blank',
     $  ' species name',/7x,'in the species pair for block ',a,
     $  ' of the superblock for',/7x,'Pitzer nc and na parameter data.',
     $  ' The offending pair shows as ',a,', ',a,'.')
c
        if (npx2 .gt. (npx2te + 1)) then
          ux24a = upair(1,npx2 - 1)
          ux24b = upair(2,npx2 - 1)
          if (ux24a(1:7).ne.'<blank>' .or.
     $      ux24b(1:7).ne.'<blank>') then
            j5 = ilnobl(ux24a)
            j6 = ilnobl(ux24b)
            write (noutpt,1030) ux24a(1:j5),ux24b(1:j6)
            write (nttyo,1030) ux24a(1:j5),ux24b(1:j6)
 1030       format(7x,'This block follows the one for ',a,
     $      ', ',a,'.')
          endif
        endif
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the indices of the two species (n1, n2). These
c     indices point to the data read from the previously
c     read species blocks.
c
c     Calling sequence substitutions:
c       n1 for na
c       unam1 for unams
c
      call gspidx(ier,n1,nat,natmax,uaqsp,unam1)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          write (noutpt,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
 1100     format(/' * Error - (EQPT/rdpni) The aqueous species ',
     $    a,' appearing in',/7x,'the Pitzer nc and na parameter data',
     $    ' block for the species pair',/7x,a,', ',a,' does not',
     $    ' appear in an aqueous species',/7x,'data block.')
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n2 for na
c       unam2 for unams
c
      call gspidx(ier,n2,nat,natmax,uaqsp,unam2)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          write (noutpt,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for illegal appearance of solvent water.
c
      if (unam1(1:4).eq.'H2O ' .or. unam2(1:4).eq.'H2O ' .or.
     $  n1.eq.1 .or. n2.eq.1) then
        write (noutpt,1200) unam1(1:j2),unam2(1:j3)
        write (nttyo,1200) unam1(1:j2),unam2(1:j3)
 1200   format(/' * Error - (EQPT/rdpni) Have found an illegal',
     $  ' data block for the',/7x,'species pair ',a,', ',a,
     $  ' in the superblock of Pitzer data',/7x,"for nc and na",
     $  ' pairs. Solvent water may not appear in such a pair.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the electrical charges of the species.
c
      z1 = 0.
      z2 = 0.
      iz1 = 0
      iz2 = 0
      if (n1 .gt. 0) then
        z1 = zaqsp(n1)
        iz1 = nint(z1)
      endif
      if (n2 .gt. 0) then
        z2 = zaqsp(n2)
        iz2 = nint(z2)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.gt.0 .and. n2.gt.0) then
c
c       Make sure that the species pair is appropriate for the
c       current superblock. It must be of type nc or na. Other
c       pair types such as ca, cc', aa', nn, and nn' are not
c       permitted here.
c
        if ((iz1.eq.0 .and. iz2.eq.0) .or.
     $    (iz1.ne.0 .and. iz2.ne.0)) then
c
c         The current data block is in the wrong superblock.
c
          write (noutpt,1230) unam1(1:j2),unam2(1:j3)
          write (nttyo,1230) unam1(1:j2),unam2(1:j3)
 1230     format(/' * Error - (EQPT/rdpni) Have found an',
     $    ' illegal data block for the',/7x,'species pair ',
     $    a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $    " nc and na pairs.",/7x,'The present pair',
     $    ' type may not appear in the current superblock.')
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Species pair storage rules:
c
c       1. neutral < cation < anion
c
c       2. If both species are of the same charge type,
c          store alphabetically.
c
c     Here: the neutral comes first.
c
      if (iz1 .eq. 0) then
c
c       The first species is the neutral.
c
        upair(1,npx2) = unam1
        upair(2,npx2) = unam2
      else
c
c       The second species is the neutral.
c
        upair(1,npx2) = unam2
        upair(2,npx2) = unam1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the coefficients for the lambda(nc) and lambda(na)
c     parameters. Store the lambda data as beta(0) data.
c
c     Check the required parameter header.
c
      read (ndat0s,1000,end=990,err=995) uline
      j4 = ilnobl(uline)
      j4 = min(j4,70)
      ux80 = uline
      call lejust(ux80)
      ustr16 = 'lambda'
      j5 = 6
      if (ux80(1:j5) .ne. ustr16(1:j5)) then
        write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
        write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
 1330   format(/' * Error - (EQPT/rdpni) Have found a line',
     $  ' starting with:',/7x,'"',a,'"',/7x,'where "',a,'" was',
     $  ' expected in the block for the species',/7x,'pair ',
     $  a,', ',a,' in the superblock of Pitzer data',
     $  /7x,"for nc and na pairs.")
        nerr = nerr + 1
        go to 999
      endif
c
c     Read the coefficients for the associated temperature function.
c
      do j = 1,jpfcmx
        read (ndat0s,1000,end=990,err=995) uline
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        ux80 = uline
        call lejust(ux80)
        ustr16 = 'a  ='
        j5 = 4
        write (ustr16(2:2),'(i1)') j
        if (ux80(1:j5) .eq. ustr16(1:j5)) then
          udastr = ux80
          udastr(1:j5) = ' '
          call g1dat(ier,noutpt,nttyo,udastr,var)
          if (ier .gt. 0) then
            write (noutpt,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
            write (nttyo,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1320       format(/' * Error - (EQPT/rdpni) Have found a line',
     $      ' starting with:',/7x,'"',a,'"',/7x,'containing an',
     $      ' expected numerical field that could not be read.',
     $      /7x,'This occurred in the block for the species pair',
     $      /7x,a,', ',a,' in the superblock of Pitzer data',
     $      /7x,"for nc and na pairs.")
            nerr = nerr + 1
            go to 999
          endif
          abeta(j,0,npx2) = var
        else
          write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          nerr = nerr + 1
          go to 999
        endif
      enddo
c
c     Skip past the block delimiter line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
      if (uline(1:8) .ne. uterm(1:8)) then
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        write (noutpt,1470) uline(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1470) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1470   format(/' * Error - (EQPT/rdpni) Have found a line starting',
     $  ' with:',/7x,'"',a,'"',/7x,' in the data block for the species',
     $  ' pair ',a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $  " nc and na pairs. Should have",/7x,'found the',
     $  ' delimiter line marking the end of the block.')
        nerr = nerr + 1
        go to 999
      endif
c
c     Process the next data block.
c
      go to 110
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdpni) Unexpectedly encountered',
     $ /7x,"an end-of-file error while reading the nc and na",
     $ /7x,'(lambda) superblock of the DATA0 file.')
      stop
c
  995 write (noutpt,2020)
      write (nttyo,2020)
 2020 format(/' * Error - (EQPT/rdpni) Encountered a read format',
     $ /7x,"error while reading the nc and na (lambda) superblock",
     $ /7x,'of the DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rdpnn(abeta,ipbtmx,jpfcmx,nat,natmax,ndat0s,nerr,
     $ noutpt,npxnn,npx2mx,npx2t,nttyo,nwarn,uaqsp,upair,zaqsp)
c
c     This subroutine reads from the DATA1 file the coefficients
c     required to compute those Pitzer interaction parameters
c     associated with neutral-different neutral (nn) pairs. This
c     particular set of interaction coefficients includes the
c     following:
c
c       1. lambda(nn')
c
c     Although mu(nnn') and mu(nn'n') are closely related to
c     lambda(nn'), they are not read from the current superblock
c     by this subroutine, but from a triplets superblock read by
c     another subroutine, rdpn2n.f. There are several reasons for
c     this treatment. First, the relevant type of mu here is more
c     analogous to a psi parameter than a Cphi parameter. Note that
c     mu(nnn) is included with lambda(nn) in part because mu(nnn)
c     is analogous to a Cphi parameter. Second, data for the current
c     type of mu is both scarce and not very likely to be needed
c     in most applications.
c
c     Coefficients required to compute Pitzer interaction coefficients
c     associated with other pair types or with triplets are not read
c     by this subroutine. This subroutine is one of several that
c     replace rdpz2.f and rdpz3.f.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c
c     Principal output:
c
c       abeta  = array of coefficients for computing beta parameters
c       nerr   = cumulative error counter
c       npxnn  = the number of nn pairs for which Pitzer parameters
c                  were read from the data file
c       npx2t  = the number of pairs of all species types for which
c                  Pitzer parameters were read from the data file
c       nwarn  = cumulative warning counter
c       uaqsp  = array of names of aqueous species
c       upair  = array of species names for species pairs
c       uaqsp  = array of electrical charge numbers of aqueous species
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,npx2mx
c
      integer ndat0s,noutpt,nttyo
c
      integer nat,nerr,npxnn,npx2t,nwarn
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real(8) abeta(jpfcmx,0:ipbtmx,npx2mx),zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer ier,iz1,iz2,j,j2,j3,j4,j5,j6,npx2,npx2te,n1,n2
c
      integer ilnobl
c
      character(len=80) udastr,uline,ux80
      character(len=24) unam1,unam2,ux24a,ux24b
      character(len=24) uhdnn,uhdnxt
      character(len=16) ustr16
      character(len=8) uterm,ux8
c
      real(8) var,z1,z2
c
c-----------------------------------------------------------------------
c
      data uterm  /'+-------'/
      data uhdnn  /"nn' combinations: lambda"/
      data uhdnxt /"cc'a and aa'c combinatio"/
c
c-----------------------------------------------------------------------
c
      npx2te = npx2t
      npx2 = npx2te
      j2 = 0
      j3 = 0
c
c     Advance to the start of the superblock for these parameters.
c
  100 read (ndat0s,1000,end=990,err=995) uline
 1000 format(a80)
      if (uline(1:24) .ne. uhdnn(1:24)) go to 100
c
c     Skip the terminator.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the names of the species comprising a pair.
c
  110 read (ndat0s,1010,end=990,err=995) unam1,unam2
 1010 format(a24,2x,a24)
c
      if (unam1(1:24) .eq. uhdnxt(1:24)) then
c
c       Found the header for the next superblock of Pitzer parameters.
c       Back up one line and terminate reading the current superblock.
c
        npxnn = npx2 - npx2te
        npx2t = npx2
        backspace(ndat0s)
        go to 999
      endif
c
      npx2 = npx2 + 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Setup up some string data for error messages.
c
      j2 = ilnobl(unam1)
      if (j2 .le. 0) then
        unam1 = '<blank>'
        j2 = ilnobl(unam1)
      endif
c
      j3 = ilnobl(unam2)
      if (j3 .le. 0) then
        unam2 = '<blank>'
        j3 = ilnobl(unam2)
      endif
c
      write (ux8,'(i5)') npx2
      call lejust(ux8)
      j4 = ilnobl(ux8)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for blank names.
c
      if (j2.le.0 .or. j3.le.0) then
        write (noutpt,1020) ux8(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1020) ux8(1:j4),unam1(1:j2),unam2(1:j3)
 1020   format(/' * Error - (EQPT/rdpnn) Have encountered a blank',
     $  ' species name',/7x,'in the species pair for block ',a,
     $  ' of the superblock for',/7x,"Pitzer nn' parameter data.",
     $  ' The offending pair shows as ',a,', ',a,'.')
c
        if (npx2 .gt. (npx2te + 1)) then
          ux24a = upair(1,npx2 - 1)
          ux24b = upair(2,npx2 - 1)
          if (ux24a(1:7).ne.'<blank>' .or.
     $      ux24b(1:7).ne.'<blank>') then
            j5 = ilnobl(ux24a)
            j6 = ilnobl(ux24b)
            write (noutpt,1030) ux24a(1:j5),ux24b(1:j6)
            write (nttyo,1030) ux24a(1:j5),ux24b(1:j6)
 1030       format(7x,'This block follows the one for ',a,
     $      ', ',a,'.')
          endif
        endif
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the indices of the two species (n1, n2). These
c     indices point to the data read from the previously
c     read species blocks.
c
c     Calling sequence substitutions:
c       n1 for na
c       unam1 for unams
c
      call gspidx(ier,n1,nat,natmax,uaqsp,unam1)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          write (noutpt,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
 1100     format(/' * Error - (EQPT/rdpnn) The aqueous species ',
     $    a,' appearing in',/7x,"the Pitzer nn' parameter data block",
     $    ' for the species pair',/7x,a,', ',a,' does not appear',
     $    ' in an aqueous species',/7x,'data block.')
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n2 for na
c       unam2 for unams
c
      call gspidx(ier,n2,nat,natmax,uaqsp,unam2)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          write (noutpt,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for illegal appearance of solvent water.
c
      if (unam1(1:4).eq.'H2O ' .or. unam2(1:4).eq.'H2O ' .or.
     $  n1.eq.1 .or. n2.eq.1) then
        write (noutpt,1200) unam1(1:j2),unam2(1:j3)
        write (nttyo,1200) unam1(1:j2),unam2(1:j3)
 1200   format(/' * Error - (EQPT/rdpnn) Have found an illegal',
     $  ' data block for the',/7x,'species pair ',a,', ',a,
     $  ' in the superblock of Pitzer data',/7x,"for nn' pairs.",
     $  ' Solvent water may not appear in such a pair.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the electrical charges of the species.
c
      z1 = 0.
      z2 = 0.
      iz1 = 0
      iz2 = 0
      if (n1 .gt. 0) then
        z1 = zaqsp(n1)
        iz1 = nint(z1)
      endif
      if (n2 .gt. 0) then
        z2 = zaqsp(n2)
        iz2 = nint(z2)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.gt.0 .and. n2.gt.0) then
c
c       Make sure that the species pair is appropriate for the
c       current superblock. It must be of type nn '. Other
c       pair types such as ca, cc', aa', nc, na, and nn are not
c       permitted here.
c
        if (iz1.ne.0 .or. iz2.ne.0 .or. n1.eq.n2) then
c
c         The current data block is in the wrong superblock.
c
          write (noutpt,1230) unam1(1:j2),unam2(1:j3)
          write (nttyo,1230) unam1(1:j2),unam2(1:j3)
 1230     format(/' * Error - (EQPT/rdpnn) Have found an',
     $    ' illegal data block for the',/7x,'species pair ',
     $    a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $    " nn' pairs.",/7x,'The present pair type may not',
     $    ' appear in the current superblock.')
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Species pair storage rules:
c
c       1. neutral < cation < anion
c
c       2. If both species are of the same charge type,
c          store alphabetically.
c
c     Here: alphabetical.
c
      if (lle(unam1,unam2)) then
c
c       The first species is first alphabetically.
c
        upair(1,npx2) = unam1
        upair(2,npx2) = unam2
      else
c
c       The second species is first alphabetically.
c
        upair(1,npx2) = unam2
        upair(2,npx2) = unam1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the coefficients for the lambda(nc) and lambda(na)
c     parameters. Store the lambda data as beta(0) data.
c
c     Check the required parameter header.
c
      read (ndat0s,1000,end=990,err=995) uline
      j4 = ilnobl(uline)
      j4 = min(j4,70)
      ux80 = uline
      call lejust(ux80)
      ustr16 = 'lambda'
      j5 = 6
      if (ux80(1:j5) .ne. ustr16(1:j5)) then
        write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
        write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
 1330   format(/' * Error - (EQPT/rdpnn) Have found a line',
     $  ' starting with:',/7x,'"',a,'"',/7x,'where "',a,'" was',
     $  ' expected in the block for the species',/7x,'pair ',
     $  a,', ',a,' in the superblock of Pitzer data',
     $  /7x,"for nn' pairs.")
        nerr = nerr + 1
        go to 999
      endif
c
c     Read the coefficients for the associated temperature function.
c
      do j = 1,jpfcmx
        read (ndat0s,1000,end=990,err=995) uline
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        ux80 = uline
        call lejust(ux80)
        ustr16 = 'a  ='
        j5 = 4
        write (ustr16(2:2),'(i1)') j
        if (ux80(1:j5) .eq. ustr16(1:j5)) then
          udastr = ux80
          udastr(1:j5) = ' '
          call g1dat(ier,noutpt,nttyo,udastr,var)
          if (ier .gt. 0) then
            write (noutpt,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
            write (nttyo,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1320       format(/' * Error - (EQPT/rdpnn) Have found a line',
     $      ' starting with:',/7x,'"',a,'"',/7x,'containing an',
     $      ' expected numerical field that could not be read.',
     $      /7x,'This occurred in the block for the species pair',
     $      /7x,a,', ',a,' in the superblock of Pitzer data',
     $      /7x,"for nn' pairs.")
            nerr = nerr + 1
            go to 999
          endif
          abeta(j,0,npx2) = var
        else
          write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          nerr = nerr + 1
          go to 999
        endif
      enddo
c
c     Skip past the block delimiter line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
      if (uline(1:8) .ne. uterm(1:8)) then
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        write (noutpt,1470) uline(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1470) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1470   format(/' * Error - (EQPT/rdpnn) Have found a line starting',
     $  ' with:',/7x,'"',a,'"',/7x,' in the data block for the species',
     $  ' pair ',a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $  " nn' pairs. Should have",/7x,'found the delimiter line',
     $  ' marking the end of the block.')
        nerr = nerr + 1
        go to 999
      endif
c
c     Process the next data block.
c
      go to 110
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdpnn) Unexpectedly encountered',
     $ /7x,"an end-of-file error while reading the nn' (lambda)",
     $ /7x,'superblock of the DATA0 file.')
      stop
c
  995 write (noutpt,2020)
      write (nttyo,2020)
 2020 format(/' * Error - (EQPT/rdpnn) Encountered a read format',
     $ /7x,"error while reading the nn' (lambda) superblock of",
     $ /7x,'the DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rdppsi(apsi,jpfcmx,nat,natmax,ndat0s,nerr,noutpt,
     $ npxpsi,npx3mx,npx3t,nttyo,nwarn,uaqsp,utripl,zaqsp)
c
c     This subroutine reads from the DATA1 file the coefficients
c     required to compute those Pitzer interaction parameters
c     associated with cation-different cation-anion (cc'a) and
c     anion-different anion-cation (aa'c) triplets. This particular
c     set of interaction coefficients includes the following:
c
c       1. psi(cc'a) and psi(aa'c)
c
c     Coefficients required to compute Pitzer interaction coefficients
c     associated with other triplet types or with pairs are not read
c     by this subroutine. This subroutine is one of several that
c     replace rdpz2.f and rdpz3.f.
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c
c     Principal output:
c
c       apsi   = array of coefficients for computing psi parameters
c       nerr   = cumulative error counter
c       npxpsi = the number of cc'a and aa'c triplets for which Pitzer
c                  parameters were read from the data file
c       npx3t  = the number of triplets of all species types for which
c                  Pitzer parameters were read from the data file.
c       nwarn  = cumulative warning counter
c       uaqsp  = array of names of aqueous species
c       utripl = array of species names for species triplets
c       uaqsp  = array of electrical charge numbers of aqueous species
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer jpfcmx,natmax,npx3mx
c
      integer ndat0s,noutpt,nttyo
c
      integer nat,nerr,npxpsi,npx3t,nwarn
c
      character*24 uaqsp(natmax),utripl(3,npx3mx)
c
      real*8 apsi(jpfcmx,npx3mx),zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer ier,iz1,iz2,iz3,j,j2,j3,j4,j5,j6,j7,j8,j9,
     $ na,nc,nn,npx3,npx3te,n1,n2,n3
c
      integer ilnobl
c
      logical qdupan,qdup12,qdup13,qdup23
c
      character(len=80) udastr,uline,ux80
      character*24 unam1,unam2,unam3,ux24a,ux24b,ux24c,u1,u2,u3
      character(len=24) uhdpsi,uhdnxt
      character(len=16) ustr16
      character*8 uterm,ux8
c
      real(8) var,z1,z2,z3
c
c-----------------------------------------------------------------------
c
      data uterm  /'+-------'/
      data uhdpsi /"cc'a and aa'c combinatio"/
      data uhdnxt /"nca combinations: zeta(n"/
c
c-----------------------------------------------------------------------
c
      npx3te = npx3t
      npx3 = npx3te
      j2 = 0
      j3 = 0
      j4 = 0
c
c     Advance to the start of the superblock for these parameters.
c
  100 read (ndat0s,1000,end=990,err=995) uline
 1000 format(a80)
      if (uline(1:24) .ne. uhdpsi(1:24)) go to 100
c
c     Skip the terminator.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the names of the species comprising a triplet.
c
  110 read (ndat0s,1010,end=990,err=995) unam1,unam2,unam3
 1010 format(a24,2x,a24,2x,a24)
c
      if (unam1(1:24) .eq. uhdnxt(1:24)) then
c
c       Found the header for the next superblock of Pitzer parameters.
c       Back up one line and terminate reading the current superblock.
c
        npxpsi = npx3 - npx3te
        npx3t = npx3
        backspace(ndat0s)
        go to 999
      endif
c
      npx3 = npx3 + 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Setup up some string data for error messages.
c
      j2 = ilnobl(unam1)
      if (j2 .le. 0) then
        unam1 = '<blank>'
        j2 = ilnobl(unam1)
      endif
c
      j3 = ilnobl(unam2)
      if (j3 .le. 0) then
        unam2 = '<blank>'
        j3 = ilnobl(unam2)
      endif
c
      j4 = ilnobl(unam3)
      if (j4 .le. 0) then
        unam3 = '<blank>'
        j4 = ilnobl(unam3)
      endif
c
      write (ux8,'(i5)') npx3
      call lejust(ux8)
      j5 = ilnobl(ux8)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for blank names.
c
      if (j2.le.0 .or. j3.le.0 .or. j4.le.0) then
        write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j3)
        write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j3)
 1020   format(/' * Error - (EQPT/rdppsi) Have encountered a blank',
     $  ' species name',/7x,'in the species triplet for block ',a,
     $  ' of the superblock for',/7x,"Pitzer cc'a and aa'c parameter",
     $  ' data. The offending triplet shows as',/7x,a,', ',a,', ',a,'.')
c
        if (npx3 .gt. (npx3te + 1)) then
          ux24a = utripl(1,npx3 - 1)
          ux24b = utripl(2,npx3 - 1)
          ux24c = utripl(3,npx3 - 1)
          if (ux24a(1:7).ne.'<blank>' .or.
     $      ux24b(1:7).ne.'<blank>' .or. ux24c(1:7).ne.'<blank>') then
            j7 = ilnobl(ux24a)
            j8 = ilnobl(ux24b)
            j9 = ilnobl(ux24c)
            write (noutpt,1030) ux24a(1:j7),ux24b(1:j8),ux24c(1:j9)
            write (nttyo,1030) ux24a(1:j7),ux24b(1:j8),ux24c(1:j9)
 1030       format(7x,'This block follows the one for ',a,
     $      ', ',a,', ',a,'.')
          endif
        endif
        nerr = nerr + 1
      endif
c
cXXXXXXXXX
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the indices of the three species (n1, n2, n3). These
c     indices point to the data read from the previously read
c     species blocks.
c
c     Calling sequence substitutions:
c       n1 for na
c       unam1 for unams
c
      call gspidx(ier,n1,nat,natmax,uaqsp,unam1)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
          write (noutpt,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          write (nttyo,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
 1100     format(/' * Error - (EQPT/rdppsi) The aqueous species ',
     $    a,' appearing in',/7x,"the Pitzer cc'a and aa'c parameter",
     $    ' data block for the species triplet',/7x,a,', ',a,', ',a,
     $    ' does not appear in an',/7x,'aqueous species data block.')
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n2 for na
c       unam2 for unams
c
      call gspidx(ier,n2,nat,natmax,uaqsp,unam2)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
          write (noutpt,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          write (nttyo,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n3 for na
c       unam3 for unams
c
      call gspidx(ier,n3,nat,natmax,uaqsp,unam3)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
          write (noutpt,1100) unam3(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          write (nttyo,1100) unam3(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for illegal appearance of solvent water.
c
      if (unam1(1:4) .eq.'H2O ' .or. unam2(1:4) .eq.'H2O ' .or.
     $  unam3(1:4).eq.'H2O ' .or. n1.eq.1 .or. n2.eq.1 .or.
     $  n3.eq.1) then
        write (noutpt,1200) unam1(1:j2),unam2(1:j3),unam3(1:j4)
        write (nttyo,1200) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1200   format(/' * Error - (EQPT/rdppsi) Have found an illegal data',
     $  ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $  ' in the superblock',/7x,"of Pitzer data for cc'a and aa'c",
     $  ' triplets. Solvent water may not',/7x,'appear in such a',
     $  ' triplet.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the electrical charges of the species.
c
      z1 = 0.
      z2 = 0.
      z3 = 0.
      iz1 = 0
      iz2 = 0
      iz3 = 0
      if (n1 .gt. 0) then
        z1 = zaqsp(n1)
        iz1 = nint(z1)
      endif
      if (n2 .gt. 0) then
        z2 = zaqsp(n2)
        iz2 = nint(z2)
      endif
      if (n3 .gt. 0) then
        z3 = zaqsp(n3)
        iz3 = nint(z3)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.ne.0 .and. n2.ne.0 .and. n3.ne.0) then
c
c       Make sure that the species triplet is appropriate for the
c       current superblock. It must be of type cc'a or aa'c. Other
c       triplet types such as nca, nnn, nnn', and nn'n' are not
c       permitted here.
c
c       Count the neutral species.
c
        nn = 0
        if (iz1 .eq. 0) nn = 1
        if (iz2 .eq. 0) nn = nn + 1
        if (iz3 .eq. 0) nn = nn + 1
c
c       Count the cations.
c
        nc = 0
        if (iz1 .gt. 0) nc = 1
        if (iz2 .gt. 0) nc = nc + 1
        if (iz3 .gt. 0) nc = nc + 1
c
c       Count the anions.
c
        na = 0
        if (iz1 .lt. 0) na = 1
        if (iz2 .lt. 0) na = na + 1
        if (iz3 .lt. 0) na = na + 1
c
c       Check for duplications.
c
        qdup12 = unam1(1:24) .eq. unam2(1:24)
        qdup13 = unam1(1:24) .eq. unam3(1:24)
        qdup23 = unam2(1:24) .eq. unam3(1:24)
        qdupan = qdup12 .or. qdup23 .or. qdup13
c
        if (nc.eq.3 .or. na.eq.3
     $    .or. (nc.eq.2 .and. nn.eq.1)
     $    .or. (na.eq.2 .and. nn.eq.1)
     $    .or. (nn.eq.2 .and. nc.eq.1)
     $    .or. (nn.eq.2 .and. na.eq.1)
     $    .or. (nc.eq.2 .and. na.eq.1 .and. qdupan)
     $    .or. (na.eq.2 .and. nc.eq.1 .and. qdupan)) then
c
c         The current data block refers to a triplet combination
c         that is not valid in the Pitzer framework.
c
          write (noutpt,1220) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1220) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1220     format(/' * Error - (EQPT/rdppsi Have found an',
     $    ' illegal data block for the',/7x,'species triplet ',
     $    a,', ',a,', ',a,' in the',/7x,'superblock of Pitzer',
     $    " data for cc'a and aa'c triplets.",/7x,'The present',
     $    ' triplet type is not valid in the Pitzer framework.')
          nerr = nerr + 1
        elseif (.not.(nc.eq.2 .and. na.eq.1)
     $    .and. .not.(na.eq.2 .and. nc.eq.1)) then
c
c         The current data block is in the wrong superblock.
c
          write (noutpt,1230) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1230) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1230     format(/' * Error - (EQPT/rdppsi Have found an',
     $    ' illegal data block for the',/7x,'species triplet ',
     $    a,', ',a,', ',a,' in the',/7x,'superblock of Pitzer',
     $    " data cc'a and aa'c triplets.",/7x,'The present',
     $    ' triplet type may not appear in the current superblock.')
          nerr = nerr + 1
        endif
c
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Species triplet storage rules:
c
c       nnn : neutral, neutral, neutral
c       nnn': neutral 1, neutral1, neutral 2
c       nca : neutral, cation, anion
c       cc'a: cation 1, cation 2, anion
c       aa'c: anion 1, anion 2, cation
c
c       A duplicated species appears first.
c
c       Otherwise, if two species are of the same charge type,
c       store alphabetically.
c
c     Here: the odd ion goes last. The alphabetical rule applies for
c     the other two.
c
c     Copy the names before rearranging for storage.
c
      u1 = unam1
      u2 = unam2
      u3 = unam3
c
c     Rearrange according to the storage rules. Note that
c     n1, n2, n3, z1, z2, z3, iz1, iz2, iz3 are all changed
c     in addtion to u1, u2, u3. Note that unam1, unam2, and
c     unam3 are not changed.
c
      call artrip(iz1,iz2,iz3,na,nc,nn,n1,n2,n3,
     $ u1,u2,u3,z1,z2,z3)
c
c     Store the triplet names in the order required by the
c     storage rules. The triplet in the original order is
c     preserved in unam1, unam2, unam3 for use in error messages
c     and such.
c
      utripl(1,npx3) = u1
      utripl(2,npx3) = u2
      utripl(3,npx3) = u3
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the coefficients for the psi(cc'a) or psi(aa'c)
c     parameters.
c
c     Check the required parameter header.
c
      read (ndat0s,1000,end=990,err=995) uline
      j5 = ilnobl(uline)
      j5 = min(j5,70)
      ux80 = uline
      call lejust(ux80)
      ustr16 = 'psi'
      j6 = 3
      if (ux80(1:j6) .ne. ustr16(1:j6)) then
        write (noutpt,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $  unam2(1:j3),unam3(1:j4)
        write (nttyo,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $  unam2(1:j3),unam3(1:j4)
 1330   format(/' * Error - (EQPT/rdppsi) Have found a line',
     $  ' starting with:',/7x,'"',a,'"',/7x,'where "',a,'" was',
     $  ' expected in the block for the species',/7x,'triplet ',
     $  a,', ',a,', ',a,' in the superblock of Pitzer data',
     $  /7x,"for cc'a and aa'c triplets.")
        nerr = nerr + 1
        go to 999
      endif
c
c     Read the coefficients for the associated temperature function.
c
      do j = 1,jpfcmx
        read (ndat0s,1000,end=990,err=995) uline
        j5 = ilnobl(uline)
        j5 = min(j5,70)
        ux80 = uline
        call lejust(ux80)
        ustr16 = 'a  ='
        j6 = 4
        write (ustr16(2:2),'(i1)') j
        if (ux80(1:j6) .eq. ustr16(1:j6)) then
          udastr = ux80
          udastr(1:j6) = ' '
          call g1dat(ier,noutpt,nttyo,udastr,var)
          if (ier .gt. 0) then
            write (noutpt,1320) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $      unam3(1:j4)
            write (nttyo,1320) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $      unam3(1:j4)
 1320       format(/' * Error - (EQPT/rdppsi) Have found a line',
     $      ' starting with:',/7x,'"',a,'"',/7x,'containing an',
     $      ' expected numerical field that could not be read.',
     $      /7x,'This occurred in the block for the species triplet',
     $      /7x,a,', ',a,', ',a,' in the superblock of Pitzer data',
     $      /7x,"for cc'a and aa'c triplets.")
            nerr = nerr + 1
            go to 999
          endif
          apsi(j,npx3) = var
        else
          write (noutpt,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $    unam2(1:j3),unam3(1:j4)
          write (nttyo,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $    unam2(1:j3),unam3(1:j4)
          nerr = nerr + 1
          go to 999
        endif
      enddo
c
c     Skip past the block delimiter line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
      if (uline(1:8) .ne. uterm(1:8)) then
        j5 = ilnobl(uline)
        j5 = min(j5,70)
        write (noutpt,1470) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j4)
        write (nttyo,1470) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j4)
 1470   format(/' * Error - (EQPT/rdppsi) Have found a line starting',
     $  ' with:',/7x,'"',a,'"',/7x,' in the data block for the species',
     $  ' triplet ',a,', ',a,', ',a,/7x,'in the superblock of',
     $  " Pitzer data for cc'a and aa'c triplets. Should have",
     $  /7x,'found the delimiter line marking the end of the block.')
        nerr = nerr + 1
        go to 999
      endif
c
c     Process the next data block.
c
      go to 110
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdppsi) Unexpectedly encountered',
     $ /7x,"an end-of-file error while reading the cc'a and aa'c",
     $ /7x,'(psi) superblock of the DATA0 file.')
      stop
c
  995 write (noutpt,2020)
      write (nttyo,2020)
 2020 format(/' * Error - (EQPT/rdppsi) Encountered a read format',
     $ /7x,"error while reading the cc'a and aa'c (psi) superblock",
     $ /7x,'of the DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
c
      end
      subroutine rdpth(abeta,ipbtmx,jpfcmx,nat,natmax,ndat0s,nerr,
     $ noutpt,npxth,npx2mx,npx2t,nttyo,nwarn,uaqsp,upair,zaqsp)
c
c     This subroutine reads from the DATA1 file the coefficients
c     required to compute those Pitzer interaction parameters
c     associated with cation-different cation (cc') and anion-
c     different anion (aa') pairs. This particular set of interaction
c     coefficients includes the following:
c
c       1. theta(cc'), theta(aa')
c
c     Coefficients required to compute Pitzer interaction coefficients
c     associated with other pair types or with triplets are not read
c     by this subroutine. This subroutine is one of several that
c     replace rdpz2.f and rdpz3.f.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c
c     Principal output:
c
c       abeta  = array of coefficients for computing beta parameters
c       nerr   = cumulative error counter
c       npxth  = the number of cc' and aa' pairs for which Pitzer
c                  parameters were read from the data file
c       npx2t  = the number of pairs of all species types for which
c                  Pitzer parameters were read from the data file.
c       nwarn  = cumulative warning counter
c       uaqsp  = array of names of aqueous species
c       upair  = array of species names for species pairs
c       uaqsp  = array of electrical charge numbers of aqueous species
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,npx2mx
c
      integer ndat0s,noutpt,nttyo
c
      integer nat,nerr,npxth,npx2t,nwarn
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real(8) abeta(jpfcmx,0:ipbtmx,npx2mx),zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer ier,iz1,iz2,j,j2,j3,j4,j5,j6,npx2,npx2te,n1,n2
c
      integer ilnobl
c
      character(len=80) udastr,uline,ux80
      character(len=24) unam1,unam2,ux24a,ux24b
      character(len=24) uhdni,uhdnxt
      character(len=16) ustr16
      character(len=8) uterm,ux8
c
      real(8) var,z1,z2
c
c-----------------------------------------------------------------------
c
      data uterm  /'+-------'/
      data uhdni  /"cc' and aa' combinations"/
      data uhdnxt /"nc and na combinations: "/
c
c-----------------------------------------------------------------------
c
      npx2te = npx2t
      npx2 = npx2te
      j2 = 0
      j3 = 0
c
c     Advance to the start of the superblock for these parameters.
c
  100 read (ndat0s,1000,end=990,err=995) uline
 1000 format(a80)
      if (uline(1:24) .ne. uhdni(1:24)) go to 100
c
c     Skip the terminator.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the names of the species comprising a pair.
c
  110 read (ndat0s,1010,end=990,err=995) unam1,unam2
 1010 format(a24,2x,a24)
c
      if (unam1(1:24) .eq. uhdnxt(1:24)) then
c
c       Found the header for the next superblock of Pitzer parameters.
c       Back up one line and terminate reading the current superblock.
c
        npxth = npx2 - npx2te
        npx2t = npx2
        backspace(ndat0s)
        go to 999
      endif
c
      npx2 = npx2 + 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Setup up some string data for error messages.
c
      j2 = ilnobl(unam1)
      if (j2 .le. 0) then
        unam1 = '<blank>'
        j2 = ilnobl(unam1)
      endif
c
      j3 = ilnobl(unam2)
      if (j3 .le. 0) then
        unam2 = '<blank>'
        j3 = ilnobl(unam2)
      endif
c
      write (ux8,'(i5)') npx2
      call lejust(ux8)
      j4 = ilnobl(ux8)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for blank names.
c
      if (j2.le.0 .or. j3.le.0) then
        write (noutpt,1020) ux8(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1020) ux8(1:j4),unam1(1:j2),unam2(1:j3)
 1020   format(/' * Error - (EQPT/rdpth) Have encountered a blank',
     $  ' species name',/7x,'in the species pair for block ',a,
     $  ' of the superblock for',/7x,"Pitzer cc' and aa' parameter",
     $  ' data. The offending pair shows as ',a,', ',a,'.')
c
        if (npx2 .gt. (npx2te + 1)) then
          ux24a = upair(1,npx2 - 1)
          ux24b = upair(2,npx2 - 1)
          if (ux24a(1:7).ne.'<blank>' .or.
     $      ux24b(1:7).ne.'<blank>') then
            j5 = ilnobl(ux24a)
            j6 = ilnobl(ux24b)
            write (noutpt,1030) ux24a(1:j5),ux24b(1:j6)
            write (nttyo,1030) ux24a(1:j5),ux24b(1:j6)
 1030       format(7x,'This block follows the one for ',a,
     $      ', ',a,'.')
          endif
        endif
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the indices of the two species (n1, n2). These
c     indices point to the data read from the previously
c     read species blocks.
c
c     Calling sequence substitutions:
c       n1 for na
c       unam1 for unams
c
      call gspidx(ier,n1,nat,natmax,uaqsp,unam1)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          write (noutpt,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
 1100     format(/' * Error - (EQPT/rdpth) The aqueous species ',
     $    a,' appearing in',/7x,"the Pitzer cc' and aa' parameter data",
     $    ' block for the species pair',/7x,a,', ',a,' does not appear',
     $    ' in an aqueous species',/7x,'data block.')
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n2 for na
c       unam2 for unams
c
      call gspidx(ier,n2,nat,natmax,uaqsp,unam2)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          write (noutpt,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for illegal appearance of solvent water.
c
      if (unam1(1:4).eq.'H2O ' .or. unam2(1:4).eq.'H2O ' .or.
     $  n1.eq.1 .or. n2.eq.1) then
        write (noutpt,1200) unam1(1:j2),unam2(1:j3)
        write (nttyo,1200) unam1(1:j2),unam2(1:j3)
 1200   format(/' * Error - (EQPT/rdpth) Have found an illegal',
     $  ' data block for the',/7x,'species pair ',a,', ',a,
     $  ' in the superblock of Pitzer data',/7x,"for cc' and aa'",
     $  ' pairs. Solvent water may not appear in such a pair.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the electrical charges of the species.
c
      z1 = 0.
      z2 = 0.
      iz1 = 0
      iz2 = 0
      if (n1 .gt. 0) then
        z1 = zaqsp(n1)
        iz1 = nint(z1)
      endif
      if (n2 .gt. 0) then
        z2 = zaqsp(n2)
        iz2 = nint(z2)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.gt.0 .and. n2.gt.0) then
c
c       Make sure that the species pair is appropriate for the
c       current superblock. It must be of type cc' or aa'. Other
c       pair types such as ca, nc, na, nn, and nn' are not
c       permitted here.
c
        if ((iz1*iz2) .lt. 0) then
          if (n1 .eq. n2) then
c
c           The current data block refers to a pair combination
c           that is not valid in the Pitzer framework.
c
            write (noutpt,1220) unam1(1:j2),unam2(1:j3)
            write (nttyo,1220) unam1(1:j2),unam2(1:j3)
 1220       format(/' * Error - (EQPT/rdpth) Have found an',
     $      ' illegal data block for the',/7x,'species pair ',
     $      a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $      " cc' and aa' pairs.",/7x,'The present pair',
     $      ' type is not valid in the Pitzer framework.')
          else
c           The current data block is in the wrong superblock.
c
            write (noutpt,1230) unam1(1:j2),unam2(1:j3)
            write (nttyo,1230) unam1(1:j2),unam2(1:j3)
 1230       format(/' * Error - (EQPT/rdpth) Have found an',
     $      ' illegal data block for the',/7x,'species pair ',
     $      a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $      " cc' and aa' pairs.",/7x,'The present pair',
     $      ' type may not appear in the current superblock.')
          endif
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Species pair storage rules:
c
c       1. neutral < cation < anion
c
c       2. If both species are of the same charge type,
c          store alphabetically.
c
c     Here: alphabetical.
c
      if (lle(unam1,unam2)) then
c
c       The first species comes first alphabetically.
c
        upair(1,npx2) = unam1
        upair(2,npx2) = unam2
      else
c
c       The second species comes first alphabetically.
c
        upair(1,npx2) = unam2
        upair(2,npx2) = unam1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the coefficients for the theta(cc') and theta(aa')
c     parameters. Store the theta data as beta(0) data.
c
c     Check the required parameter header.
c
      read (ndat0s,1000,end=990,err=995) uline
      j4 = ilnobl(uline)
      j4 = min(j4,70)
      ux80 = uline
      call lejust(ux80)
      ustr16 = 'theta'
      j5 = 5
      if (ux80(1:j5) .ne. ustr16(1:j5)) then
        write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
        write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $  unam2(1:j3)
 1330   format(/' * Error - (EQPT/rdpth) Have found a line',
     $  ' starting with:',/7x,'"',a,'"',/7x,'where "',a,'" was',
     $  ' expected in the block for the species',/7x,'pair ',
     $  a,', ',a,' in the superblock of Pitzer data',
     $  /7x,"for cc' and aa' pairs.")
        nerr = nerr + 1
        go to 999
      endif
c
c     Read the coefficients for the associated temperature function.
c
      do j = 1,jpfcmx
        read (ndat0s,1000,end=990,err=995) uline
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        ux80 = uline
        call lejust(ux80)
        ustr16 = 'a  ='
        j5 = 4
        write (ustr16(2:2),'(i1)') j
        if (ux80(1:j5) .eq. ustr16(1:j5)) then
          udastr = ux80
          udastr(1:j5) = ' '
          call g1dat(ier,noutpt,nttyo,udastr,var)
          if (ier .gt. 0) then
            write (noutpt,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
            write (nttyo,1320) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1320       format(/' * Error - (EQPT/rdpth) Have found a line',
     $      ' starting with:',/7x,'"',a,'"',/7x,'containing an',
     $      ' expected numerical field that could not be read.',
     $      /7x,'This occurred in the block for the species pair',
     $      /7x,a,', ',a,' in the superblock of Pitzer data',
     $      /7x,"for cc' and aa' pairs.")
            nerr = nerr + 1
            go to 999
          endif
          abeta(j,0,npx2) = var
        else
          write (noutpt,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          write (nttyo,1330) uline(1:j4),ustr16(1:j5),unam1(1:j2),
     $    unam2(1:j3)
          nerr = nerr + 1
          go to 999
        endif
      enddo
c
c     Skip past the block delimiter line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
      if (uline(1:8) .ne. uterm(1:8)) then
        j4 = ilnobl(uline)
        j4 = min(j4,70)
        write (noutpt,1470) uline(1:j4),unam1(1:j2),unam2(1:j3)
        write (nttyo,1470) uline(1:j4),unam1(1:j2),unam2(1:j3)
 1470   format(/' * Error - (EQPT/rdpth) Have found a line starting',
     $  ' with:',/7x,'"',a,'"',/7x,' in the data block for the species',
     $  ' pair ',a,', ',a,' in the',/7x,'superblock of Pitzer data for',
     $  " cc' and aa' pairs. Should have",/7x,'found the',
     $  ' delimiter line marking the end of the block.')
        nerr = nerr + 1
        go to 999
      endif
c
c     Process the next data block.
c
      go to 110
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdpth) Unexpectedly encountered',
     $ /7x,"an end-of-file error while reading the cc' and aa'",
     $ /7x,'(theta) superblock of the DATA0 file.')
      stop
c
  995 write (noutpt,2020)
      write (nttyo,2020)
 2020 format(/' * Error - (EQPT/rdpth) Encountered a read format',
     $ /7x,"error while reading the cc' and aa' (theta) superblock",
     $ /7x,'of the DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rdpz2(abeta,alpha,acphi,ipbtmx,jpfcmx,nat,natmax,
     $ ndat0s,nerr,noutpt,npx2mx,npx2t,nttyo,nwarn,uaqsp,upair,
     $ zaqsp)
c
c     This subroutine reads coefficients for computing the following
c     Pitzer interaction parameters from the DATA0 file:
c
c       beta(MX)(0), beta(MX)(1), beta(MX)(2), and their
c         temperature derivatives
c       Cphi(MX) and its temperature derivatives
c
c     (Here M = a cation and X = an anion). The alpha(1) and alpha(2)
c     coefficients which go with the beta parameters are also read.
c
c     The beta parameters map to conventional lambda parameters for
c     cation-anion pairs. Conventional lambda coefficients for MN
c     and NX pairs, where N = a neutral species may be entered in
c     place of beta parameters. The same is true for the observable
c     lambda coefficients of NN and NN' pairs (here N' is a second
c     neutral species).
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c
c     Principal output:
c
c       alpha  = array of Pitzer alpha constants
c       acphi  = array of coefficients for computing Cphi parameters
c       abeta  = array of coefficients for computing beta parameters
c       nerr   = cumulative error counter
c       npx2t  = the number of pairs of species for which Pitzer
c                  interaction parameters are defined
c       nwarn  = cumulative warning counter
c       uaqsp  = array of names of aqueous species
c       upair  = array of species names for species pairs
c       uaqsp  = array of electrical charge numbers of aqueous species
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,npx2mx
c
      integer ndat0s,noutpt,nttyo
c
      integer nat,nerr,npx2t,nwarn
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real(8) abeta(jpfcmx,0:ipbtmx,npx2mx),alpha(ipbtmx,npx2mx),
     $ acphi(jpfcmx,npx2mx),zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ier,iz1,iz1x,iz2,iz2x,j,j2,j3,j4,j5,j6,j7,npx2,n1,n2
c
      integer ilnobl
c
      logical qzepfc
c
      character(len=80) uline
      character(len=24) unam1,unam2,ux24a,ux24b
      character(len=8) umixt,usingl,uterm,ux8,ux8a
c
      real(8) z1,z2
c
c-----------------------------------------------------------------------
c
      data uterm  /'+-------'/
      data usingl /'single-s'/
      data umixt  / 'mixture'/
c
c-----------------------------------------------------------------------
c
      npx2 = 0
c
c     Advance to the start of the superblock for these parameters.
c
  100 read (ndat0s,1000,end=990,err=995) uline
 1000 format(a80)
      if (uline(1:8) .ne. usingl(1:8)) go to 100
c
c     Skip the terminator.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the names of the species comprising a pair.
c
  110 read (ndat0s,1010,end=990,err=995) unam1,unam2
 1010 format(a24,2x,a24)
c
      if (unam1(1:8) .eq. umixt(1:8)) then
c
c       Found the header for the mixture parameters superblock.
c
        npx2t = npx2
        go to 999
      endif
c
      npx2 = npx2 + 1
c
c     Check for blank names.
c
      j2 = ilnobl(unam1)
      j3 = ilnobl(unam2)
      if (j2.le.0 .or. j3.le.0) then
        write (ux8,'(i5)') npx2
        call lejust(ux8)
        j5 = ilnobl(ux8)
        if (j2 .le. 0) then
          unam1 = '<blank>'
          j2 = ilnobl(unam1)
        endif
        if (j3 .le. 0) then
          unam2 = '<blank>'
          j3 = ilnobl(unam2)
        endif
        write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
        write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
 1020   format(/' * Error - (EQPT/rdpz2) Have encountered a blank',
     $  ' species name',/7x,'in the species pair for block ',a,
     $  ' of the superblock for',/7x,'Pitzer parameter data',
     $  ' corresponding to species pairs.',/7x,'The offending',
     $  ' pair shows as ',a,', ',a,'.')
        if (npx2 .gt. 1) then
          ux24a = upair(1,npx2 - 1)
          ux24b = upair(2,npx2 - 1)
          if (ux24a(1:7).ne.'<blank>' .or.
     $      ux24b(1:7).ne.'<blank>') then
            j6 = ilnobl(ux24a)
            j7 = ilnobl(ux24b)
            write (noutpt,1030) ux24a(1:j6),ux24b(1:j7)
            write (nttyo,1030) ux24a(1:j6),ux24b(1:j7)
 1030       format(7x,'This block follows the one for ',a,
     $      ', ',a,'.')
          endif
        endif
        nerr = nerr + 1
      endif
c
c     Read the electrical charges.
c
      read (ndat0s,1050,end=990,err=995) z1,z2
 1050 format(f3.0,t15,f3.0)
c
      n1 = 0
      n2 = 0
      iz1 = 0
      iz2 = 0
c
c     Get the indices of the two species (n1, n2). These
c     indices point to the data read from the previously
c     read species blocks.
c
c     Calling sequence substitutions:
c       n1 for na
c       unam1 for unams
c
      call gspidx(ier,n1,nat,natmax,uaqsp,unam1)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          j2 = ilnobl(unam1)
          j3 = ilnobl(unam2)
          write (noutpt,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3)
 1100     format(/' * Error - (EQPT/rdpz2) The aqueous species ',
     $    a,' appearing in',/7x,'the Pitzer parameter data block',
     $    ' for the species pair',/7x,a,', ',a,' does not appear',
     $    ' in an aqueous species',/7x,'data block.')
          nerr = nerr + 1
        endif
      else
c
        iz1x = nint(z1)
        z1 = zaqsp(n1)
        iz1 = nint(z1)
c
        if (iz1 .ne. iz1x) then
          j2 = ilnobl(unam1)
          j3 = ilnobl(unam2)
          write (ux8a,'(i5)') iz1x
          call lejust(ux8a)
          j4 = ilnobl(ux8a)
          write (ux8,'(i5)') iz1
          call lejust(ux8)
          j5 = ilnobl(ux8)
          write (noutpt,1110) ux8a(1:j4),unam1(1:j2),
     $    unam1(1:j2),unam2(1:j3),ux8(1:j5)
          write (nttyo,1110) ux8a(1:j4),unam1(1:j2),
     $    unam1(1:j2),unam2(1:j3),ux8(1:j5)
 1110     format(/' * Note - (EQPT/rdpz2) A charge of ',a,
     $    ' was incorrectly',/7x,'specifed for ',a,' in the'
     $    ' data block for the pair',/7x,a,', ',a,'. The',
     $    ' correct charge is ',a,'.',/7x,'The incorrect',
     $    ' charge will be ignored.')
        endif
      endif
c
c     Calling sequence substitutions:
c       n2 for na
c       unam2 for unams
c
      call gspidx(ier,n2,nat,natmax,uaqsp,unam2)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>') then
          j2 = ilnobl(unam1)
          j3 = ilnobl(unam2)
          write (noutpt,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          write (nttyo,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3)
          nerr = nerr + 1
        endif
      else
c
        iz2x = nint(z2)
        z2 = zaqsp(n2)
        iz2 = nint(z2)
c
        if (iz2 .ne. iz2x) then
          j2 = ilnobl(unam1)
          j3 = ilnobl(unam2)
          write (ux8a,'(i5)') iz2x
          call lejust(ux8a)
          j4 = ilnobl(ux8a)
          write (ux8,'(i5)') iz2
          call lejust(ux8)
          j5 = ilnobl(ux8)
          write (noutpt,1110) ux8a(1:j4),unam2(1:j3),
     $    unam1(1:j2),unam2(1:j3),ux8(1:j5)
          write (nttyo,1110) ux8a(1:j4),unam2(1:j3),
     $    unam1(1:j2),unam2(1:j3),ux8(1:j5)
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for illegal appearance of solvent water.
c
      if (unam1(1:4).eq.'H2O ' .or. unam2(1:4).eq.'H2O ' .or.
     $  n1.eq.1 .or. n2.eq.1) then
        j2 = ilnobl(unam1)
        j3 = ilnobl(unam2)
        write (noutpt,1200) unam1(1:j2),unam2(1:j3)
        write (nttyo,1200) unam1(1:j2),unam2(1:j3)
 1200   format(/' * Error - (EQPT/rdpz2) Have found an illegal',
     $  ' data block for the',/7x,'species pair ',a,', ',a,
     $  ' among the blocks for "single-salt',/7x,'parameters".',
     $  ' Solvent water may not appear in such a pair in the',
     $  /7x,'normal Pitzer treatment of electrolyte solutions.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.gt.0 .and. n2.gt.0) then
c
c       Check for illegal combinations (cc, aa, cc', and aa').
c       Note that nc, na, and nn' combinations are allowed here
c       under restricted circumstances (see further below), even
c       though they technically correspond to mixtures.
c
        if ((iz1*iz2) .gt. 0) then
          j2 = ilnobl(unam1)
          j3 = ilnobl(unam2)
          if (n1 .ne. n2) then
            ux8 = 'cations'
            if (iz1 .lt. 0) ux8 = 'anions'
            j5 = ilnobl(ux8)
            write (noutpt,1220) unam1(1:j2),unam2(1:j3),ux8(1:j5)
            write (nttyo,1220) unam1(1:j2),unam2(1:j3),ux8(1:j5)
 1220       format(/' * Error - (EQPT/rdpz2) Have found an',
     $      ' illegal data block for the',/7x,'species pair ',
     $      a,', ',a,' among the blocks for "single-salt',
     $      /7x,'parameters". Both species are ',a,'. This is',
     $      ' not a valid',/7x,'combination for the present kind',
     $      ' of block. Enter these',/7x,'data in a block for',
     $      '"mixture parameters".')
          else
            write (noutpt,1230) unam1(1:j2),unam2(1:j3)
            write (nttyo,1230) unam1(1:j2),unam2(1:j3)
 1230       format(/' * Error - (EQPT/rdpz2) Have found an',
     $      ' illegal data block for the',/7x,'species pair ',
     $      a,', ',a,' among the blocks for "single-salt',
     $      /7x,'parameters". The same ion appears twice.',
     $      ' This is not',/7x,'a valid combination, as the',
     $      ' corresponding lambda and mu',/7x,'data are',
     $      ' defined to be zero by convention in the normal',
     $      ' Pitzer',/7x,'treatment of electrolyte solutions.')
          endif
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Species pair storage rules:
c
c       neutral < cation < anion
c       if both species are of the same charge type,
c       store alphabetically.
c
      if (iz1.eq.0 .and. iz2.ne.0) then
c
c       The first species is a neutral and the second species
c       isn't.
c
        upair(1,npx2) = unam1
        upair(2,npx2) = unam2
      elseif (iz2.eq.0 .and. iz1.ne.0) then
c
c       The second species is a neutral and the first species
c       isn't.
c
        upair(1,npx2) = unam2
        upair(2,npx2) = unam1
      elseif (iz1.gt.0 .and. iz2.lt.0) then
c
c       The first species is a cation and the second species
c       is an anion.
c
        upair(1,npx2) = unam1
        upair(2,npx2) = unam2
      elseif (iz2.gt.0 .and. iz1.lt.0) then
c
c       The second species is a cation and the first species
c       is an anion.
c
        upair(1,npx2) = unam2
        upair(2,npx2) = unam1
      else
c
c       Both species have the same charge type.
c
        if (unam1 .le. unam2) then
          upair(1,npx2) = unam1
          upair(2,npx2) = unam2
        else
          upair(1,npx2) = unam2
          upair(2,npx2) = unam1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the beta (lambda) coefficients.
c
      read (ndat0s,1300,end=990,err=995) abeta(1,0,npx2),
     $ abeta(1,1,npx2),abeta(1,2,npx2)
 1300 format(13x,f9.5,11x,f9.5,11x,f9.5)
c
c     Read the alpha parameters.
c
      read (ndat0s,1310,end=990,err=995) alpha(1,npx2),alpha(2,npx2)
 1310 format(18x,2(16x,f5.1))
c
c     Read the Cphi parameter.
c
      read (ndat0s,1320,end=990,err=995) acphi(1,npx2)
 1320 format(13x,f9.5,12x,f5.1)
c
c     Read source 1.
c
      read (ndat0s,1330,end=990,err=995) uline
 1330 format(13x,a24)
c
c     Read the beta (lambda) derivatives.
c
      read (ndat0s,1340,end=990,err=995) abeta(2,0,npx2),
     $ abeta(3,0,npx2)
      read (ndat0s,1340,end=990,err=995) abeta(2,1,npx2),
     $ abeta(3,1,npx2)
      read (ndat0s,1340,end=990,err=995) abeta(2,2,npx2),
     $ abeta(3,2,npx2)
 1340 format(13x,e10.3,13x,e10.3)
c
c     Read the Cphi derivatives.
c
      read (ndat0s,1340,end=990,err=995) acphi(2,npx2),
     $ acphi(3,npx2)
c
c     Read source 2.
c
      read (ndat0s,1330,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.gt.0 .and. n2.gt.0) then
c
        if ((iz1.eq.0 .and. iz2.eq.0) .and. (n1 .ne. n2)) then
c
c         Have an nn' combination. This is really a mixture
c         mixture parameter combination. Only lambda coefficients
c         (as "beta0") are permitted in a "single-salt parameters"
c         block. The coresponding two mu coefficients (as "psi")
c         must be entered in separate blocks under "mixture
c         parameters". The lambda data must be entered in a
c         block under "single-salt parameters" in order to
c         preserve current block formatting and to avoid the
c         problem that a given lambda of this type corresponds to
c         two distinct mu values. If such a lambda were to be
c         entered in the "theta" field of the blocks for the
c         corresponding mu values, then the same parameter would
c         be entered in two places.
c
          j2 = ilnobl(unam1)
          j3 = ilnobl(unam2)
          qzepfc = .true.
          do j = 1,jpfcmx
            if (acphi(j,npx2) .ne. 0.) qzepfc = .false.
          enddo
          if (.not. qzepfc) then
            write (noutpt,1400) unam1(1:j2),unam2(1:j3)
            write (nttyo,1400) unam1(1:j2),unam2(1:j3)
 1400       format(/' * Error - (EQPT/rdpz2) Have found an',
     $      ' illegal data block for the',/7x,'species pair ',
     $      a,', ',a,' among the blocks for "single-salt',
     $      /7x,'parameters". Have non-zero input for mu',
     $      ' data in the "Cphi" field.',/7x,'Only lambda data',
     $      ' may be specified (in the "beta0" field) in',
     $      /7x,'a block of this type. To specify mu data,',
     $      ' enter each of the',/7x,'two corresponding mu',
     $      " values [mu(nnn') and mu(n'n'n)] in separate",
     $      /7x,'"mixture parameters" blocks, using the "psi"',
     $      ' fields. The',/7x,'corresponding lambda data must',
     $      ' remain in a "single-salt parameters"',/7x,'block',
     $      ' (in the "beta0" field).')
            nerr = nerr + 1
          endif
        endif
c
        if ((iz1.ne.0 .and. iz2.eq.0) .or.
     $    (iz1.eq.0 .and. iz2.ne.0)) then
c
c         Have an nc or na combination. This is also really a
c         mixture parameter combination. Only lambda coefficients
c         (as "beta0") are permitted in a "single-salt parameters"
c         block. The coresponding zeta coefficient (as "psi")
c         must be entered in a block under "mixture parameters".
c         Note that there is a lambda(nc) and a lambda(na) for
c         each zeta(nca). The lambda data must be entered in
c         separate blocks under "single-salt parameters" because
c         a given lambda of this type is shared by various nca-
c         type mixtures and duplicate values would occur
c         if the lambdas were put into blocks under "mixture
c         parameters". For example, lambda(Na+, CO2(aq)) pertains
c         to mixtures involving various anions.
c
          j2 = ilnobl(unam1)
          j3 = ilnobl(unam2)
          qzepfc = .true.
          do j = 1,jpfcmx
            if (acphi(j,npx2) .ne. 0.) qzepfc = .false.
          enddo
          if (.not. qzepfc) then
            write (noutpt,1410) unam1(1:j2),unam2(1:j3)
            write (nttyo,1410) unam1(1:j2),unam2(1:j3)
 1410       format(/' * Error - (EQPT/rdpz2) Have found an',
     $      ' illegal data block for the',/7x,'species pair ',
     $      a,', ',a,' among the blocks for "single-salt',
     $      /7x,'parameters". Have non-zero input for zeta',
     $      ' data in the "Cphi"',/7x,'field. Only lambda data',
     $      ' may be specified in a block of this type,',
     $      /7x,'(in the "beta0" field). To specify zeta data,',
     $      ' enter it in',/7x,'a "mixture parameters"',
     $      ' block in the "psi" field. The',/7x,'corresponding',
     $      ' lambda data must remain in a "single-salt',
     $      /7x,'parameters" block (in the "beta0" field).')
            nerr = nerr + 1
          endif
        endif
c
        if (iz1*iz2 .ge. 0) then
c
c         Have a combination other than a ca combination.
c         The "beta1" and "beta2" parameters are ordinarily used
c         only for ca combinations. Issue a warning if they
c         are used for any other combinations, such as nc, na,
c         nn, or nn'.
c
          j2 = ilnobl(unam1)
          j3 = ilnobl(unam2)
          qzepfc = .true.
          do i = 1,ipbtmx
            do j = 1,jpfcmx
              if (abeta(j,i,npx2) .ne. 0.) qzepfc = .false.
            enddo
          enddo
          if (.not. qzepfc) then
            write (noutpt,1420) unam1(1:j2),unam2(1:j3)
            write (nttyo,1420) unam1(1:j2),unam2(1:j3)
 1420       format(/' * Warning - (EQPT/rdpz2) Have found a',
     $      ' data block for the',/7x,'species pair ',
     $      a,', ',a,' among the blocks for "single-salt',
     $      /7x,'parameters" that has non-zero input in the',
     $      ' "beta1" and/or "beta2"',/7x,'fields. The "beta1"',
     $      ' and "beta2" parameters are ordinarily used',
     $      /7x,'only for cation-anion pairs.')
            nwarn = nwarn + 1
          endif
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Skip past the block delimiter line.
c
  120 read (ndat0s,1500,end=990,err=995) uline
 1500 format(a8)
      if (uline(1:8) .eq. uterm(1:8)) then
c
c       Process the next data block.
c
        go to 110
      endif
      go to 120
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/rdpz2) Unexpectedly encountered',
     $ /7x,'end-of-file while reading the DATA0 file.')
      stop
c
  995 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdpz2) Encountered a read format',
     $ /7x,'error while reading the DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rdpz3(apsi,atheta,jpfcmx,nat,natmax,ndat0s,nerr,
     $ noutpt,npx3mx,npx3t,nthdt,nttyo,nwarn,uaqsp,uethfl,uthdtr,
     $ utripl,zaqsp)
c
c     This suboutine reads the following Pitzer interaction parameter
c     data from the DATA0 file:
c
c       S-theta(MM'X) (and S-theta (MXX')) and their temperature
c         derivatives
c       psi(MM'X) (and psi (MXX')) and their temperature derivatives
c
c     (Here M = a cation, M' = a second cation, X = an anion, and
c     X' = a second anion).
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c
c     Principal output:
c
c       apsi   = array of coefficients for computing psi parameters
c       atheta = array of coefficients for computing S-theta parameters
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c       nthdt  = the number of distinct S-theta parameter entries
c                  (i.e., not counting duplicates)
c       npx3t  = the number of triplets of species for which Pitzer
c                  interaction parameters are defined
c       utripl = array of names in a species triplet
c       uthdtr = array of names of cc'a and aa'c triplets which
c                  provide the values used for coefficients for
c                  computing S-theta parameters for the cc' and aa'
c                  pairs
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer jpfcmx,natmax,npx3mx
c
      integer ndat0s,noutpt,nttyo
c
      integer nat,nerr,npx3t,nthdt,nwarn
c
      character*24 uaqsp(natmax),uthdtr(3,npx3mx),utripl(3,npx3mx)
      character*8 uethfl
c
      real*8 atheta(jpfcmx,npx3mx),apsi(jpfcmx,npx3mx),zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ier,ifound,iz1,iz2,iz3,j,j2,j3,j4,j5,j6,j7,j8,
     $ na,nc,nn,npx3,nthd,n1,n2,n3
c
      integer ilnobl
c
      logical qdup12,qdup13,qdup23
c
      character*80 uline
      character*24 unam1,unam2,unam3,uthd1,uthd2,uthd3,ux24a,ux24b,
     $ ux24c,u1,u2,u3
      character*8 uelemt,uterm,ux8
c
      real(8), dimension(:), allocatable :: athetx
c
      real(8) z1,z2,z3
c
c-----------------------------------------------------------------------
c
      data uelemt / 'elements'/
      data uterm  / '+-------'/
c
c-----------------------------------------------------------------------
c
c     Allocate work array.
c
      ALLOCATE(athetx(jpfcmx))
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      nthdt = 0
      npx3 = 0
c
c     Read the E-theta flag.
c
      uethfl = ' '
      read (ndat0s,1000,end=990,err=995) uline
 1000 format(a80)
      i = index(uline,'E-theta flag')
      if (i .eq. 0) then
        write (noutpt,1010)
        write (nttyo,1010)
 1010   format(/' * Error - (EQPT/rdpz3) The E-theta flag line is',
     $  ' missing from',
     $  /7x,'the DATA0 file. This line is specific to DATA0 files',
     $  /7x,"tied to Pitzer's equations. It should appear after",
     $  /7x,'the line containing "mixture parameters". The E-theta',
     $  /7x,'flag line should contain "E-theta flag = on" or',
     $  /7x,'"E-theta flag = off". A value of "on" causes inclusion',
     $  /7x,'of the higher-order electrostatic (E-theta) terms in',
     $  /7x,"Pitzer's",' equations. A value of "off" causes the',
     $  /7x,"exclusion of these terms. Most models based on Pitzer's",
     $  /7x,'equations are consistent with the inclusion of these',
     $  /7x,'terms, but some are not. The values of the mixture',
     $  /7x,'coefficients theta and psi are consistent with either',
     $  /7x,'the inclusion or the exclusion of these terms.')
        stop
      endif
      i = index(uline,'= on')
      if (i .gt. 0) then
        uethfl = uline(i + 2:i + 3)
      else
        i = index(uline,'= off')
        if (i .gt. 0) then
          uethfl = uline(i + 2:i + 4)
        else
          write (noutpt,1020) uline
          write (nttyo,1020) uline
 1020     format(/' * Error - (EQPT/rdpz3) The value of the E-theta',
     $    ' flag on the line:',
     $    //7x,'"',a32,'"',
     $    //7x,"isn't ",'"on" or "off", as is required.')
          stop
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     LOOP HERE for each species block
c
  100 continue
c
c     Skip past the block terminator line.
c
      read (ndat0s,1000,end=990,err=995) uline
      if (uline(1:8) .ne. uterm(1:8)) go to 100
c
c     Check for the end of the present superblock.
c
      read (ndat0s,1030,end=990,err=995) unam1,unam2,unam3
 1030 format(a24,2x,a24,2x,a24)
      if (unam1(1:8) .eq. uelemt(1:8)) then
c
c       Found the header for the elements block.
c
        npx3t = npx3
        go to 999
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Have another species triplet.
c
      npx3 = npx3 + 1
c
      j2 = ilnobl(unam1)
      j3 = ilnobl(unam2)
      j4 = ilnobl(unam3)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for blank names.
c
      if (j2.le.0 .or. j3.le.0 .or. j4.le.0) then
        write (ux8,'(i5)') npx3
        call lejust(ux8)
        j5 = ilnobl(ux8)
        if (j2 .le. 0) then
          unam1 = '<blank>'
          j2 = ilnobl(unam1)
        endif
        if (j3 .le. 0) then
          unam2 = '<blank>'
          j3 = ilnobl(unam2)
        endif
        if (j4 .le. 0) then
          unam3 = '<blank>'
          j4 = ilnobl(unam3)
        endif
        write (noutpt,1040) ux8(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j4)
        write (nttyo,1040) ux8(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j4)
 1040   format(/' * Error - (EQPT/rdpz3) Have encountered a blank',
     $  ' species name',/7x,'in the species triplet for block ',a,
     $  ' of the superblock for',/7x,'Pitzer parameter data',
     $  ' corresponding to species triplets.',/7x,'The offending',
     $  ' triplet shows as ',a,', ',a,', ',a,'.')
        if (npx3 .gt. 1) then
          ux24a = utripl(1,npx3 - 1)
          ux24b = utripl(2,npx3 - 1)
          ux24c = utripl(3,npx3 - 1)
          if (ux24a(1:7).ne.'<blank>' .or.
     $      ux24b(1:7).ne.'<blank>' .or.
     $      ux24c(1:7).ne.'<blank>') then
            j6 = ilnobl(ux24a)
            j7 = ilnobl(ux24b)
            j8 = ilnobl(ux24c)
            write (noutpt,1050) ux24a(1:j6),ux24b(1:j7),ux24c(1:j8)
            write (nttyo,1050) ux24a(1:j6),ux24b(1:j7),ux24c(1:j8)
 1050       format(7x,'This block follows the one for ',a,
     $      ', ',a,', ',a,'.')
          endif
        endif
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the indices of the three species (n1, n2, n3). These
c     indices point to the data read from the previously read
c     species blocks.
c
c     Get the index for the first species name.
c
c     Calling sequence substitutions:
c       n1 for na
c       unam1 for unams
c
      call gspidx(ier,n1,nat,natmax,uaqsp,unam1)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
          write (noutpt,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          write (nttyo,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
 1100     format(/' * Error - (EQPT/rdpz3) The aqueous species ',
     $    a,' appearing in',/7x,'the Pitzer parameter data block',
     $    ' for the species triplet',/7x,a,', ',a,', ',a,' does',
     $    ' not appear in an aqueous',/7x,'species data block.')
          nerr = nerr + 1
        endif
      endif
c
c     Get the index for the second species name.
c
      qdup12 = .false.
      if (unam2(1:24) .eq. unam1(1:24)) then
c
        qdup12 = .true.
        n2 = n1
      else
c
c       Calling sequence substitutions:
c         n2 for na
c         unam2 for unams
c
        call gspidx(ier,n2,nat,natmax,uaqsp,unam2)
c
        if (ier .gt. 0) then
          if (unam1(1:7).ne.'<blank>' .and.
     $      unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
            write (noutpt,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3),
     $      unam3(1:j4)
            write (nttyo,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3),
     $      unam3(1:j4)
            nerr = nerr + 1
          endif
        endif
      endif
c
c     Get the index for the third species name.
c
      qdup13 = .false.
      qdup23 = .false.
      if (unam3(1:24) .eq. unam1(1:24)) then
c
        qdup13 = .true.
        if (qdup12) qdup23 = .true.
        n3 = n1
      elseif (unam3(1:24) .eq. unam2(1:24)) then
c
        qdup23 = .true.
        if (qdup12) qdup13 = .true.
        n3 = n2
      else
c
c       Calling sequence substitutions:
c         n3 for na
c         unam3 for unams
c
        call gspidx(ier,n3,nat,natmax,uaqsp,unam3)
c
        if (ier .gt. 0) then
          if (unam1(1:7).ne.'<blank>' .and.
     $      unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
            write (noutpt,1100) unam3(1:j4),unam1(1:j2),unam2(1:j3),
     $      unam3(1:j4)
            write (nttyo,1100) unam3(1:j4),unam1(1:j2),unam2(1:j3),
     $      unam3(1:j4)
            nerr = nerr + 1
          endif
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.ne.0 .and. n2.ne.0 .and. n3.ne.0) then
c
c       Get the charges.
c
        z1 = zaqsp(n1)
        z2 = zaqsp(n2)
        z3 = zaqsp(n3)
c
        iz1 = nint(z1)
        iz2 = nint(z2)
        iz3 = nint(z3)
c
c       Count the neutral species.
c
        nn = 0
        if (iz1 .eq. 0) nn = 1
        if (iz2 .eq. 0) nn = nn + 1
        if (iz3 .eq. 0) nn = nn + 1
c
c       Count the cations.
c
        nc = 0
        if (iz1 .gt. 0) nc = 1
        if (iz2 .gt. 0) nc = nc + 1
        if (iz3 .gt. 0) nc = nc + 1
c
c       Count the anions.
c
        na = 0
        if (iz1 .lt. 0) na = 1
        if (iz2 .lt. 0) na = na + 1
        if (iz3 .lt. 0) na = na + 1
c
c       Check for illegal species combinations. These checks depend
c       on the charge combinations; hence, they should not be made
c       unless the all the charges have been determined.
c
        call tripck(na,nc,nerr,nn,noutpt,nttyo,n1,n2,n3,
     $  qdup12,qdup13,qdup23,unam1,unam2,unam3)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Copy the names before rearranging for storage.
c
      u1 = unam1
      u2 = unam2
      u3 = unam3
c
c     Rearrange for storage. The rules are:
c
c       If exactly one neutral is present:
c         neutral, cation, anion
c
c       If exactly two neutrals are present:
c         neutral 1, neutral 1, neutral2
c
c       If two cations are present:
c         cation 1, cation 2, anion
c
c       If two anions are present:
c         anion 1, anion 2, cation
c
c       If two species are of the same charge type,
c       store alphabetically.
c
      call artrip(iz1,iz2,iz3,na,nc,nn,n1,n2,n3,
     $ u1,u2,u3,z1,z2,z3)
c
c     Store the triplet names in the order required by the
c     storage rules. The triplet in the original order is
c     preserved in unam1, unam2, unam3 for use in error messages
c     and such.
c
      utripl(1,npx3) = u1
      utripl(2,npx3) = u2
      utripl(3,npx3) = u3
c
c     Read the S-theta and psi parameters.
c
      read (ndat0s,1160,end=990,err=995) athetx(1),apsi(1,npx3)
 1160 format(13x,f8.5,13x,f8.5)
c
c     Read the first source.
c
      read (ndat0s,1170,end=990,err=995) uline
 1170 format(13x,a24)
c
c     Read the first and second temperature derivatives of the
c     S-theta and psi parameters.
c
      read (ndat0s,1180,end=990,err=995) athetx(2),athetx(3)
      read (ndat0s,1180,end=990,err=995) apsi(2,npx3),apsi(3,npx3)
 1180 format(13x,e10.3,13x,e10.3)
c
c     Read the second source.
c
      read (ndat0s,1170,end=990,err=995) uline
c
c     Check for illegal inputs in the S-theta data fields.
c
      call thetck(athetx,jpfcmx,na,nc,nerr,nn,noutpt,nttyo,
     $ n1,n2,n3,unam1,unam2,unam3)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if ((nc.eq.2 .and. na.eq.1) .or.
     $  (nc.eq.1 .and. na.eq.2)) then
c
c       Find the theta index for the two cations or two anions.
c
        ifound = 0
        do nthd = 1,nthdt
          uthd1 = uthdtr(1,nthd)
          uthd2 = uthdtr(2,nthd)
          uthd3 = uthdtr(3,nthd)
          if (u1.eq.uthd1 .and. u2.eq.uthd2) then
            ifound = 1
            j2 = ilnobl(u1)
            j3 = ilnobl(u2)
            j4 = ilnobl(u3)
            j5 = ilnobl(uthd1)
            j6 = ilnobl(uthd2)
            j7 = ilnobl(uthd3)
            do j = 1,jpfcmx
              write (ux8,'(i5)') j
              call lejust(ux8)
              j8 = ilnobl(ux8)
              if (abs(atheta(j,nthd) - athetx(j)) .gt. 1.e-6) then
                write (noutpt,1200) ux8(1:j8),u1(1:j2),u2(1:j3),
     $          u3(1:j4),athetx(j),uthd1(1:j5),uthd2(1:j6),
     $          uthd3(1:j7),atheta(j,nthd)
                write (nttyo,1200) ux8(1:j8),u1(1:j2),u2(1:j3),
     $          u3(1:j4),athetx(j),uthd1(1:j5),uthd2(1:j6),
     $          uthd3(1:j7),atheta(j,nthd)
 1200           format(/' * Warning - (EQPT/rdpz3) The S-theta',
     $          ' a(',a,') coefficient for the',/7x,'triplet ',
     $          a,', ',a,', ',a,' is ',e12.5,',',/7x,'whereas the',
     $          ' value previously read for the triplet',
     $          /7x,a,', ',a,', ',a,' is ',e12.5,'. The former',
     $          ' value will be ignored.')
                nwarn = nwarn + 1
              endif
            enddo
            go to 110
          endif
        enddo
  110   continue
c
        if (ifound .eq. 0) then
c
c         Found a new pair defining a theta parameter.
c
          nthdt = nthdt + 1
          nthd = nthdt
          uthdtr(1,nthd) = u1
          uthdtr(2,nthd) = u2
          uthdtr(3,nthd) = u3
          do j = 1,jpfcmx
            atheta(j,nthd) = athetx(j)
          enddo
        endif
      endif
c
c     Go back to read the next species block.
c
      go to 100
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/rdpz3) Unexpectedly encountered',
     $ /7x,'end-of-file while reading the DATA0 file.')
      stop
c
  995 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdpz3) Encountered a read format',
     $ /7x,'error while reading the DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
c
c     Deallocate work array.
c
      DEALLOCATE(athetx)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine rdpzet(apsi,jpfcmx,nat,natmax,ndat0s,nerr,noutpt,
     $ npxzet,npx3mx,npx3t,nttyo,nwarn,uaqsp,utripl,zaqsp)
c
c     This subroutine reads from the DATA1 file the coefficients
c     required to compute those Pitzer interaction parameters
c     associated with neutral-cation-anion (nca) triplets. This
c     particular set of interaction coefficients includes the
c     following:
c
c       1. zeta(nca)
c
c     Coefficients required to compute Pitzer interaction coefficients
c     associated with other triplet types or with pairs are not read
c     by this subroutine. This subroutine is one of several that
c     replace rdpz2.f and rdpz3.f.
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c       ndat1f = unit number of the DATA1F file
c
c     Principal output:
c
c       apsi   = array of coefficients for computing psi parameters
c       nerr   = cumulative error counter
c       npxzet = the number of nca triplets for which Pitzer parameters
c                 were read from the data file
c       npx3t  = the number of triplets of all species types for which
c                  Pitzer parameters were read from the data file.
c       nwarn  = cumulative warning counter
c       uaqsp  = array of names of aqueous species
c       utripl = array of species names for species triplets
c       uaqsp  = array of electrical charge numbers of aqueous species
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer jpfcmx,natmax,npx3mx
c
      integer ndat0s,noutpt,nttyo
c
      integer nat,nerr,npxzet,npx3t,nwarn
c
      character(len=24) uaqsp(natmax),utripl(3,npx3mx)
c
      real(8) apsi(jpfcmx,npx3mx),zaqsp(natmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer ier,iz1,iz2,iz3,j,j2,j3,j4,j5,j6,j7,j8,j9,
     $ na,nc,nn,npx3,npx3te,n1,n2,n3
c
      integer ilnobl
c
      logical qdupan,qdup12,qdup13,qdup23
c
      character(len=80) udastr,uline,ux80
      character(len=24) unam1,unam2,unam3,ux24a,ux24b,ux24c,u1,u2,u3
      character(len=24) uhdzet,uhdnxt
      character(len=16) ustr16
      character(len=8) uterm,ux8
c
      real(8) var,z1,z2,z3
c
c-----------------------------------------------------------------------
c
      data uterm  /'+-------'/
      data uhdzet /"nca combinations: zeta(n"/
      data uhdnxt /"nnn' combinations: mu(nn"/
c
c-----------------------------------------------------------------------
c
      npx3te = npx3t
      npx3 = npx3te
      j2 = 0
      j3 = 0
      j4 = 0
c
c     Advance to the start of the superblock for these parameters.
c
  100 read (ndat0s,1000,end=990,err=995) uline
 1000 format(a80)
      if (uline(1:24) .ne. uhdzet(1:24)) go to 100
c
c     Skip the terminator.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the names of the species comprising a triplet.
c
  110 read (ndat0s,1010,end=990,err=995) unam1,unam2,unam3
 1010 format(a24,2x,a24,2x,a24)
c
      if (unam1(1:24) .eq. uhdnxt(1:24)) then
c
c       Found the header for the next superblock of Pitzer parameters.
c       Back up one line and terminate reading the current superblock.
c
        npxzet = npx3 - npx3te
        npx3t = npx3
        backspace(ndat0s)
        go to 999
      endif
c
      npx3 = npx3 + 1
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Setup up some string data for error messages.
c
      j2 = ilnobl(unam1)
      if (j2 .le. 0) then
        unam1 = '<blank>'
        j2 = ilnobl(unam1)
      endif
c
      j3 = ilnobl(unam2)
      if (j3 .le. 0) then
        unam2 = '<blank>'
        j3 = ilnobl(unam2)
      endif
c
      j4 = ilnobl(unam3)
      if (j4 .le. 0) then
        unam3 = '<blank>'
        j4 = ilnobl(unam3)
      endif
c
      write (ux8,'(i5)') npx3
      call lejust(ux8)
      j5 = ilnobl(ux8)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for blank names.
c
      if (j2.le.0 .or. j3.le.0 .or. j4.le.0) then
        write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j3)
        write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j3)
 1020   format(/' * Error - (EQPT/rdpzet) Have encountered a blank',
     $  ' species name',/7x,'in the species triplet for block ',a,
     $  ' of the superblock for',/7x,"Pitzer nca parameter data.",
     $  ' The offending triplet shows as',/7x,a,', ',a,', ',a,'.')
c
        if (npx3 .gt. (npx3te + 1)) then
          ux24a = utripl(1,npx3 - 1)
          ux24b = utripl(2,npx3 - 1)
          ux24c = utripl(3,npx3 - 1)
          if (ux24a(1:7).ne.'<blank>' .or.
     $      ux24b(1:7).ne.'<blank>' .or. ux24c(1:7).ne.'<blank>') then
            j7 = ilnobl(ux24a)
            j8 = ilnobl(ux24b)
            j9 = ilnobl(ux24c)
            write (noutpt,1030) ux24a(1:j7),ux24b(1:j8),ux24c(1:j9)
            write (nttyo,1030) ux24a(1:j7),ux24b(1:j8),ux24c(1:j9)
 1030       format(7x,'This block follows the one for ',a,
     $      ', ',a,', ',a,'.')
          endif
        endif
        nerr = nerr + 1
      endif
c
cXXXXXXXXX
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the indices of the three species (n1, n2, n3). These
c     indices point to the data read from the previously read
c     species blocks.
c
c     Calling sequence substitutions:
c       n1 for na
c       unam1 for unams
c
      call gspidx(ier,n1,nat,natmax,uaqsp,unam1)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
          write (noutpt,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          write (nttyo,1100) unam1(1:j2),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
 1100     format(/' * Error - (EQPT/rdpzet) The aqueous species ',
     $    a,' appearing in',/7x,"the Pitzer nca parameter data",
     $    ' block for the species triplet',/7x,a,', ',a,', ',a,
     $    ' does not appear in an',/7x,'aqueous species data block.')
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n2 for na
c       unam2 for unams
c
      call gspidx(ier,n2,nat,natmax,uaqsp,unam2)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
          write (noutpt,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          write (nttyo,1100) unam2(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          nerr = nerr + 1
        endif
      endif
c
c     Calling sequence substitutions:
c       n3 for na
c       unam3 for unams
c
      call gspidx(ier,n3,nat,natmax,uaqsp,unam3)
c
      if (ier .gt. 0) then
        if (unam1(1:7).ne.'<blank>' .and.
     $    unam2(1:7).ne.'<blank>' .and. unam3(1:7).ne.'<blank>') then
          write (noutpt,1100) unam3(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          write (nttyo,1100) unam3(1:j3),unam1(1:j2),unam2(1:j3),
     $    unam3(1:j4)
          nerr = nerr + 1
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for illegal appearance of solvent water.
c
      if (unam1(1:4) .eq.'H2O ' .or. unam2(1:4) .eq.'H2O ' .or.
     $  unam3(1:4).eq.'H2O ' .or. n1.eq.1 .or. n2.eq.1 .or.
     $  n3.eq.1) then
        write (noutpt,1200) unam1(1:j2),unam2(1:j3),unam3(1:j4)
        write (nttyo,1200) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1200   format(/' * Error - (EQPT/rdpzet) Have found an illegal data',
     $  ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $  ' in the superblock',/7x,"of Pitzer data for nca triplets.",
     $  ' Solvent water may not',/7x,'appear in such a triplet.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the electrical charges of the species.
c
      z1 = 0.
      z2 = 0.
      z3 = 0.
      iz1 = 0
      iz2 = 0
      iz3 = 0
      if (n1 .gt. 0) then
        z1 = zaqsp(n1)
        iz1 = nint(z1)
      endif
      if (n2 .gt. 0) then
        z2 = zaqsp(n2)
        iz2 = nint(z2)
      endif
      if (n3 .gt. 0) then
        z3 = zaqsp(n3)
        iz3 = nint(z3)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (n1.ne.0 .and. n2.ne.0 .and. n3.ne.0) then
c
c       Make sure that the species triplet is appropriate for the
c       current superblock. It must be of type nca. Other triplet
c       types such as cc'a, aa'c, nnn, nnn', and nn'n' are not
c       permitted here.
c
c       Count the neutral species.
c
        nn = 0
        if (iz1 .eq. 0) nn = 1
        if (iz2 .eq. 0) nn = nn + 1
        if (iz3 .eq. 0) nn = nn + 1
c
c       Count the cations.
c
        nc = 0
        if (iz1 .gt. 0) nc = 1
        if (iz2 .gt. 0) nc = nc + 1
        if (iz3 .gt. 0) nc = nc + 1
c
c       Count the anions.
c
        na = 0
        if (iz1 .lt. 0) na = 1
        if (iz2 .lt. 0) na = na + 1
        if (iz3 .lt. 0) na = na + 1
c
c       Check for duplications.
c
        qdup12 = unam1(1:24) .eq. unam2(1:24)
        qdup13 = unam1(1:24) .eq. unam3(1:24)
        qdup23 = unam2(1:24) .eq. unam3(1:24)
        qdupan = qdup12 .or. qdup23 .or. qdup13
c
        if (nc.eq.3 .or. na.eq.3
     $    .or. (nc.eq.2 .and. nn.eq.1)
     $    .or. (na.eq.2 .and. nn.eq.1)
     $    .or. (nn.eq.2 .and. nc.eq.1)
     $    .or. (nn.eq.2 .and. na.eq.1)
     $    .or. (nc.eq.2 .and. na.eq.1 .and. qdupan)
     $    .or. (na.eq.2 .and. nc.eq.1 .and. qdupan)) then
c
c         The current data block refers to a triplet combination
c         that is not valid in the Pitzer framework.
c
          write (noutpt,1220) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1220) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1220     format(/' * Error - (EQPT/rdpzet Have found an',
     $    ' illegal data block for the',/7x,'species triplet ',
     $    a,', ',a,', ',a,' in the',/7x,'superblock of Pitzer',
     $    " data for nca triplets.",/7x,'The present triplet',
     $    ' type is not valid in the Pitzer framework.')
          nerr = nerr + 1
        elseif (.not.(nn.eq.1 .and. nc.eq.1 .and. na.eq.1)) then
c
c         The current data block is in the wrong superblock.
c
          write (noutpt,1230) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1230) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1230     format(/' * Error - (EQPT/rdpzet Have found an',
     $    ' illegal data block for the',/7x,'species triplet ',
     $    a,', ',a,', ',a,' in the',/7x,'superblock of Pitzer',
     $    " data nca triplets. The present",/7x,'triplet type',
     $    ' may not appear in the current superblock.')
          nerr = nerr + 1
        endif
c
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Species triplet storage rules:
c
c       nnn : neutral, neutral, neutral
c       nnn': neutral 1, neutral1, neutral 2
c       nca : neutral, cation, anion
c       cc'a: cation 1, cation 2, anion
c       aa'c: anion 1, anion 2, cation
c
c       A duplicated species appears first.
c
c       Otherwise, if two species are of the same charge type,
c       store alphabetically.
c
c     Here: neutral, cation, anion.
c
c     Copy the names before rearranging for storage.
c
      u1 = unam1
      u2 = unam2
      u3 = unam3
c
c     Rearrange according to the storage rules. Note that
c     n1, n2, n3, z1, z2, z3, iz1, iz2, iz3 are all changed
c     in addtion to u1, u2, u3. Note that unam1, unam2, and
c     unam3 are not changed.
c
      call artrip(iz1,iz2,iz3,na,nc,nn,n1,n2,n3,
     $ u1,u2,u3,z1,z2,z3)
c
c     Store the triplet names in the order required by the
c     storage rules. The triplet in the original order is
c     preserved in unam1, unam2, unam3 for use in error messages
c     and such.
c
      utripl(1,npx3) = u1
      utripl(2,npx3) = u2
      utripl(3,npx3) = u3
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the coefficients for the zeta(nca) parameters. Store the
c     zeta data as psi data.
c
c     Check the required parameter header.
c
      read (ndat0s,1000,end=990,err=995) uline
      j5 = ilnobl(uline)
      j5 = min(j5,70)
      ux80 = uline
      call lejust(ux80)
      ustr16 = 'zeta'
      j6 = 4
      if (ux80(1:j6) .ne. ustr16(1:j6)) then
        write (noutpt,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $  unam2(1:j3),unam3(1:j4)
        write (nttyo,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $  unam2(1:j3),unam3(1:j4)
 1330   format(/' * Error - (EQPT/rdpzet) Have found a line',
     $  ' starting with:',/7x,'"',a,'"',/7x,'where "',a,'" was',
     $  ' expected in the block for the species',/7x,'triplet ',
     $  a,', ',a,', ',a,' in the superblock of Pitzer data',
     $  /7x,"for nca triplets.")
        nerr = nerr + 1
        go to 999
      endif
c
c     Read the coefficients for the associated temperature function.
c
      do j = 1,jpfcmx
        read (ndat0s,1000,end=990,err=995) uline
        j5 = ilnobl(uline)
        j5 = min(j5,70)
        ux80 = uline
        call lejust(ux80)
        ustr16 = 'a  ='
        j6 = 4
        write (ustr16(2:2),'(i1)') j
        if (ux80(1:j6) .eq. ustr16(1:j6)) then
          udastr = ux80
          udastr(1:j6) = ' '
          call g1dat(ier,noutpt,nttyo,udastr,var)
          if (ier .gt. 0) then
            write (noutpt,1320) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $      unam3(1:j4)
            write (nttyo,1320) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $      unam3(1:j4)
 1320       format(/' * Error - (EQPT/rdpzet) Have found a line',
     $      ' starting with:',/7x,'"',a,'"',/7x,'containing an',
     $      ' expected numerical field that could not be read.',
     $      /7x,'This occurred in the block for the species triplet',
     $      /7x,a,', ',a,', ',a,' in the superblock of Pitzer data',
     $      /7x,"for nca triplets.")
            nerr = nerr + 1
            go to 999
          endif
          apsi(j,npx3) = var
        else
          write (noutpt,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $    unam2(1:j3),unam3(1:j4)
          write (nttyo,1330) uline(1:j5),ustr16(1:j6),unam1(1:j2),
     $    unam2(1:j3),unam3(1:j4)
          nerr = nerr + 1
          go to 999
        endif
      enddo
c
c     Skip past the block delimiter line.
c
      read (ndat0s,1000,end=990,err=995) uline
c
      if (uline(1:8) .ne. uterm(1:8)) then
        j5 = ilnobl(uline)
        j5 = min(j5,70)
        write (noutpt,1470) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j4)
        write (nttyo,1470) uline(1:j5),unam1(1:j2),unam2(1:j3),
     $  unam3(1:j4)
 1470   format(/' * Error - (EQPT/rdpzet) Have found a line starting',
     $  ' with:',/7x,'"',a,'"',/7x,' in the data block for the species',
     $  ' triplet ',a,', ',a,', ',a,/7x,'in the superblock of',
     $  " Pitzer data for nca triplets. Should have",
     $  /7x,'found the delimiter line marking the end of the block.')
        nerr = nerr + 1
        go to 999
      endif
c
c     Process the next data block.
c
      go to 110
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2010)
      write (nttyo,2010)
 2010 format(/' * Error - (EQPT/rdpzet) Unexpectedly encountered',
     $ /7x,"an end-of-file error while reading the nca (zeta)",
     $ /7x,'superblock of the DATA0 file.')
      stop
c
  995 write (noutpt,2020)
      write (nttyo,2020)
 2020 format(/' * Error - (EQPT/rdpzet) Encountered a read format',
     $ /7x,"error while reading the nca (zeta) superblock of",
     $ /7x,'the DATA0 file.')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
c
      end
      subroutine rdwele(atwt,nch,nco,nct,nctmax,ndata1,ndat0s,ndat1f,
     $ nerr,noutpt,nslist,nttyo,uelem)
c
c     This suboutine reads the chemical elements block from the
c     DATA0 file.
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nct    = the number of chemical elements
c       ndat0s = unit number of the stripped DATA0 file
c
c     Principal output:
c
c       atwt   = array of atomic weghts
c       uelem  = array of chemical element names
c       nerr   = cumulative error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer nctmax
c
      integer ndata1,ndat0s,ndat1f,nerr,noutpt,nslist,nttyo
c
      integer nch,nco,nct
c
      character(len=8) uelem(nctmax)
c
      real(8) atwt(nctmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer j2,j3,j4,nc
c
      integer ilnobl
c
      character(len=80) uline
      character(len=72) uterm,utermc
      character(len=24) ux24
      character(len=8) ux8a,ux8b
c
c-----------------------------------------------------------------------
c
      uterm(1:48) = '+-----------------------------------------------'
      uterm(49:72) = '------------------------'
      utermc = uterm
      utermc(1:1) = '*'
c
c     Skip to the 'elements' block.
c
  110 read(ndat0s,1000,end=120,err=120) uline
      if (uline(1:8) .ne. 'elements') go to 110
 1000 format(a)
      go to 130
c
  120 write(noutpt,1010)
      write(nttyo,1010)
 1010 format(/' * Error - (EQPT/eqpt) End-of-file hit or other read',
     $ /7x,'error occurred while searching for the elements block.')
      stop
c
  130 continue
c
c     Skip the delimiter line below the "elements" header.
c
      read (ndat0s,1000,end=990,err=995) uline
c
      ux24 = 'elements'
      j2 = ilnobl(ux24)
      write (ndata1) ux24
      write (ndat1f,1020) ux24(1:j2)
 1020 format(a)
      write (ndat1f,1020) utermc(1:72)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Read the chemical elements data.
c
      write (noutpt,1030)
      write (nslist,1030)
 1030 format(/)
      do nc = 1,nct
        read (ndat0s,1000,end=990,err=995) uline
        read (uline,1040,err=995) uelem(nc),atwt(nc)
 1040   format(a8,f10.5,5x,a8,5x,f10.5)
c
c       Check for a blank element name.
c
        j2 = ilnobl(uelem(nc))
        if (j2 .le. 0) then
          write (ux8a,'(i5)') nc
          call lejust(ux8a)
          j3 = ilnobl(ux8a)
          write (noutpt,1050) ux8a(1:j3)
          write (nttyo,1050) ux8a(1:j3)
 1050     format(/' * Error - (EQPT/rdwele) Have encountered a blank',
     $    ' name for chemical',/7x,'element number ',a,' in the list',
     $    ' of elements on the data file.')
          if (nc .gt. 1) then
            ux8b = uelem(nc - 1)
            if (ux8b(1:7) .ne. '<blank>') then
              j4 = ilnobl(ux8b)
              write (noutpt,1060) ux8b(1:j4)
              write (nttyo,1060) ux8b(1:j4)
 1060         format(7x,'This follows the element ',a,'.')
            endif
          endif
          stop
        endif
c
c       Check for a zero atomic weight.
c
        if (atwt(nc) .le. 0.) then
          j2 = ilnobl(uelem(nc))
          write (noutpt,1070) uelem(nc)(1:j2)
          write (nttyo,1070) uelem(nc)(1:j2)
 1070     format(/' * Error - (EQPT/rdwele) Have encountered a zero',
     $    ' atomic weight for ',a,/7x,'on the data file.')
          nerr = nerr + 1
        endif
c
        write (ndata1) uelem(nc),atwt(nc)
        write (ndat1f,1040) uelem(nc),atwt(nc)
        write (noutpt,1080) uelem(nc),atwt(nc)
        write (nslist,1080) uelem(nc),atwt(nc)
 1080   format(' element = ',a8,', atwt = ',f10.5)
      enddo
c
      write (ndat1f,1020) utermc(1:72)
c
c     Skip the ending delimiter.
c
      read (ndat0s,1000,end=990,err=995) uline
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Find the indices of O and H.
c
      nerr = 0
      nco = 0
      do nc = 1,nct
        if (uelem(nc)(1:2) .eq. 'O ') then
          nco = nc
          go to 140
        endif
      enddo
c
      write (noutpt,1140)
      write (nttyo,1140)
 1140 format(/' * Error - (EQPT/rdwele) The element O is not present',
     $ ' on the data file',/7x,'as is required.')
      nerr = nerr + 1
c
  140 continue
c
      nch = 0
      do nc = 1,nct
        if (uelem(nc)(1:2) .eq. 'H ') then
          nch = nc
          go to 150
        endif
      enddo
c
      write (noutpt,1150)
      write (nttyo,1150)
 1150 format(/' * Error - (EQPT/rdwele) The element H is not present',
     $ ' on the data file',/7x,'as is required.')
      nerr = nerr + 1
c
  150 continue
c
      if (nco .gt. 0) then
        if (nco .ne. 1) then
          j2 = ilnobl(uelem(1))
          write (noutpt,1160) uelem(1)(1:j2)
          write (nttyo,1160) uelem(1)(1:j2)
 1160     format(/' * Error - (EQPT/rdwele) The first chemical element',
     $    ' on the data file',/7x,'is ',a,'. The first chemical',
     $    ' element must be O. Note also that',/7x,'the corresponding',
     $    ' strict basis species must be H2O. This is an',
     $    /7x,'idiosyncrasy of EQ3/6.')
          nerr = nerr + 1
        endif
      endif
c
      go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/rdwele) Unexpectedly encountered',
     $ /7x,'end-of-file while reading the DATA0 file.')
c
      write (noutpt,2010) nc
      write (nttyo,2010) nc
 2010 format(7x,'The value of the local block line counter is ',i3,'.')
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,70)
        write (noutpt,2030) uline(1:j2)
        write (nttyo,2030) uline(1:j2)
 2030   format(7x,'The last line read was the following:',
     $  /7x,'"',a,'"')
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  995 write (noutpt,2040)
      write (nttyo,2040)
 2040 format(/' * Error - (EQPT/rdwele) Encountered a read format',
     $ /7x,'error while reading the DATA0 file.')
      write (noutpt,2010) nc
      write (nttyo,2010) nc
      j2 = ilnobl(uline)
      if (j2 .gt. 0) then
        j2 = min(j2,70)
        write (noutpt,2030) uline(1:j2)
        write (nttyo,2030) uline(1:j2)
      endif
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rdwttl(ipch,ipcv,jpdblo,jpfcmx,jptffl,narxt,ndata1,
     $ ndat0s,ndat1f,noutpt,nslist,ntitld,ntidmx,ntprmx,ntprt,nttyo,
     $ uakey,utitld)
c
c     This suboutine reads the title on the DATA0 file and writes it
c     on the DATA1 and DATA1F files. It checks the DATA0 file
c     header for validity. It also searches the title for embedded
c     flags and data indicating special treatment.
c
c     Possible embedded flags and data deal with the following:
c
c       1. Defining the temperature grid used on the data file.
c          By default, the classic eight-temperature grid is used.
c       2. Indicating the presence of data grids for enthalpy
c          and volume functions. By default, these data grids
c          are assumed to be absent.
c       3. Defining the temperature function used to describe
c          Pitzer interaction parameters. By default, this function
c          is the classic second-order Taylor's series centered
c          at 25C.
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndat0s = unit number of the stripped DATA0 file
c
c     Principal output:
c
c       ipch   = enthalpy functions data grid flag:
c                  -1 = no enthalpy grids
c                   0 = enthalpy grids present
c                   1 = grids present for the enthalpy and its first
c                         pressure derivative
c                   2 = grids present for the enthalpy and its first
c                         and second pressure derivatives
c       ipcv   = volume functions data flag:
c                  -1 = no volume grids
c                   0 = volume grids present
c                   1 = grids present for the volume and its first
c                         pressure derivative
c                   2 = grids present for the volume and its first
c                         and second pressure derivatives
c       ntitld = the number of lines in the title
c       utitld = array of title lines
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer jpfcmx,ntidmx,ntprmx
c
      integer narxt(ntprmx)
c
      integer ndata1,ndat0s,ndat1f,noutpt,nslist,ntitld,nttyo
c
      integer ipch,ipcv,jpdblo,jptffl,ntprt
c
      character(len=80) utitld(ntidmx)
      character(len=8) uakey
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,j,j2,j3,j4,k,n,narxti,nerr,ntpr,ntpri
c
      integer ilnobl
c
      logical qrderr
c
      character(len=56) ux56
c
      character(len=80) ulbufa,ulbufb
      character(len=72) uterm,utermc
      character(len=32) upchst,upcvst
      character(len=8) ustr,ux8a,ux8b
c
c-----------------------------------------------------------------------
c
      uterm(1:48) = '+-----------------------------------------------'
      uterm(49:72) = '------------------------'
      utermc = uterm
      utermc(1:1) = '*'
c
c     Read the data file title.
c
      ntitld = ntidmx
      do n = 1,ntitld
        read (ndat0s,1000,end=990,err=995) utitld(n)
 1000   format(a)
        if (utitld(n)(1:8) .eq. uterm(1:8)) go to 110
      enddo
  110 continue
c
c     Write title information.
c
      do n = 1,ntitld
         j2 = ilnobl(utitld(n))
         j2 = min(j2,79)
         write (ndata1) utitld(n)
         write (ndat1f,1000) utitld(n)(1:j2)
         write (nttyo,1140) utitld(n)(1:j2)
         write (noutpt,1140) utitld(n)(1:j2)
         write (nslist,1140) utitld(n)(1:j2)
 1140    format(' ',a)
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Get the parameters for the temperature grid used for log K values
c     and standard state enthalpy and volume functions.
c
c       ntprt       = the number of temperature ranges
c       narxt(ntpr) = the number of points or coefficients in the
c                       ntpr-th temperature range
c
c     The last point of the ntpr-th temperature range is also the first
c     point of the following range, if any. This insures continuity.
c     The default values correspond to the original EQ3/6 data grid:
c
c       ntprt = 2
c       narxt(1) = 4  (0, 25, 60 100 C)
c       narxt(2) = 5  (100, 150, 200, 250, 300 C)
c
c     Note: the number of temperature ranges (ntprt) is equal to
c     the dimensioned limit (ntpr_asv), which has been determined
c     by a prior scan. The prior scan has also provided narx_asv,
c     the dimenionsed limit on the number of values in a temperature
c     range. This was found as the greatest value of any range.
c     Now, it is necessary to get the actual value for each range.
c
      ntprt = ntprmx
      call initiz(narxt,ntprmx)
      if (ntprt .eq. 2) then
        narxt(1) = 4
        narxt(2) = 5
      endif
c
      do ntpr = 1,ntprt
        do n = 1,ntitld
          ulbufa = ' '
          ulbufb = ' '
          j = 0
c
c         Check for a keystring.
c
          i = index(utitld(n),'NO. OF POINTS IN RANGE')
          if (i .gt. 0) then
            j = i + 22
          else
             i = index(utitld(n),'NUMBER OF POINTS IN RANGE')
            if (i .gt. 0) then
              j = i + 25
            else
              i = index(utitld(n),'NARXT')
              if (i .gt. 0) j = i + 5
            endif
          endif
c
          if (j .gt. 0) then
c
c           Extract a number acting as a subscript to the keystring.
c
            ulbufb = utitld(n)(j:80)
            call lejust(ulbufb)
            j = index(ulbufb,' ')
            j = min(j,9)
            k = j - 1
            if (k .gt. 0) then
              ustr = ulbufb(1:k)
              call chrint(ntpri,nttyo,qrderr,ustr)
              if (qrderr) go to 997
              if (ntpri .ne. ntpr) j = 0
            else
              j = 0
            endif
          endif
c
          if (j .gt. 0) then
c
c           Check for an equal sign following the keystring.
c
            ulbufa = ulbufb(j:80)
            call lejust(ulbufa)
            i = index(ulbufa,'=')
            j = 2
            if (i .ne. 1) j = 0
          endif
c
          if (j .gt. 0) then
c
c           Extract a number matching the keystring.
c
            ulbufb = ulbufa(j:80)
            call lejust(ulbufb)
            ustr = ulbufb(1:8)
            call chrint(narxti,nttyo,qrderr,ustr)
            if (qrderr) go to 997
            narxt(ntpr) = narxti
            go to 220
          endif
        enddo
  220   continue
c
      enddo
c
      nerr = 0
      ntpr = 1
      if (narxt(ntpr) .lt. 2) then
        write (ux8a,'(i5)') ntpr
        call lejust(ux8a)
        j3 = ilnobl(ux8a)
        write (ux8b,'(i5)') narxt(ntpr)
        call lejust(ux8b)
        j4 = ilnobl(ux8b)
        write (noutpt,1320) ux8a(1:j3),ux8b(1:j4)
        write (nttyo,1320) ux8a(1:j3),ux8b(1:j4)
 1320   format(/' * Error - (EQPT/rdwttl) The number of points in',
     $  /7x,'temperature range ',a,' is ',a,'. The number of',
     $  /7x,'points in the first or last temperature range must be',
     $  /7x,'at least 2.')
        nerr = nerr + 1
      endif
c
      do ntpr = 2,ntprt - 1
        if (narxt(ntpr) .lt. 3) then
          write (ux8a,'(i5)') ntpr
          call lejust(ux8a)
          j3 = ilnobl(ux8a)
          write (ux8b,'(i5)') narxt(ntpr)
          call lejust(ux8b)
          j4 = ilnobl(ux8b)
          write (noutpt,1330) ux8a(1:j3),ux8b(1:j4)
          write (nttyo,1330) ux8a(1:j3),ux8b(1:j4)
 1330     format(/' * Error - (EQPT/rdwttl) The number of points in',
     $    /7x,'temperature range ',a,' is ',a,'. The number of',
     $    /7x,'points in an interior temperature range must be at',
     $    /7x,'least 3.')
          nerr = nerr + 1
        endif
      enddo
c
      ntpr = ntprt
      if (ntpr.gt.1 .and. narxt(ntpr).lt.2) then
        write (ux8a,'(i5)') ntpr
        call lejust(ux8a)
        j3 = ilnobl(ux8a)
        write (ux8b,'(i5)') narxt(ntpr)
        call lejust(ux8b)
        j4 = ilnobl(ux8b)
        write (noutpt,1320) ux8a(1:j3),ux8b(1:j4)
        write (nttyo,1320) ux8a(1:j3),ux8b(1:j4)
        nerr = nerr + 1
      endif
c
      if (nerr .gt. 0) stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the grid parameters.
c
      ux56 = 'Number of ranges in the logK temperature grid'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1350) ux56(1:j2)
 1350 format(a)
c
      write (ndata1) ntprt
      write (ndat1f,1360) ntprt
 1360 format(i5)
c
      do ntpr = 1,ntprt
        ux56 = 'Number of points in range '
        j2 = ilnobl(ux56)
        write (ux8a,'(i5)') ntpr
        call lejust(ux8a)
        j3 = ilnobl(ux8a)
        ux56(j2 + 2: j2 + 1 + j3) = ux8a(1:j3)
c
        write (ndata1) ux56
        j2 = ilnobl(ux56)
        write (ndat1f,1350) ux56(1:j2)
c
        n = narxt(ntpr)
        write (ndata1) n
        write (ndat1f,1360) n
      enddo
c
      write (ux8a,'(i5)') ntprt
      call lejust(ux8a)
      j3 = ilnobl(ux8a)
      write (noutpt,1380) ux8a(1:j3)
      write (nttyo,1380) ux8a(1:j3)
 1380 format(/' Number of logK temperature grid ranges= ',a)
      do ntpr = 1,ntprt
        write (ux8a,'(i5)') ntpr
        call lejust(ux8a)
        j2 = ilnobl(ux8a)
        n = narxt(ntpr)
        write (ux8b,'(i5)') n
        call lejust(ux8a)
        j3 = ilnobl(ux8a)
 1390   format('   Number of points in range ',a,'= ',a)
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Set flags for enthalpy and volume functions data grids.
c
      ipch = -1
      do n = 1,ntitld
        ulbufa = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(utitld(n),'ENTHALPY')
        if (i .gt. 0) j = i + 8
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = utitld(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a string input matching the keystring.
c
          ustr = ulbufa(2:9)
          call lejust(ustr)
          k = index(ustr,'ON')
          if (k .le. 0) k = index(ustr,'PRESENT')
          if (k .le. 0) k = index(ustr,'ACTIVE')
          if (k .gt. 0) ipch = 0
          go to 300
        endif
      enddo
  300 continue
c
      do n = 1,ntitld
        ulbufa = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(utitld(n),'dH/dP')
        if (i .gt. 0) j = i + 5
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = utitld(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a string input matching the keystring.
c
          ustr = ulbufa(2:9)
          call lejust(ustr)
          k = index(ustr,'ON')
          if (k .le. 0) k = index(ustr,'PRESENT')
          if (k .le. 0) k = index(ustr,'ACTIVE')
          if (k .gt. 0) then
            if (ipch .eq. 0) then
              ipch = 1
            else
              write (noutpt,1400)
              write (nttyo,1400)
 1400         format(/" * Error - (EQPT/rdwttl) Can't use dH/dP data",
     $        ' without',/7x,'enthalpy (H) data.')
              stop
            endif
          endif
          go to 310
        endif
      enddo
  310 continue
c
      do n = 1,ntitld
        ulbufa = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(utitld(n),'d2H/dP2')
        if (i .gt. 0) j = i + 7
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = utitld(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a string input matching the keystring.
c
          ustr = ulbufa(2:9)
          call lejust(ustr)
          k = index(ustr,'ON')
          if (k .le. 0) k = index(ustr,'PRESENT')
          if (k .le. 0) k = index(ustr,'ACTIVE')
          if (k .gt. 0) then
            if (ipch .eq. 1) then
              ipch = 2
            else
              write (noutpt,1410)
              write (nttyo,1410)
 1410         format(/" * Error - (EQPT/rdwttl) Can't use d2H/dP2",
     $        ' data without',/7x,'enthalpy (H) and dH/dP data.')
              stop
            endif
          endif
          go to 320
        endif
      enddo
  320 continue
c
      ipcv = -1
      do n = 1,ntitld
        ulbufa = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(utitld(n),'VOLUME')
        if (i .gt. 0) j = i + 6
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = utitld(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a string input matching the keystring.
c
          ustr = ulbufa(2:9)
          call lejust(ustr)
          k = index(ustr,'ON')
          if (k .le. 0) k = index(ustr,'PRESENT')
          if (k .le. 0) k = index(ustr,'ACTIVE')
          if (k .gt. 0) ipcv = 0
          go to 330
        endif
      enddo
  330 continue
c
      do n = 1,ntitld
        ulbufa = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(utitld(n),'dV/dP')
        if (i .gt. 0) j = i + 5
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = utitld(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a string input matching the keystring.
c
          ustr = ulbufa(2:9)
          call lejust(ustr)
          k = index(ustr,'ON')
          if (k .le. 0) k = index(ustr,'PRESENT')
          if (k .le. 0) k = index(ustr,'ACTIVE')
          if (k .gt. 0) then
            if (ipcv .eq. 0) then
              ipcv = 1
            else
              write (noutpt,1420)
              write (nttyo,1420)
 1420         format(/" * Error - (EQPT/rdwttl) Can't use dV/dP data",
     $        ' without',/7x,'volume (V) data.')
              stop
            endif
          endif
          go to 340
        endif
      enddo
  340 continue
c
      do n = 1,ntitld
        ulbufa = ' '
        j = 0
c
c       Check for a keystring.
c
        i = index(utitld(n),'d2V/dP2')
        if (i .gt. 0) j = i + 7
c
        if (j .gt. 0) then
c
c         Check for an equal sign following the keystring.
c
          ulbufa = utitld(n)(j:80)
          call lejust(ulbufa)
          i = index(ulbufa,'=')
          j = 2
          if (i .ne. 1) j = 0
        endif
c
        if (j .gt. 0) then
c
c         Extract a string input matching the keystring.
c
          ustr = ulbufa(2:9)
          call lejust(ustr)
          k = index(ustr,'ON')
          if (k .le. 0) k = index(ustr,'PRESENT')
          if (k .le. 0) k = index(ustr,'ACTIVE')
          if (k .gt. 0) then
            if (ipcv .eq. 1) then
              ipcv = 2
            else
              write (noutpt,1430)
              write (nttyo,1430)
 1430         format(/" * Error - (EQPT/rdwttl) Can't use d2V/dP2",
     $        ' data without',/7x,'volume (V) and dV/dP data.')
              nerr = nerr + 1
            endif
          endif
          go to 350
        endif
      enddo
  350 continue
c
      if (ipch.gt.0 .and. ipcv.lt.0) then
        write (noutpt,1440)
        write (nttyo,1440)
 1440   format(/" * Error - (EQPT/rdwttl) Can't have pressure",
     $  ' corrections',
     $  /7x,'for enthalpy functions without having such corrections',
     $  /7x,'for log K functions. At a minimum, volume functions',
     $  /7x,'must be present.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write flags for enthalpy and volume functions grids.
c
      ux56 = 'Enthalpy functions flag'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1450) ux56(1:j2)
 1450 format(a)
c
      write (ndata1) ipch
      write (ndat1f,1460) ipch
 1460 format(i5)
c
      upchst = 'Not present'
      if (ipch .eq. 0) then
        upchst = 'Present, no dH/dP data'
      elseif (ipch .eq. 1) then
        upchst = 'Present, with dH/dP data'
      elseif (ipch .ge. 2) then
        upchst = 'Present, with dH/dP-dnH/dPn data'
        write (upchst,'(21x,i1,4x,i1)') ipch
      endif
      j2 = ilnobl(upchst)
c
      write (noutpt,1470) ipch,upchst(1:j2)
      write (nttyo,1470) ipch,upchst(1:j2)
 1470 format(/' Enthalpy functions flag= ',i2,' (',a,')')
c
      ux56 = 'Volume functions flag'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1450) ux56(1:j2)
c
      write (ndata1) ipcv
      write (ndat1f,1460) ipcv
c
      upcvst = 'Not present'
      if (ipcv .eq. 0) then
        upcvst = 'Present, no dV/dP data'
      elseif (ipcv .eq. 1) then
        upcvst = 'Present, with dV/dP data'
      elseif (ipcv .ge. 2) then
        upcvst = 'Present, with dV/dP-dnV/dPn data'
        write (upcvst,'(21x,i1,4x,i1)') ipcv
      endif
      j2 = ilnobl(upcvst)
c
      write (noutpt,1480) ipcv,upcvst(1:j2)
      write (nttyo,1480) ipcv,upcvst(1:j2)
 1480 format(' Volume functions flag  = ',i2,' (',a,')')
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (uakey(1:8) .eq. 'Pitzer  ') then
c
c       Write the flag for Pitzer data block organization.
c
        ux56 = 'Pitzer data block organization flag'
        write (ndata1) ux56
        j2 = ilnobl(ux56)
        write (ndat1f,1450) ux56(1:j2)
c
        write (ndata1) jpdblo
        write (ndat1f,1460) jpdblo
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check the temperature function used to represent Pitzer
c     interaction parameters. This is determined by the value
c     of jptffl, which was read previously by ggridp.f.
c
      if (uakey(1:8) .eq. 'Pitzer  ') then
        if (jpdblo .eq. -1) then
          if (jptffl .ne. -1) then
            write (noutpt,1510)
            write (nttyo,1510)
 1510       format(/' * Note - (EQPT/rdwttl) Resetting the jptffl',
     $      ' Pitzer data',/7x,'temperature function flag to -1',
     $      " (classic 25C-centric Taylor's series",/7x,'truncated',
     $      ' at second order), because the Pitzer data block',
     $      /7x,'organization flag (jpdblo) is set to -1',
     $      ' ("Classical").',/7x,'Other Pitzer data temperature',
     $      ' functions are not permitted.')
            jptffl = -1
          endif
        endif
c
        if (jptffl .eq. -1) then
          if (jpfcmx .ne. 3) then
            write (noutpt,1520)
            write (nttyo,1520)
 1520       format(/' * Error - (EQPT/rdwttl) The number of terms',
     $      ' (jpfcmx) used in',/7x,'the Pitzer data temperature',
     $      ' function is not 3, as is required',/7x,'in the case',
     $      " of the classical 25C-centric Taylor's series",
     $      /7x,'truncated at second order (jptffl = -1).')
            nerr = nerr + 1
          endif
        endif
c
        if (jptffl .eq. 1) then
          if (jpfcmx .ne. 8) then
            write (noutpt,1530)
            write (nttyo,1530)
 1530       format(/' * Error - (EQPT/rdwttl) The number of terms',
     $      ' (jpfcmx) used in',/7x,'the Pitzer data temperature',
     $      ' function is not 8, as is required',/7x,'in the case',
     $      ' of the case of the Greenberg-Moller combination',
     $      /7x,'temperature function (jptffl = 1).')
            nerr = nerr + 1
          endif
        endif
c
        if (jptffl .eq. 0) then
          if (jpfcmx.lt.1 .or. jpfcmx.gt.5) then
            write (noutpt,1540)
            write (nttyo,1540)
 1540       format(/' * Error - (EQPT/rdwttl) The number of terms',
     $      ' terms (jpfcmx)',/7x,'used in the LLNL maximal five-term',
     $      ' temperature equation (jptffl = 0)',/7x,'is not in the',
     $      ' allowed range of of 1-5. ')
            nerr = nerr + 1
          endif
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (uakey(1:8) .eq. 'Pitzer  ') then
c
c       Write the flag for the temperature function used to represent
c       Pitzer interaction coefficients.
c
        ux56 = 'Pitzer parameter temperature function'
        write (ndata1) ux56
        j2 = ilnobl(ux56)
        write (ndat1f,1450) ux56(1:j2)
c
        write (ndata1) jptffl
        write (ndat1f,1460) jptffl
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      write (ndat1f,1220) utermc(1:72)
 1220 format(a)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nerr .gt. 0) stop
c
      go to 999
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  990 write (noutpt,2000)
      write (nttyo,2000)
 2000 format(/' * Error - (EQPT/rdwttl) Unexpectedly encountered',
     $ /7x,'end-of-file while reading the title of the DATA0 file.')
      if (n .le. 1) then
        write (noutpt,2010)
        write (nttyo,2010)
 2010   format(/7x,'This occurred while trying to read the first line',
     $  /7x,'of the title.')
      else
        ulbufa = utitld(n - 1)
        call lejust(ulbufa)
        j2 = ilnobl(ulbufa)
        j2 = min(j2,70)
        write (noutpt,2020) ulbufa(1:j2)
        write (nttyo,2020) ulbufa(1:j2)
 2020   format(/7x,'This occurred while trying to read the line',
     $  ' following',/7x,'the line:',/7x,'"',a,'"')
      endif
      stop
c
  995 write (noutpt,2030)
      write (nttyo,2030)
 2030 format(/' * Error - (EQPT/rdwttl) Encountered a read format',
     $ /7x,'error while reading the DATA0 file.')
      if (n .le. 1) then
        write (noutpt,2010)
        write (nttyo,2010)
      else
        ulbufa = utitld(n - 1)
        call lejust(ulbufa)
        j2 = ilnobl(ulbufa)
        j2 = min(j2,70)
        write (noutpt,2020) ulbufa(1:j2)
      endif
      stop
c
  997 ulbufa = utitld(n)
      call lejust(ulbufa)
      j2 = ilnobl(ulbufa)
      j2 = min(j2,70)
      write (noutpt,2050) ulbufa(1:j2)
      write (nttyo,2050) ulbufa(1:j2)
 2050 format(/' * Error - (EQPT/rdwttl) Encountered a read format',
     $ /7x,'error while reading data embedded in the title of the',
     $ /7x,'DATA0 file. This occurred while attempting to process',
     $ ' the line:',/7x,'"',a,'"')
      stop
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine rxnchk(cdrs,cess,mtotr,nbt,nbtmx1,nbtmx2,nco,
     $ nct,nctmax,nerr,noutpt,ns,nsb,nttyo,uelem,uspec,zchar)
c
c     This suboutine checks the reaction associated with the ns-th
c     species for mass and charge balance. If an imbalance is found,
c     a message is written to the screen and output files.
c
c     This suboutine is called by:
c
c       EQPT/pcraq.f
c       EQPT/pcrsg.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       cdrs   = array of reaction coefficients
c       cess   = array of elemental composition coefficients
c       nbt    = the number of basis species
c       nct    = the number of chemical elements
c       nerr   = cumulative error counter
c       uelem  = array of chemical element names
c       uspec  = array of species names
c       zchar  = array of electrical charge numbers
c
c     Principal output:
c
c       nerr   = cumulative error counter
c
c     Workspace:
c
c       mtotr  = array of mass balance residuals
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer nbtmx1,nbtmx2
c
      integer noutpt,nttyo
c
      integer nbt,nco,nct,nctmax,nerr,ns,nsb
c
      character*24 uspec(nbtmx1)
      character*8 uelem(nctmax)
      character*8 ux8
c
      real*8 cdrs(nbtmx2,nbtmx1),cess(nctmax,nbtmx1),mtotr(nctmax),
     $ zchar(nbtmx1)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      logical qbadr,qo2gx
c
      integer j2,j3,nbt1,nc,nfile,nlim,nse
c
      integer ilnobl
c
      real*8 mx,rxntol,ztotr
c
c-----------------------------------------------------------------------
c
      data rxntol /1.e-6/
c
c-----------------------------------------------------------------------
c
      qbadr = .false.
c
      qo2gx = uspec(nsb) .eq. 'O2(g)'
      if (qo2gx) cess(nco,nsb) = 2.
c
      nlim = ns - 1
      nlim = min(nlim,nbt)
      nbt1 = nbt + 1
c
      ztotr = cdrs(nbt1,ns)*zchar(ns)
      do nse = 1,nlim
        ztotr = ztotr + cdrs(nse,ns)*zchar(nse)
      enddo
      if (abs(ztotr) .gt. rxntol) qbadr = .true.
c
      do nc = 1,nct
        mx = cdrs(nbt1,ns)*cess(nc,ns)
        do nse = 1,nlim
          mx = mx + cdrs(nse,ns)*cess(nc,nse)
        enddo
        mtotr(nc) = mx
        if (abs(mx) .gt. rxntol) qbadr = .true.
      enddo
c
      if (qo2gx) cess(nco,nsb) = 0.
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (qbadr) then
c
c       Have a reaction with one or more imbalances.
c
        j2 = ilnobl(uspec(ns))
        write (noutpt,1000) uspec(ns)(1:j2)
        write (nttyo,1000) uspec(ns)(1:j2)
 1000   format(/' * Error - (EQPT/rxnchk) The reaction for the',
     $  ' destruction of',/7x,a,' has the following imbalances:',/)
        if (abs(ztotr) .gt. rxntol) then
          ux8 = 'charge'
          j3 = ilnobl(ux8)
          write (noutpt,1010) ztotr,ux8(1:j3)
          write (nttyo,1010) ztotr,ux8(1:j3)
 1010     format(9x,1pe12.5,' in ',a)
        endif
        do nc = 1,nct
          if (abs(mtotr(nc)) .gt. rxntol) then
            ux8 = uelem(nc)
            j3 = ilnobl(ux8)
            write (noutpt,1010) mtotr(nc),ux8(1:j3)
            write (nttyo,1010) mtotr(nc),ux8(1:j3)
          endif
        enddo
        write (noutpt,1020)
        write (nttyo,1020)
 1020   format(/9x,'The reaction is:')
        nfile = noutpt
        call prrecy(cdrs,nbtmx1,nbtmx2,nbt,ns,nfile,uspec)
        nfile = nttyo
        call prrecy(cdrs,nbtmx1,nbtmx2,nbt,ns,nfile,uspec)
        nerr = nerr + 1
      endif
c
      end
      subroutine rxnsck(nbtmx1,cdrsi,nct,ndrsts,nentri,nerr,noutpt,
     $ ns,nsb,nttyo,qblkrs,qzerrs,udrsi,usblkf,uspec)
c
c     This subroutine conducts tests on the associated reaction
c     specified for a species. It detects any blank and duplicate
c     species names in the reaction and any zero-valued reaction
c     coefficients. It checks to see if the first species in the
c     reaction is the one formally associated with it, and that
c     The corresponding coefficient is negative.
c
c     Note: any blank names are replaced by the string '<blank>'.
c
c     This subroutine is called by:
c
c       eqpt/pcraq.f
c       eqpt/pcrsg.f
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer nbtmx1
c
      integer noutpt,nttyo
c
      integer nentri(nbtmx1)
c
      integer nct,ndrsts,nerr,ns,nsb
c
      logical qblkrs,qzerrs
c
      character(len=24) udrsi(nbtmx1),uspec(nbtmx1)
      character(len=24) usblkf
c
      real(8) cdrsi(nbtmx1)
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer j2,j3,j4,n,ncount
c
      integer ilnobl
c
      logical qduprs
c
      character*24 ux24
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Check for blank element names.
c
      qblkrs = .false.
      ncount = 0
      do n = 1,ndrsts
        j3 = ilnobl(udrsi(n))
        if (j3 .le. 0) then
          ncount = ncount + 1
          udrsi(n) = '<blank>'
        endif
      enddo
c
      if (ncount .gt. 0) then
        j2 = ilnobl(uspec(ns))
        j4 = ilnobl(usblkf)
        write (noutpt,1000) uspec(ns)(1:j2),usblkf(1:j4)
        write (nttyo,1000) uspec(ns)(1:j2),usblkf(1:j4)
 1000   format(/' * Error - (eqpt/rxnsck) The species ',a,
     $  ' appearing',/7x,'on the data file in the ',a,' superblock',
     $  ' has a specified',/7x,'reaction with blank species names',
     $  ' in the following positions:',/)
        do n = 1,ndrsts
          if (udrsi(n)(1:7) .eq. '<blank>') then
            write (ux8,'(i5)') n
            call lejust(ux8)
            j4 = ilnobl(ux8)
            write (noutpt,1010) ux8(1:j4)
            write (nttyo,1010) ux8(1:j4)
 1010       format(9x,a)
          endif
        enddo
        qblkrs = .true.
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for a species appearing more than once in the reaction
c
      call nrxnck(nbtmx1,ndrsts,nentri,nerr,qduprs,udrsi)
c
      if (qduprs) then
c
c       Make an exception for the reaction O2(g) = O2(g) when
c       in the gases superblock and O2(g) is the redox species.
c       Here the O2(g) on the left-hand side is an actual gas
c       species, while that on the right is actually the
c       fictive aqueous species.
c
        if (usblkf(1:5) .eq. 'gases') then
          if (uspec(ns)(1:6) .eq. 'O2(g) ') then
            if (nsb .eq. (nct + 1)) then
              if (uspec(nsb)(1:6) .eq. 'O2(g) ') then
                if (ndrsts .eq. 2) then
                  if (udrsi(1)(1:6) .eq. 'O2(g) ') then
                    if (udrsi(2)(1:6) .eq. 'O2(g) ') then
                      qduprs = .false.
                      nentri(1) = 1
                      nentri(2) = 1
                    endif
                  endif
                endif
              endif
            endif
          endif
        endif
      endif
c
      if (qduprs)  then
        j2 = ilnobl(uspec(ns))
        j4 = ilnobl(usblkf)
        write (noutpt,1040) uspec(ns)(1:j2),usblkf(1:j4)
        write (nttyo,1040) uspec(ns)(1:j2),usblkf(1:j4)
 1040   format(/' * Error - (eqpt/rxnsck) The species ',a,
     $  ' appearing',/7x,'on the data file in the ',a,' superblock',
     $  ' has a specified',/7x,'reaction for which there is more',
     $  ' than one entry for the following',/7x,'species(s):',/)
        do n = 1,ndrsts
          if (nentri(n) .gt. 1) then
            write (ux8,'(i5)') nentri(n)
            call lejust(ux8)
            j3 = ilnobl(ux8)
            j4 = ilnobl(udrsi(n))
            write (noutpt,1050) udrsi(n)(1:j4),ux8(1:j3)
            write (nttyo,1050) udrsi(n)(1:j4),ux8(1:j3)
 1050       format(9x,a,' (',a,' entries)')
          endif
        enddo
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for zero-valued stoichiometric coefficients.
c
      qzerrs = .false.
      do n = 1,ndrsts
        if (cdrsi(n) .eq. 0.) qzerrs = .true.
      enddo
c
      if (qzerrs) then
        j2 = ilnobl(uspec(ns))
        j4 = ilnobl(usblkf)
        write (noutpt,1080) uspec(ns)(1:j2),usblkf(1:j4)
        write (nttyo,1080) uspec(ns)(1:j2),usblkf(1:j4)
 1080     format(/' * Error - (eqpt/rxnsck) The species ',a,
     $    ' appearing',/7x,'on the data file in the ',a,' superblock',
     $    ' has an associated',/7x,'reaction with zero-valued',
     $    ' coefficients for the following species:',/)
        do n = 1,ndrsts
          if (cdrsi(n) .eq. 0.) then
            ux24 = udrsi(n)
            j3 = ilnobl(ux24)
            write (noutpt,1090) ux24(1:j3)
            write (nttyo,1090) ux24(1:j3)
 1090       format(9x,a)
          endif
        enddo
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c       Check the name of the species as it appears in the associated
c       reaction. A species must appear first in its associated
c       reaction.
c
        if (ndrsts .ge. 2) then
          if (uspec(ns)(1:24) .ne. udrsi(1)(1:24)) then
            j2 = ilnobl(uspec(ns))
            j4 = ilnobl(usblkf)
            ux24 = udrsi(1)
            j3 = ilnobl(ux24)
            write (noutpt,1210) uspec(ns)(1:j2),usblkf(1:j4),
     $      ux24(1:j3),uspec(ns)(1:j2)
            write (nttyo,1210) uspec(ns)(1:j2),usblkf(1:j4),
     $      ux24(1:j3),uspec(ns)(1:j2)
 1210       format(/' * Error - (eqpt/rxnsck) The species ',a,
     $      ' appearing',/7x,'on the data file in the ',a,' superblock',
     $      ' does not appear',/7x,'in its associated reaction.',
     $      ' Should "',a,'" in the',/7x,'reaction be "',a,'", or',
     $      ' vice versa?')
            nerr = nerr + 1
          else
c
c           Check to see that the associated reaction coefficient is
c           negative.
c
            if (cdrsi(1) .ge. 0.) then
              j2 = ilnobl(uspec(ns))
              j4 = ilnobl(usblkf)
              write (noutpt,1220) uspec(ns)(1:j2),usblkf(1:j4),cdrsi(1)
              write (nttyo,1220) uspec(ns)(1:j2),usblkf(1:j4),cdrsi(1)
 1220         format(/' * Error - (eqpt/rxnsck) The species ',a,
     $        ' appearing',/7x,'on the data file in the ',a,
     $        ' superblock does not have a',/7x,'negative reaction',
     $        ' coefficient, as is required. The coefficient',
     $        /7x,'has a value of ',1pe12.5,'.')
              nerr = nerr + 1
            endif
          endif
        endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 return
      end
      subroutine srch22(jpair,unam1,unam2,upair,npx2mx,npx2t)
c
c     This subroutine searches for the species pair corresponding
c     to unam1, unam2 or unam2, unam1 in the upair array, and returns
c     the index jpair of that pair in that aray. The variable jpair
c     is returned as 0 if no match is found.
c
c     This suboutine is called by:
c
c       EQPT/tprca.f
c       EQPT/tprn2.f
c       EQPT/tprnn.f
c       EQPT/tprnc.f
c       EQPT/tprna.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       npx2t  = number of species pairs in the upair array
c       unam1  = the name of the first aqueous species in a pair
c       unam2  = the name of the second aqueous species in a pair
c       upair  = array containing the names of species in a pair
c
c     Principal output:
c
c       jpair  = the index of the pair unam1, unam2 or unam2, unam1 in
c                  the upair array, if that pair is present; else 0
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer npx2mx
c
      integer jpair,npx2t
c
      character*24 unam1,unam2
      character*24 upair(2,npx2mx)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer j
c
c-----------------------------------------------------------------------
c
c     Search the upair array for an element matching (unam1, unam2).
c
      do j = 1,npx2t
        if (unam1(1:24) .eq. upair(1,j)(1:24)) then
c
c         Look for unam2 in the matching position in the upair array.
c
          if (unam2(1:24) .eq. upair(2,j)(1:24)) then
            jpair = j
            go to 999
          endif
        endif
      enddo
c
c     Search the upair array for an element matching (unam2, unam1).
c
      do j = 1,npx2t
        if (unam2(1:24) .eq. upair(1,j)(1:24)) then
c
c         Look for unam1 in the matching position in the upair array.
c
          if (unam1(1:24) .eq. upair(2,j)(1:24)) then
            jpair = j
            go to 999
          endif
        endif
      enddo
c
c     Did not find the pair in the upair array.
c
      jpair = 0
c
  999 continue
      end
      subroutine srch33(jtripl,unam1,unam2,unam3,utripl,npx3mx,npx3t)
c
c     This subroutine searches for the species triplet corresponding
c     to unam1, unam2, unam3 in the utripl array, and returns the
c     index jtripl of that triplet in that array. The variable jtripl
c     is returned as 0 if no match is found. The species names in
c     the triplet array must be in the same order to generate a match.
c
c     This subroutine is called by:
c
c       EQPT/wrpz3.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       npx3t  = the number of aqueous species triplets in the utripl
c                  array
c       unam1  = the name of the first aqueous species in a triplet
c       unam2  = the name of the second aqueous species in a triplet
c       unam3  = the name of the third aqueous species in a triplet
c       utripl = array of aqueous species triplets
c
c     Principal output:
c
c       jtripl = the index of the triplet unam1, unam2, unam3 in the
c                  utripl array, if that triplet is present; else 0
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer npx3mx
c
      integer jtripl,npx3t
c
      character(len=24) unam1,unam2,unam3
      character(len=24) utripl(3,npx3mx)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer j
c
c-----------------------------------------------------------------------
c
      do j = 1,npx3t
        if (unam1(1:24) .eq. utripl(1,j)(1:24)) then
          if (unam2(1:24) .eq. utripl(2,j)(1:24)) then
            if (unam3(1:24) .eq. utripl(3,j)(1:24)) then
c
c             Found in the triplet in the utripl array.
c
              jtripl = j
              go to 999
            endif
          endif
        endif
      enddo
c
c     Did not find the triplet in the utripl array.
c
      jtripl = 0
c
  999 continue
      end
      subroutine tegrid(itgenf,nacdpr,narxt,nerr,noutpt,ntprmx,
     $ ntprt,nttyo,nwarn,ustrgr)
c
c     This subroutine tests the contents of a "log K" temperature
c     grid for sparse contents in any range. The response to an
c     instance of sparseness is determined by the variable
c     itgenf (-1 = ignore, 0 = warn, 1 = error). This subroutine
c     need not be called if itgenf = -1.
c
c     This suboutine is called by:
c
c       EQPT/rdpar.f
c       EQPT/pcraq.f
c       EQPT/pcrsg.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       itgenf = integer flag controlling the response to a detected
c                  incidence of sparseness (-1 = ignore, 0 = warn,
c                  1 = error)
c       nacdpr = array giving the number of points containing actual
c                  data in a temperature range for the "log K" grid
c                  currently being examined
c       narxt  = array giving the number of points (actual data plus
c                  no data) in that range
c       ntprt  = the number of ranges in the current "log K" grid
c       ustrgr = string describing what the grid represents
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ntprmx
c
      integer noutpt,nttyo
c
      integer itgenf,nerr,ntprt,nwarn
c
      integer nacdpr(ntprmx),narxt(ntprmx)
c
      character(len=56) ustrgr
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer j2,j3,j4,ntpr
c
      logical qx
c
      integer ilnobl
c
      character(len=8) ux8a,ux8b
c
c-----------------------------------------------------------------------
c
      do ntpr = 1,ntprt
c
        if (narxt(ntpr) .le. 3) then
c
c         For a range with up to three grid points, at least two
c         must contain actual data. Note that a range can not
c         be composed of fewer than two grid points.
c
          qx = nacdpr(ntpr) .lt. 2
        else
c
c         Otherwise, at least three points containing actual data
c         are required.
c
          qx = nacdpr(ntpr) .lt. 3
        endif
c
        if (qx .and. itgenf.ge.0) then
          write (ux8a,'(i5)') nacdpr(ntpr)
          call lejust(ux8a)
          j2 = ilnobl(ux8a)
          write (ux8b,'(i5)') ntpr
          call lejust(ux8b)
          j3 = ilnobl(ux8b)
          call lejust(ustrgr)
          j4 = ilnobl(ustrgr)
          if (itgenf .eq. 0) then
            nwarn = nwarn + 1
            if (nacdpr(ntpr) .gt. 0) then
              write (noutpt,1000) ux8a(1:j2),ux8b(1:j3),ustrgr(1:j4)
              write (nttyo,1000) ux8a(1:j2),ux8b(1:j3),ustrgr(1:j4)
 1000         format(/' * Warning - (EQPT/tegrid) The number of grid',
     $        ' points containing actual',/7x,'data is only ',a,' in',
     $        ' range ',a,' of the temperature grid representing',
     $        /7x,a,'.')
            else
              write (noutpt,1010) ux8b(1:j3),ustrgr(1:j4)
              write (nttyo,1010) ux8b(1:j3),ustrgr(1:j4)
 1010         format(/' * Warning - (EQPT/tegrid) There are no grid',
     $        ' points containing actual',/7x,'data in range ',a,
     $        ' of the temperature grid representing',/7x,a,'.')
            endif
          else
            nerr = nerr + 1
            if (nacdpr(ntpr) .gt. 0) then
              write (noutpt,1030) ux8a(1:j2),ux8b(1:j3),ustrgr(1:j4)
              write (nttyo,1030) ux8a(1:j2),ux8b(1:j3),ustrgr(1:j4)
 1030         format(/' * Error - (EQPT/tegrid) The number of grid',
     $        ' points containing actual',/7x,'data is only ',a,' in',
     $        ' range ',a,' of the temperature grid representing',
     $        /7x,a,'.')
            else
              write (noutpt,1040) ux8b(1:j3),ustrgr(1:j4)
              write (nttyo,1040) ux8b(1:j3),ustrgr(1:j4)
 1040         format(/' * Error - (EQPT/tegrid) There are no grid',
     $        ' points containing actual',/7x,'data in range ',a,
     $        ' of the temperature grid representing',/7x,a,'.')
            endif
          endif
        endif
      enddo
c
  999 continue
      end
      subroutine thetck(athetx,jpfcmx,na,nc,nerr,nn,noutpt,nttyo,
     $ n1,n2,n3,unam1,unam2,unam3)
c
c     This suboutine checks data that were read from the S-theta
c     fields of the DATA0 file.
c
c     This suboutine is called by:
c
c       EQPT/rdpz3.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       na     = number of anions in a species triplet
c       nc     = number of cations in a species triplet
c       nn     = number of neutral species in a species triplet
c       n1     = index of the first species in a triplet
c       n2     = index of the second species in a triplet
c       n3     = index of the third species in a triplet
c       unam1  = first name in a species triplet
c       unam2  = second name in a species triplet
c       unam3  = third name in a species triplet
c
c     Principal output:
c
c       nerr   = error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer jpfcmx
c
      integer noutpt,nttyo
c
      integer na,nc,nn,nerr,n1,n2,n3
c
      character*24 unam1,unam2,unam3
c
      real*8 athetx(jpfcmx)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer j,j2,j3,j4
c
      integer ilnobl
c
      logical qzethx
c
c-----------------------------------------------------------------------
c
c     Check for erroneous data in the thetax data.
c
c
      qzethx = .true.
      do j = 1,jpfcmx
        if (athetx(j) .ne. 0.) qzethx = .false.
      enddo
c
      if (.not.qzethx) then
c
        if (nn .eq. 3) then
c
c         Note: the unique neutral is assumed to be the third
c         species in the triplet.
c
          if (n1.eq.n2 .and. n3.ne.n1) then
c
c           Have an nnn' combination.
c
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            j4 = ilnobl(unam3)
            write (noutpt,1400) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1400) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1400       format(/' * Error - (EQPT/thetck) Have found an illegal',
     $      ' data block for the',/7x,'species triplet ',a,', ',a,
     $      ', ',a,' among the blocks for',/7x,'"mixture parameters".',
     $      ' Have non-zero input for lambda data in the',
     $      /7x,'"theta" field. Only mu data may be specified (in',
     $      ' the "psi" field)',/7x,'in a block of this type. This',
     $      " is an nnn' combination. Enter the",/7x,'corresponding',
     $      " lambda(nn') data",' in a "single-salt parameters" block,',
     $      /7x,'using the "beta0" field. Leave the'," mu(nnn') data",
     $      ' in the present',/7x,'"mixture parameters" block (in the',
     $      ' "psi" field). Enter the',/7x,"corresponding mu(n'n'n)",
     $      ' data in a second "mixture parameters" block',
     $      /7x,'(in the "psi" field).')
            nerr = nerr + 1
          endif
        endif
c
        if (nn.eq.1 .and. nc.eq.1 .and. na.eq.1) then
c
c         Have an nca combination.
c
          j2 = ilnobl(unam1)
          j3 = ilnobl(unam2)
          j4 = ilnobl(unam3)
          write (noutpt,1410) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1410) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1410     format(/' * Error - (EQPT/thetck) Have found an illegal',
     $    ' data block for the',/7x,'species triplet ',a,', ',a,
     $    ', ',a,' among the blocks for',/7x,'"mixture parameters".',
     $    ' Have non-zero input for lambda data in the',/7x,'"theta"',
     $    ' field. Only zeta data may be specified (in the "psi"',
     $    ' field)',/7x,'in a block of this type. This is an nca',
     $    ' combination. Enter the',/7x,'corresponding lambda(nc)',
     $    ' and lambda(na) data in separate',/7x,'"single-salt',
     $    ' parameters" blocks, using the "beta0" fields.',
     $    /7x,'Leave the zeta(nca) data in the present "mixture',
     $    ' parameters"',/7x,'block (in the "psi" field).')
          nerr = nerr + 1
        endif
c
      endif
c
      end
      subroutine tpraa(alamaa,atheta,iaapr,ipbtmx,jpfcmx,naapr,
     $ natmax,ncvaa,nerr,noutpt,npx3mx,nthdt,nttyo,nwarn,pcvaa,
     $ qpdaa,uaqsp,uthdtr)
c
c     Test and process the Pitzer data for aa' (anion, different
c     anion) pairs read from the DATA0 file. Find and flag errors,
c     such as duplication of data (e.g., two data blocks for the same
c     aa' pair). Calculate the conventional primitive Pitzer parameters
c     from the observable compound parameters read from the data file:
c
c       theta(aa') -> lambda(aa')
c
c     Check the coverage of entered Pitzer data against all possible
c     anion-distinct anion pairs that can be composed of the aqueous
c     anions present on the data file.
c
c     This subroutine is complementary to tprcc.f, which does the
c     same thing for cc' (cation, different cation) pairs.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,naapr,natmax,npx3mx
c
      integer noutpt,nttyo
c
      integer iaapr(2,naapr)
c
      integer ncvaa,nerr,nthdt,nwarn
c
      logical qpdaa(naapr)
c
      character(len=24) uaqsp(natmax),uthdtr(3,npx3mx)
c
      real*8 alamaa(jpfcmx,0:ipbtmx,naapr),atheta(jpfcmx,npx3mx)
c
      real*8 pcvaa
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,j,jth,jthpr,j2,j3,j4,j5,n,ncount,ndupl,nlistl,
     $ nn,nodatc
c
      integer ilnobl
c
      logical qmatch,qzerov
c
      character*56 ustr56
      character*24 unam1,unam2
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Limit on the list of pairs for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Initialize the data arrays.
c
      do n = 1,naapr
        qpdaa(n) = .false.
        do j = 1,jpfcmx
          do i = 0,ipbtmx
            alamaa(j,i,n) = 0.
          enddo
        enddo
      enddo
c
c     Check the entered data for aa' pairs.
c
      nodatc = 0
c
      do n = 1,naapr
        i = iaapr(1,n)
        j = iaapr(2,n)
        unam1 = uaqsp(i)
        unam2 = uaqsp(j)
c
        jthpr = 0
        ndupl = 0
c
c       Search for unam1, unam2 in the species triplet blocks.
c       This is actually done by searching the uthdtr array,
c       not the utripl array.
c
        do jth = 1,nthdt
          if (unam1(1:24) .eq. uthdtr(1,jth)(1:24)) then
            if (unam2(1:24) .eq. uthdtr(2,jth)(1:24)) then
              jthpr = jth
              go to 110
            endif
          endif
        enddo
  110   continue
c
        if (jthpr .gt. 0) then
c
c         Have found an entry in the triplet blocks.
c
          qpdaa(n) = .true.
c
c         Store the data.
c
          do j = 1,jpfcmx
            alamaa(j,0,n) = atheta(j,jthpr)
            do i = 1,ipbtmx
              alamaa(j,i,n) = 0.
            enddo
          enddo
c
c         Search for duplicates in the species triplets blocks.
c         Ignore duplications in the triplet blocks if the
c         values are all zeros (take this to mean "no data input")
c         or if the values all match the first-encountered
c         values (exact duplication).
c
          do jth = jthpr + 1,nthdt
            if (unam1(1:24) .eq. uthdtr(1,jth)(1:24)) then
              if (unam2(1:24) .eq. uthdtr(2,jth)(1:24)) then
                qzerov = .true.
                do j = 1,jpfcmx
                  if (atheta(j,jth) .ne. 0.) qzerov = .false.
                enddo
                qmatch = .true.
                do j = 1,jpfcmx
                  if ((atheta(j,jth) - atheta(j,jthpr)) .gt. 1.e-6)
     $            qmatch = .false.
                enddo
                if (.not.qzerov .and. .not.qmatch)
     $          ndupl = ndupl + 1
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam2(1:j3)
              write (nttyo,1010) unam1(1:j2),unam2(1:j3)
 1010         format(/' * Error - (EQPT/tpraa) Have found a',
     $        ' duplicate data block on the DATA0 file',
     $        /7x,"for the aa' pair ",a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j5 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
              write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
 1020         format(/' * Error - (EQPT/tpraa) Have found ',a,
     $        ' duplicate data blocks on the DATA0 file',
     $        /7x,"for the aa' pair ",a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
        endif
c
        if (jthpr.le.0) then
c
c         No data block was found on the DATA0 file.
c         Note that qpdaa(n) is left with a value of .false.
c
          nodatc = nodatc + 1
        endif
c
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1040)
        write (nttyo,1040)
 1040   format(/' * Warning - (EQPT/tpraa) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  " aa' pairs:",/)
c
        ncount = 0
        do n = 1,naapr
          if (.not.qpdaa(n)) then
            ncount = ncount + 1
            i = iaapr(1,n)
            j = iaapr(2,n)
            unam1 = uaqsp(i)
            unam2 = uaqsp(j)
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            ustr56 = unam1(1:j2) // ', ' // unam2(1:j3)
            j4 = ilnobl(ustr56)
            write (noutpt,1050) ustr56(1:j4)
            write (nttyo,1050) ustr56(1:j4)
 1050       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1060) ux8(1:j3)
          write (nttyo,1060) ux8(1:j3)
 1060     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1070)
        write (nttyo,1070)
 1070   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvaa = naapr - nodatc
      pcvaa = (100.*ncvaa)/float(naapr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
c
      end
      subroutine tpraac(amuaac,amua2c,apsi,iaactr,icapr,ipbtmx,
     $ jpfcmx,naactr,natmax,na2ctr,ncapr,ncvaac,nerr,noutpt,
     $ npx3mx,npx3t,nttyo,nwarn,pcvaac,qpdaac,qpdca,uaqsp,
     $ utripl,zaqsp)
c
c     Test and process the Pitzer data for aa'c (anion, different
c     anion, cation) triplets read from the DATA0 file. Find and flag
c     errors, such as duplication of data (e.g., two data blocks for
c     the same aa'c triplet). Calculate the conventional primitive
c     Pitzer parameters from the observable compound parameters read
c     from the data file:
c
c       psi(aa'c) -> mu(aa'c)
c
c     Note: mu(aa'c) depends on cphi(ca) and cphi(c'a) as well as
c     psi(aa'c).
c
c     Check the coverage of entered Pitzer data against all possible
c     aa'c triplets that can be composed of the cations and anions
c     present on the data file.
c
c     This subroutine is complementary to tprcca.f, which does the
c     same thing for cc'a (cation, different cation, anion) triplets.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,naactr,natmax,na2ctr,ncapr,npx3mx
c
      integer noutpt,nttyo
c
      integer iaactr(3,naactr),icapr(2,ncapr)
c
      integer ncvaac,nerr,npx3t,nwarn
c
      logical qpdaac(naactr),qpdca(ncapr)
c
      character(len=24) uaqsp(natmax),utripl(3,npx3mx)
c
      real*8 apsi(jpfcmx,npx3mx),amuaac(jpfcmx,naactr),
     $ amua2c(jpfcmx,na2ctr),zaqsp(natmax)
c
      real*8 pcvaac
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ii,j,jj,jt,jtripl,j2,j3,j4,j5,j6,k,n,ncount,ndupl,
     $ nlistl,nn,nodatc
c
      integer ilnobl
c
      logical qfound1,qfound2
c
      character(len=80) ustr80
      character(len=24) unam1,unam2,unam3
      character(len=8) ux8
c
      real(8), dimension(:), allocatable :: amu1,amu2
c
      real(8) z1,z2
c
c-----------------------------------------------------------------------
c
c     Limit on the list of triplets for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Allocate work space arrays.
c
      ALLOCATE(amu1(jpfcmx))
      ALLOCATE(amu2(jpfcmx))
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Initialize the data arrays.
c
      do n = 1,naactr
        qpdaac(n) = .false.
        do j = 1,jpfcmx
          amuaac(j,n) = 0.
        enddo
      enddo
c
c     Check the entered data for aa'c triplets.
c
      nodatc = 0
c
      do n = 1,naactr
        i = iaactr(1,n)
        j = iaactr(2,n)
        k = iaactr(3,n)
        unam1 = uaqsp(i)
        unam2 = uaqsp(j)
        unam3 = uaqsp(k)
        j2 = ilnobl(unam1)
        j3 = ilnobl(unam2)
        j4 = ilnobl(unam3)
        z1 = zaqsp(i)
        z2 = zaqsp(j)
c
c       Search for unam1, unam2, unam3 in the utripl array.
c       That array corresponds to the species triplets blocks.
c
        call srch33(jtripl,unam1,unam2,unam3,utripl,npx3mx,npx3t)
c
        if (jtripl .le. 0) then
c
c         No data block was found on the DATA0 file.
c         Note that qpdaac(n) is left with a value of .false.
c
          nodatc = nodatc + 1
c
        else
c
c         Have found an entry.
c
          qpdaac(n) = .true.
c
c         Check for duplicate data sets.
c
          ndupl = 0
          do jt = jtripl + 1,npx3t
            if (unam1(1:24) .eq. utripl(1,jt)(1:24)) then
              if (unam2(1:24) .eq. utripl(2,jt)(1:24)) then
                if (unam3(1:24) .eq. utripl(3,jt)(1:24)) then
                  ndupl = ndupl + 1
                endif
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam2(1:j3),unam3(1:j4)
              write (nttyo,1010) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1010         format(/' * Error - (EQPT/tpraac) Have found a',
     $        ' duplicate data block',/7x,'on the DATA0 file',
     $        " for the aa'c triplet",/7x,a,', ',a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j6 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j6),unam1(1:j2),unam2(1:j3),
     $        unam3(1:j4)
              write (nttyo,1020) ux8(1:j6),unam1(1:j2),unam2(1:j3),
     $        unam3(1:j4)
 1020         format(/' * Error - (EQPT/tpraac) Have found ',a,
     $        ' duplicate data blocks',/7x,'on the DATA0 file',
     $        " for the aa'c triplet",/7x,a,', ',a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
c
c         Get the data for the two constituent binary systems.
c
          qfound1 = .false.
          do j = 1,jpfcmx
            amu1(j) = 0.
          enddo
c
          do nn = 1,ncapr
            ii = icapr(1,nn)
            if (uaqsp(ii)(1:24) .eq. unam3(1:24)) then
              jj = icapr(2,nn)
              if (uaqsp(jj)(1:24) .eq. unam1(1:24)) then
                if (qpdca(nn)) then
                  qfound1 = .true.
                  do j = 1,jpfcmx
                    amu1(j) = amua2c(j,nn)
                  enddo
                  go to 130
                endif
              endif
            endif
          enddo
  130     continue
c
          qfound2 = .false.
          do j = 1,jpfcmx
            amu2(j) = 0.
          enddo
c
          do nn = 1,ncapr
            ii = icapr(1,nn)
            if (uaqsp(ii)(1:24) .eq. unam3(1:24)) then
              jj = icapr(2,nn)
              if (uaqsp(jj)(1:24) .eq. unam2(1:24)) then
                if (qpdca(nn)) then
                  qfound2 = .true.
                  do j = 1,jpfcmx
                    amu2(j) = amua2c(j,nn)
                  enddo
                  go to 140
                endif
              endif
            endif
          enddo
  140     continue
c
          if (qfound1 .and. qfound2) then
            do j = 1,jpfcmx
              amuaac(j,n) = (apsi(j,jtripl) +
     $        3.0*((z2/z1)*amu1(j) + (z1/z2)*amu2(j)))/6.
            enddo
          else
c
c           Certain required data were not found on the DATA0 file.
c
            write (noutpt,1030) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1030) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1030       format(/' * Error - (EQPT/tpraac) Have data on the DATA0',
     $      " file for the aa'c",/7x,'triplet ',a,', ',a,', ',a,', but',
     $      " don't have the",/7x,'required data for the following',
     $      ' cation-anion pair(s):',/)
c
            if (.not.qfound1) then
              write (noutpt,1040) unam3(1:j2),unam1(1:j4)
              write (nttyo,1040) unam3(1:j2),unam1(1:j4)
 1040         format(9x,a,', ',a)
            endif
c
            if (.not.qfound2) then
              write (noutpt,1040) unam3(1:j3),unam1(1:j4)
              write (nttyo,1040) unam3(1:j3),unam1(1:j4)
            endif
c
            nerr = nerr + 1
          endif
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1060)
        write (nttyo,1060)
 1060   format(/' * Warning - (EQPT/tpraac) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  " aa'c triplets:",/)
c
        ncount = 0
        do n = 1,naactr
          if (.not.qpdaac(n)) then
            ncount = ncount + 1
            i = iaactr(1,n)
            j = iaactr(2,n)
            k = iaactr(3,n)
            unam1 = uaqsp(i)
            unam2 = uaqsp(j)
            unam3 = uaqsp(k)
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            j4 = ilnobl(unam3)
            ustr80 = unam1(1:j2) // ', ' // unam2(1:j3) // ', ' //
     $      unam3(1:j4)
            j5 = ilnobl(ustr80)
            write (noutpt,1070) ustr80(1:j5)
            write (nttyo,1070) ustr80(1:j5)
 1070       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1080) ux8(1:j3)
          write (nttyo,1080) ux8(1:j3)
 1080     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1090)
        write (nttyo,1090)
 1090   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvaac = naactr - nodatc
      pcvaac = (100.*ncvaac)/float(naactr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Deallocate work space arrays.
c
      DEALLOCATE(amu1)
      DEALLOCATE(amu2)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine tpraz(nat,natmax,nazt,naztmx,ncvaz,nerr,noutpt,nttyo,
     $ pcvaz,qpdaz,uaqsp,uazp)
c
c     Test and process the hard core diameter (azero) and neutral
c     activity coefficient flag (insgf) data (i.e., the 'bdot' data)
c     read from the DATA0 file. Find and flag errors, such as duplication
c     of data (e.g., two entries for the same aqueous species).
c
c     Check the coverage of entered data against all aqueous solute
c     species present on the data file.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       nazt   = the number of specified hard core diameters
c       uaqsp  = array of names of aqueous species
c       uazp   = array of aqueous species names used to specify
c                  hard core diamters on the data file
c
c     Principal output:
c
c       nerr   = error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer natmax,naztmx
c
      integer noutpt,nttyo
c
      integer nat,nazt,ncvaz,nerr
c
      logical qpdaz(natmax)
c
      character*24 uaqsp(natmax),uazp(naztmx)
c
      real*8 pcvaz
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer jaz,j2,j3,j4,j5,na,naz,ncount,ndupl,nlistl,nn,nodatc
c
      integer ilnobl
c
      character*24 unam
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Limit on the list of aqueous species for which no data
c     were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Initialize the qpdaz array. A value of .false. for a species
c     means that no azero or insgf data for this species were read
c     from the data file. Solvent water (the first aqueous species)
c     does not have such data, so set the flag to .true. for this
c     species.
c
      qpdaz(1) = .true.
      do na = 2,nat
        qpdaz(na) = .false.
      enddo
c
c     Check the entered azero and insgf data for aqueous species.
c
      nodatc = 0
c
      do na = 2,nat
c
c       Search for uaqsp(na) in the uazp array. That array contains
c       the aqueous species names for which azero and insgf data
c       were read from the data file.
c
        unam = uaqsp(na)
        do naz = 1,nazt
          if (unam(1:24) .eq. uazp(naz)(1:24)) go to 100
        enddo
        naz = 0
  100   continue
c
        if (naz .gt. 0) then
c
c         Have found an entry.
c
          qpdaz(na) = .true.
c
c         Check for duplicate data sets.
c
          ndupl = 0
          do jaz = naz + 1,nazt
            if (unam(1:24) .eq. uazp(jaz)(1:24)) then
              ndupl = ndupl + 1
            endif
          enddo
c
          if (ndupl .gt. 0) then
            j2 = ilnobl(unam)
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam(1:j2)
              write (nttyo,1010) unam(1:j2)
 1010         format(/' * Error - (EQPT/tpraz) Have found a duplicate',
     $        ' entry on the DATA0 file',/7x,'for the hard core',
     $        ' diameter of ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j5 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j5),unam(1:j2)
              write (nttyo,1020) ux8(1:j5),unam(1:j2)
 1020         format(/' * Error - (EQPT/tpraz) Have found ',a,
     $        ' duplicate entries on the DATA0 file',
     $        /7x,'for the hard core diameter of ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
c
        else
c
c         No data entry was found on the DATA0 file.
c         Note that qpdaz(na) is left with a value of .false.
c
          nodatc = nodatc + 1
        endif
c
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1040)
        write (nttyo,1040)
 1040   format(/' * Warning - (EQPT/tpraz) Did not find a hard core',
     $  ' diameter entry on the',/7x,'DATA0 file for any of the',
     $  ' following aqueous species:',/)
c
        ncount = 0
        do na = 1,nat
          if (.not.qpdaz(na)) then
            ncount = ncount + 1
            unam = uaqsp(na)
            j4 = ilnobl(unam)
            write (noutpt,1050) unam(1:j4)
            write (nttyo,1050) unam(1:j4)
 1050       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1060) ux8(1:j3)
          write (nttyo,1060) ux8(1:j3)
 1060     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1070)
        write (nttyo,1070)
 1070   format(1x)
      endif
c
      ncvaz = nat - nodatc - 1
      pcvaz = (100.*ncvaz)/float(nat - 1)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine tprca(abeta,acphi,alamca,alpha,alphca,amua2c,amuc2a,
     $ icapr,ipbtmx,jpfcmx,natmax,na2ctr,ncapr,ncvca,nc2atr,nerr,
     $ noutpt,npx2mx,npx2t,nttyo,nwarn,pcvca,qpdca,uaqsp,upair,zaqsp)
c
c     Test and process the Pitzer data for ca (cation, anion) pairs
c     read from the DATA0 file. Find and flag errors, such as duplication
c     of data (e.g., two data blocks for the same ca pair). Calculate
c     the conventional primitive Pitzer parameters from the observable
c     compound parameters read from the data file:
c
c       beta(n)(ca) -> lambda(n)(ca)   (n = 0,2)
c       Cphi(ca)    -> mu(cca) and mu(aac)
c
c     Check the coverage of entered Pitzer data against all possible
c     ca pairs that can be composed of the aqueous cations and anions
c     present on the data file.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,na2ctr,ncapr,nc2atr,npx2mx
c
      integer noutpt,nttyo
c
      integer icapr(2,ncapr)
c
      integer ncvca,nerr,npx2t,nwarn
c
      logical qpdca(ncapr)
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real*8 abeta(jpfcmx,0:ipbtmx,npx2mx),acphi(jpfcmx,npx2mx),
     $ alamca(jpfcmx,0:ipbtmx,ncapr),alphca(ipbtmx,ncapr),
     $ alpha(2,npx2mx),amua2c(jpfcmx,na2ctr),amuc2a(jpfcmx,nc2atr),
     $ zaqsp(natmax)
c
      real*8 pcvca
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,j,jp,jpair,j2,j3,j4,j5,n,ncount,ndupl,nlistl,nn,
     $ nodatc
c
      integer ilnobl
c
      character*56 ustr56
      character*24 unam1,unam2
      character*8 ux8
c
      real*8 fmuc2a,fmua2c,z1,z2
c
c-----------------------------------------------------------------------
c
c     Limit on the list of pairs for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Initialize the data arrays.
c
      do n = 1,ncapr
        qpdca(n) = .false.
        do i = 1,ipbtmx
          alphca(i,n) = 0.
        enddo
      enddo
c
      do n = 1,ncapr
        do i = 0,ipbtmx
          do j = 1,jpfcmx
            alamca(j,i,n) = 0.
          enddo
        enddo
      enddo
c
      do n = 1,ncapr
        do j = 1,jpfcmx
          amuc2a(j,n) = 0.
          amua2c(j,n) = 0.
        enddo
      enddo
c
c     Check the entered data for ca pairs.
c
      nodatc = 0
c
      do n = 1,ncapr
        i = icapr(1,n)
        j = icapr(2,n)
        unam1 = uaqsp(i)
        unam2 = uaqsp(j)
        z1 = zaqsp(i)
        z2 = zaqsp(j)
c
c       Search for unam1, unam2 in the upair array.
c       That array corresponds to the species pairs blocks.
c
        call srch22(jpair,unam1,unam2,upair,npx2mx,npx2t)
c
        if (jpair .gt. 0) then
c
c         Have found an entry.
c
          qpdca(n) = .true.
c
c         Store the data.
c
          do i = 1,ipbtmx
            alphca(i,n) = alpha(i,jpair)
          enddo
c
          do i = 0,ipbtmx
            do j = 1,jpfcmx
              alamca(j,i,n) = abeta(j,i,jpair)
            enddo
          enddo
c
          fmuc2a = sqrt(-z1/z2)/6.
          fmua2c = sqrt(-z2/z1)/6.
c
          do j = 1,jpfcmx
            amuc2a(j,n)   = acphi(j,jpair)*fmuc2a
            amua2c(j,n)   = acphi(j,jpair)*fmua2c
          enddo
c
c         Check for duplicate data sets.
c
          ndupl = 0
          do jp = jpair + 1,npx2t
            if (unam1(1:24) .eq. upair(1,jp)(1:24)) then
              if (unam2(1:24) .eq. upair(2,jp)(1:24)) then
                ndupl = ndupl + 1
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam2(1:j3)
              write (nttyo,1010) unam1(1:j2),unam2(1:j3)
 1010         format(/' * Error - (EQPT/tprca) Have found a duplicate',
     $        ' data block on the DATA0 file',/7x,'for the ca pair ',
     $        a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j5 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
              write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
 1020         format(/' * Error - (EQPT/tprca) Have found ',a,
     $        ' duplicate data blocks on the DATA0 file',
     $        /7x,'for the ca pair ',a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
c
        else
c
c         No data block was found on the DATA0 file.
c         Note that qpdca(n) is left with a value of .false.
c
          nodatc = nodatc + 1
        endif
c
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1040)
        write (nttyo,1040)
 1040   format(/' * Warning - (EQPT/tprca) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  ' ca pairs:',/)
c
        ncount = 0
        do n = 1,ncapr
          if (.not.qpdca(n)) then
            ncount = ncount + 1
            i = icapr(1,n)
            j = icapr(2,n)
            unam1 = uaqsp(i)
            unam2 = uaqsp(j)
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            ustr56 = unam1(1:j2) // ', ' // unam2(1:j3)
            j4 = ilnobl(ustr56)
            write (noutpt,1050) ustr56(1:j4)
            write (nttyo,1050) ustr56(1:j4)
 1050       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1060) ux8(1:j3)
          write (nttyo,1060) ux8(1:j3)
 1060     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1070)
        write (nttyo,1070)
 1070   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvca = ncapr - nodatc
      pcvca = (100.*ncvca)/float(ncapr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine tprcc(alamcc,atheta,iccpr,ipbtmx,jpfcmx,natmax,
     $ nccpr,ncvcc,nerr,noutpt,npx3mx,nthdt,nttyo,nwarn,pcvcc,
     $ qpdcc,uaqsp,uthdtr)
c
c     Test and process the Pitzer data for cc' (cation, different
c     cation) pairs read from the DATA0 file. Find and flag errors,
c     such as duplication of data (e.g., two data blocks for the same
c     cc' pair). Calculate the conventional primitive Pitzer parameters
c     from the observable compound parameters read from the data file:
c
c       theta(cc') -> lambda(cc')
c
c     Check the coverage of entered Pitzer data against all possible
c     cation-distinct cation pairs that can be composed of the aqueous
c     cations present on the data file.
c
c     This subroutine is complementary to tpraa.f, which does the
c     same thing for aa' (anion, different anion) pairs.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,nccpr,npx3mx
c
      integer noutpt,nttyo
c
      integer iccpr(2,nccpr)
c
      integer ncvcc,nerr,nthdt,nwarn
c
      logical qpdcc(nccpr)
c
      character(len=24) uaqsp(natmax),uthdtr(3,npx3mx)
c
      real*8 alamcc(jpfcmx,0:ipbtmx,nccpr),atheta(jpfcmx,npx3mx)
c
      real*8 pcvcc
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,j,jth,jthpr,j2,j3,j4,j5,n,ncount,ndupl,nlistl,
     $ nn,nodatc
c
      integer ilnobl
c
      logical qmatch,qzerov
c
      character*56 ustr56
      character*24 unam1,unam2
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Limit on the list of pairs for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Initialize the data arrays.
c
      do n = 1,nccpr
        qpdcc(n) = .false.
        do j = 1,jpfcmx
          do i = 0,ipbtmx
            alamcc(j,i,n) = 0.
          enddo
        enddo
      enddo
c
c     Check the entered data for cc' pairs.
c
      nodatc = 0
c
      do n = 1,nccpr
        i = iccpr(1,n)
        j = iccpr(2,n)
        unam1 = uaqsp(i)
        unam2 = uaqsp(j)
c
        jthpr = 0
        ndupl = 0
c
c       Search for unam1, unam2 in the species triplet blocks.
c       This is actually done by searching the uthdtr array,
c       not the utripl array.
c
        do jth = 1,nthdt
          if (unam1(1:24) .eq. uthdtr(1,jth)(1:24)) then
            if (unam2(1:24) .eq. uthdtr(2,jth)(1:24)) then
              jthpr = jth
              go to 110
            endif
          endif
        enddo
  110   continue
c
        if (jthpr .gt. 0) then
c
c         Have found an entry in the triplet blocks.
c
          qpdcc(n) = .true.
c
c         Store the data.
c
          do j = 1,jpfcmx
            alamcc(j,0,n) = atheta(j,jthpr)
            do i = 1,ipbtmx
              alamcc(j,i,n) = 0.
            enddo
          enddo
c
c         Search for duplicates in the species triplets blocks.
c         Ignore duplications in the triplet blocks if the
c         values are all zeros (take this to mean "no data input")
c         or if the values all match the first-encountered
c         values (exact duplication).
c
          do jth = jthpr + 1,nthdt
            if (unam1(1:24) .eq. uthdtr(1,jth)(1:24)) then
              if (unam2(1:24) .eq. uthdtr(2,jth)(1:24)) then
                qzerov = .true.
                do j = 1,jpfcmx
                  if (atheta(j,jth) .ne. 0.) qzerov = .false.
                enddo
                qmatch = .true.
                do j = 1,jpfcmx
                  if ((atheta(j,jth) - atheta(j,jthpr)) .gt. 1.e-6)
     $            qmatch = .false.
                enddo
                if (.not.qzerov .and. .not.qmatch)
     $          ndupl = ndupl + 1
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam2(1:j3)
              write (nttyo,1010) unam1(1:j2),unam2(1:j3)
 1010         format(/' * Error - (EQPT/tprcc) Have found a',
     $        ' duplicate data block on the DATA0 file',
     $        /7x,"for the cc' pair ",a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j5 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
              write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
 1020         format(/' * Error - (EQPT/tprcc) Have found ',a,
     $        ' duplicate data blocks on the DATA0 file',
     $        /7x,"for the cc' pair ",a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
        endif
c
        if (jthpr.le.0) then
c
c         No data block was found on the DATA0 file.
c         Note that qpdcc(n) is left with a value of .false.
c
          nodatc = nodatc + 1
        endif
c
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1040)
        write (nttyo,1040)
 1040   format(/' * Warning - (EQPT/tprcc) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  " cc' pairs:",/)
c
        ncount = 0
        do n = 1,nccpr
          if (.not.qpdcc(n)) then
            ncount = ncount + 1
            i = iccpr(1,n)
            j = iccpr(2,n)
            unam1 = uaqsp(i)
            unam2 = uaqsp(j)
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            ustr56 = unam1(1:j2) // ', ' // unam2(1:j3)
            j4 = ilnobl(ustr56)
            write (noutpt,1050) ustr56(1:j4)
            write (nttyo,1050) ustr56(1:j4)
 1050       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1060) ux8(1:j3)
          write (nttyo,1060) ux8(1:j3)
 1060     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1070)
        write (nttyo,1070)
 1070   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvcc = nccpr - nodatc
      pcvcc = (100.*ncvcc)/float(nccpr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
c
      end
      subroutine tprcca(amucca,amuc2a,apsi,icapr,iccatr,ipbtmx,
     $ jpfcmx,natmax,ncapr,nccatr,ncvcca,nc2atr,nerr,noutpt,
     $ npx3mx,npx3t,nttyo,nwarn,pcvcca,qpdca,qpdcca,uaqsp,
     $ utripl,zaqsp)
c
c     Test and process the Pitzer data for cc'a (cation, different
c     cation, anion) triplets read from the DATA0 file. Find and flag
c     errors, such as duplication of data (e.g., two data blocks for
c     the same cc'a triplet). Calculate the conventional primitive
c     Pitzer parameters from the observable compound parameters read
c     from the data file:
c
c       psi(cc'a) -> mu(cc'a)
c
c     Note: mu(cc'a) depends on cphi(ca) and cphi(c'a) as well as
c     psi(cc'a).
c
c     Check the coverage of entered Pitzer data against all possible
c     cc'a triplets that can be composed of the cations and anions
c     present on the data file.
c
c     This subroutine is complementary to tpraac.f, which does the
c     same thing for aa'c (anion, different anion, cation) triplets.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,ncapr,nccatr,nc2atr,npx3mx
c
      integer noutpt,nttyo
c
      integer icapr(2,ncapr),iccatr(3,nccatr)
c
      integer ncvcca,nerr,npx3t,nwarn
c
      logical qpdca(ncapr),qpdcca(nccatr)
c
      character(len=24) uaqsp(natmax),utripl(3,npx3mx)
c
      real*8 apsi(jpfcmx,npx3mx),amucca(jpfcmx,nccatr),
     $ amuc2a(jpfcmx,nc2atr),zaqsp(natmax)
c
      real*8 pcvcca
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ii,j,jj,jt,jtripl,j2,j3,j4,j5,j6,k,n,ncount,ndupl,
     $ nlistl,nn,nodatc
c
      integer ilnobl
c
      logical qfound1,qfound2
c
      character(len=80) ustr80
      character(len=24) unam1,unam2,unam3
      character(len=8) ux8
c
      real(8), dimension(:), allocatable :: amu1,amu2
c
      real(8) z1,z2
c
c-----------------------------------------------------------------------
c
c     Limit on the list of triplets for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Allocate work space arrays.
c
      ALLOCATE(amu1(jpfcmx))
      ALLOCATE(amu2(jpfcmx))
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Initialize the data arrays.
c
      do n = 1,nccatr
        qpdcca(n) = .false.
        do j = 1,jpfcmx
          amucca(j,n) = 0.
        enddo
      enddo
c
c     Check the entered data for cc'a triplets.
c
      nodatc = 0
c
      do n = 1,nccatr
        i = iccatr(1,n)
        j = iccatr(2,n)
        k = iccatr(3,n)
        unam1 = uaqsp(i)
        unam2 = uaqsp(j)
        unam3 = uaqsp(k)
        j2 = ilnobl(unam1)
        j3 = ilnobl(unam2)
        j4 = ilnobl(unam3)
        z1 = zaqsp(i)
        z2 = zaqsp(j)
c
c       Search for unam1, unam2, unam3 in the utripl array.
c       That array corresponds to the species triplets blocks.
c
        call srch33(jtripl,unam1,unam2,unam3,utripl,npx3mx,npx3t)
c
        if (jtripl .le. 0) then
c
c         No data block was found on the DATA0 file.
c         Note that qpdcca(n) is left with a value of .false.
c
          nodatc = nodatc + 1
c
        else
c
c         Have found an entry.
c
          qpdcca(n) = .true.
c
c         Check for duplicate data sets.
c
          ndupl = 0
          do jt = jtripl + 1,npx3t
            if (unam1(1:24) .eq. utripl(1,jt)(1:24)) then
              if (unam2(1:24) .eq. utripl(2,jt)(1:24)) then
                if (unam3(1:24) .eq. utripl(3,jt)(1:24)) then
                  ndupl = ndupl + 1
                endif
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam2(1:j3),unam3(1:j4)
              write (nttyo,1010) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1010         format(/' * Error - (EQPT/tprcca) Have found a',
     $        ' duplicate data block',/7x,'on the DATA0 file',
     $        " for the cc'a triplet",/7x,a,', ',a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j6 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j6),unam1(1:j2),unam2(1:j3),
     $        unam3(1:j4)
              write (nttyo,1020) ux8(1:j6),unam1(1:j2),unam2(1:j3),
     $        unam3(1:j4)
 1020         format(/' * Error - (EQPT/tprcca) Have found ',a,
     $        ' duplicate data blocks',/7x,'on the DATA0 file',
     $        " for the cc'a triplet",/7x,a,', ',a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
c
c         Get the data for the two constituent binary systems.
c
          qfound1 = .false.
          do j = 1,jpfcmx
            amu1(j) = 0.
          enddo
c
          do nn = 1,ncapr
            ii = icapr(1,nn)
            if (uaqsp(ii)(1:24) .eq. unam1(1:24)) then
              jj = icapr(2,nn)
              if (uaqsp(jj)(1:24) .eq. unam3(1:24)) then
                if (qpdca(nn)) then
                  qfound1 = .true.
                  do j = 1,jpfcmx
                    amu1(j) = amuc2a(j,nn)
                  enddo
                  go to 130
                endif
              endif
            endif
          enddo
  130     continue
c
          qfound2 = .false.
          do j = 1,jpfcmx
            amu2(j) = 0.
          enddo
c
          do nn = 1,ncapr
            ii = icapr(1,nn)
            if (uaqsp(ii)(1:24) .eq. unam2(1:24)) then
              jj = icapr(2,nn)
              if (uaqsp(jj)(1:24) .eq. unam3(1:24)) then
                if (qpdca(nn)) then
                  qfound2 = .true.
                  do j = 1,jpfcmx
                    amu2(j) = amuc2a(j,nn)
                  enddo
                  go to 140
                endif
              endif
            endif
          enddo
  140     continue
c
          if (qfound1 .and. qfound2) then
            do j = 1,jpfcmx
              amucca(j,n) = (apsi(j,jtripl) +
     $        3.0*((z2/z1)*amu1(j) + (z1/z2)*amu2(j)))/6.
            enddo
          else
c
c           Certain required data were not found on the DATA0 file.
c
            write (noutpt,1030) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1030) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1030       format(/' * Error - (EQPT/tprcca) Have data on the DATA0',
     $      " file for the cc'a",/7x,'triplet ',a,', ',a,', ',a,', but',
     $      " don't have the",/7x,'required data for the following',
     $      ' cation-anion pair(s):',/)
c
            if (.not.qfound1) then
              write (noutpt,1040) unam1(1:j2),unam3(1:j4)
              write (nttyo,1040) unam1(1:j2),unam3(1:j4)
 1040         format(9x,a,', ',a)
            endif
c
            if (.not.qfound2) then
              write (noutpt,1040) unam2(1:j3),unam3(1:j4)
              write (nttyo,1040) unam2(1:j3),unam3(1:j4)
            endif
c
            nerr = nerr + 1
          endif
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1060)
        write (nttyo,1060)
 1060   format(/' * Warning - (EQPT/tprcca) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  " cc'a triplets:",/)
c
        ncount = 0
        do n = 1,nccatr
          if (.not.qpdcca(n)) then
            ncount = ncount + 1
            i = iccatr(1,n)
            j = iccatr(2,n)
            k = iccatr(3,n)
            unam1 = uaqsp(i)
            unam2 = uaqsp(j)
            unam3 = uaqsp(k)
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            j4 = ilnobl(unam3)
            ustr80 = unam1(1:j2) // ', ' // unam2(1:j3) // ', ' //
     $      unam3(1:j4)
            j5 = ilnobl(ustr80)
            write (noutpt,1070) ustr80(1:j5)
            write (nttyo,1070) ustr80(1:j5)
 1070       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1080) ux8(1:j3)
          write (nttyo,1080) ux8(1:j3)
 1080     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1090)
        write (nttyo,1090)
 1090   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvcca = nccatr - nodatc
      pcvcca = (100.*ncvcca)/float(nccatr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Deallocate work space arrays.
c
      DEALLOCATE(amu1)
      DEALLOCATE(amu2)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine tprn2(abeta,acphi,alamn2,amun3,in2pr,ipbtmx,
     $ jpfcmx,natmax,ncvn2,nerr,nn2pr,nn3tr,noutpt,npx2mx,npx2t,
     $ nttyo,nwarn,pcvn2,qpdn2,uaqsp,upair)
c
c     Test and process Pitzer data read from the data file that
c     pertain to a single neutral species (nn and nnn combinations,
c     such as CO2(aq)-CO2(aq) and CO2(aq)-CO2(aq)-CO2(aq). Find and
c     flag errors, such as duplication of data (e.g., two data
c     blocks for the same pair composed of a repeated neutral).
c     The conventional primitive Pitzer parameters are identical
c     to the observable parameters read from the data file:
c
c       lambda(nn) -> lambda(nn)
c       mu(nnn)    -> mu(nnn)
c
c     Check the coverage of entered Pitzer data against all possible
c     pairs that can be composed by repeating a neutral species present
c     on the data file.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,nn2pr,nn3tr,npx2mx
c
      integer noutpt,nttyo
c
      integer in2pr(nn2pr)
c
      integer ncvn2,nerr,npx2t,nwarn
c
      logical qpdn2(nn2pr)
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real*8 abeta(jpfcmx,0:ipbtmx,npx2mx),acphi(jpfcmx,npx2mx),
     $ alamn2(jpfcmx,0:ipbtmx,nn2pr),amun3(jpfcmx,nn3tr)
c
      real*8 pcvn2
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,j,jp,jpair,j2,j3,j4,j5,n,ncount,ndupl,nlistl,
     $ nn,nodatc
c
      integer ilnobl
c
      character*56 ustr56
      character*24 unam1
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Limit on the list of pairs for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Initialize the data arrays.
c
      do n = 1,nn2pr
        qpdn2(n) = .false.
        do j = 1,jpfcmx
          do i = 0,ipbtmx
            alamn2(j,i,n) = 0.
          enddo
        enddo
      enddo
c
c     Note: nn3tr = nn2pr.
c
      do n = 1,nn3tr
        do j = 1,jpfcmx
          amun3(j,n) = 0.
        enddo
      enddo
c
c     Check the entered data for nn pairs.
c
      nodatc = 0
c
      do n = 1,nn2pr
        i = in2pr(n)
        unam1 = uaqsp(i)
c
c       Search for unam1 in the upair array.
c
        call srch22(jpair,unam1,unam1,upair,npx2mx,npx2t)
c
        if (jpair .gt. 0) then
c
c         Have found an entry.
c
          qpdn2(n) = .true.
c
c         Store the data.
c
          do j = 1,jpfcmx
            do i = 0,ipbtmx
              alamn2(j,i,n) = abeta(j,i,jpair)
            enddo
          enddo
c
          do j = 1,jpfcmx
            amun3(j,n)   = acphi(j,jpair)
          enddo
c
c         Check for duplicate data sets.
c
          ndupl = 0
          do jp = jpair + 1,npx2t
            if (unam1(1:24) .eq. upair(1,jp)(1:24)) then
              if (unam1(1:24) .eq. upair(2,jp)(1:24)) then
                ndupl = ndupl + 1
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            j2 = ilnobl(unam1)
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam1(1:j2)
              write (nttyo,1010) unam1(1:j2),unam1(1:j2)
 1010         format(/' * Error - (EQPT/tprn2) Have found a',
     $        ' duplicate data block on the DATA0 file',
     $        /7x,'for the nn pair ',a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j5 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam1(1:j2)
              write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam1(1:j2)
 1020         format(/' * Error - (EQPT/tprn2) Have found ',a,
     $        ' duplicate data blocks on the DATA0 file',
     $        /7x,'for the nn pair ',a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
c
        else
c
c         No data block was found on the DATA0 file.
c         Note that qpdn2(n) is left with a value of .false.
c
          nodatc = nodatc + 1
        endif
c
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1050)
        write (nttyo,1050)
 1050   format(/' * Warning - (EQPT/tprn2) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  ' nn pairs:',/)
c
        ncount = 0
        do n = 1,nn2pr
          if (.not.qpdn2(n)) then
            ncount = ncount + 1
            i = in2pr(n)
            unam1 = uaqsp(i)
            j2 = ilnobl(unam1)
            ustr56 = unam1(1:j2) // ', ' // unam1(1:j2)
            j4 = ilnobl(ustr56)
            write (noutpt,1060) ustr56(1:j4)
            write (nttyo,1060) ustr56(1:j4)
 1060       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1070) ux8(1:j3)
          write (nttyo,1070) ux8(1:j3)
 1070     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1080)
        write (nttyo,1080)
 1080   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvn2 = nn2pr - nodatc
      pcvn2 = (100.*ncvn2)/float(nn2pr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine tprn2n(amun2n,apsi,innpr,in2pr,in2ntr,ipbtmx,
     $ jpfcmx,natmax,ncvn2n,nerr,nnnpr,nn2pr,nn2ntr,noutpt,npx3mx,
     $ npx3t,nttyo,nwarn,pcvn2n,qpdnn,qpdn2,qpdn2n,uaqsp,utripl)
c
c     Test and process the Pitzer data for nnn' (neutral, same neutral,
c     different neutral) triplets read from the DATA0 file. Find and
c     flag errors, such as duplication of data (e.g., two data blocks
c     for the same repeated neutral-distinct neutral triplet). The
c     conventional primitive Pitzer parameters are identical to the
c     observable parameters read from the data file:
c
c       mu(nnn') -> mu(nnn')
c
c     Note that there are two mu parameters mu(nnn') and mu(n'n'n)
c     for each corresponding lambda parameter lambda(nn'). Both are
c     handled in one set.
c
c     Check the coverage of entered Pitzer data against all possible
c     nnn' triplets that can be composed of the neutral species present
c     on the data file.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,nnnpr,nn2ntr,nn2pr,npx3mx
c
      integer noutpt,nttyo
c
      integer innpr(2,nnnpr),in2pr(nn2pr),in2ntr(2,nn2ntr)
c
      integer ncvn2n,nerr,npx3t,nwarn
c
      logical qpdnn(nnnpr),qpdn2(nn2pr),qpdn2n(nn2ntr)
c
      character(len=24) uaqsp(natmax),utripl(3,npx3mx)
c
      real*8 amun2n(jpfcmx,nn2ntr),apsi(jpfcmx,npx3mx)
c
      real*8 pcvn2n
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ii,j,jj,jt,jtripl,j2,j3,j4,j5,j6,k,n,ncount,ndupl,
     $ nlistl,nn,nodatc
c
      integer ilnobl
c
      logical qfound1,qfound2,qfound3
c
      character*80 ustr80
      character*24 unam1,unam2,unam3
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Limit on the list of triplets for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Initialize the data arrays.
c
      do n = 1,nn2ntr
        qpdn2n(n) = .false.
        do j = 1,jpfcmx
          amun2n(j,n) = 0.
        enddo
      enddo
c
c     Check the entered data for nnn' triplets.
c
      nodatc = 0
c
      do n = 1,nn2ntr
        i = in2ntr(1,n)
        j = in2ntr(1,n)
        k = in2ntr(2,n)
        unam1 = uaqsp(i)
        unam2 = uaqsp(j)
        unam3 = uaqsp(k)
        j2 = ilnobl(unam1)
        j3 = ilnobl(unam2)
        j4 = ilnobl(unam3)
c
c       Search for unam1, unam2, unam3 in the utripl array.
c       That array corresponds to the species triplets blocks.
c
        call srch33(jtripl,unam1,unam2,unam3,utripl,npx3mx,npx3t)
c
        if (jtripl .le. 0) then
c
c
c         No data block was found on the DATA0 file.
c         Note that qpdn2n(n) is left with a value of .false.
c
          nodatc = nodatc + 1
        else
c
c         Have found an entry.
c
          qpdn2n(n) = .true.
c
c         Store the data.
c
          do j = 1,jpfcmx
            amun2n(j,n) = apsi(j,jtripl)
          enddo
c
c         Check for duplicate data sets.
c
          ndupl = 0
          do jt = jtripl + 1,npx3t
            if (unam1(1:24) .eq. utripl(1,jt)(1:24)) then
              if (unam2(1:24) .eq. utripl(2,jt)(1:24)) then
                if (unam3(1:24) .eq. utripl(3,jt)(1:24)) then
                  ndupl = ndupl + 1
                endif
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam2(1:j3),unam3(1:j4)
              write (nttyo,1010) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1010         format(/' * Error - (EQPT/tprn2n) Have found a',
     $        ' duplicate data block on the DATA0 file',
     $        /7x,"for the nnn' triplet ",a,', ',a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j6 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j6),unam1(1:j2),unam2(1:j3),
     $        unam3(1:j4)
              write (nttyo,1020) ux8(1:j6),unam1(1:j2),unam2(1:j3),
     $        unam3(1:j4)
 1020         format(/' * Error - (EQPT/tprn2n) Have found ',a,
     $        ' duplicate data blocks on the DATA0 file',
     $        /7x,"for the nnn' triplet ",a,', ',a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
c
c         Check for the presence of the corresponding lamda(nn),
c         lambda(n'n'), and lambda(nn')  data. The presence of these
c         data on the data file is required.
c
          qfound1 = .false.
c
          do nn = 1,nn2pr
            ii = in2pr(nn)
            if (uaqsp(ii)(1:24) .eq. unam1(1:24)) then
              if (qpdn2(nn)) then
                qfound1 = .true.
                go to 130
              endif
            endif
          enddo
  130     continue
c
          qfound2 = .false.
c
          do nn = 1,nn2pr
            ii = in2pr(nn)
            if (uaqsp(ii)(1:24) .eq. unam3(1:24)) then
              if (qpdn2(nn)) then
                qfound2 = .true.
                go to 140
              endif
            endif
          enddo
  140     continue
c
          qfound3 = .false.
c
          if (unam1 .lt. unam3) then
            do nn = 1,nnnpr
              ii = innpr(1,nn)
              if (uaqsp(ii)(1:24) .eq. unam1(1:24)) then
                jj = innpr(2,nn)
                if (uaqsp(jj)(1:24) .eq. unam3(1:24)) then
                  if (qpdnn(nn)) then
                    qfound3 = .true.
                    go to 150
                  endif
                endif
              endif
            enddo
  150       continue
          else
            do nn = 1,nnnpr
              ii = innpr(1,nn)
              if (uaqsp(ii)(1:24) .eq. unam3(1:24)) then
                jj = innpr(2,nn)
                if (uaqsp(jj)(1:24) .eq. unam1(1:24)) then
                  if (qpdnn(nn)) then
                    qfound3 = .true.
                    go to 160
                  endif
                endif
              endif
            enddo
  160       continue
          endif
c
          if (.not.(qfound1 .and. qfound2 .and. qfound3)) then
c
c           Certain required data were not found on the DATA0 file.
c
            write (noutpt,1030) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1030) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1030       format(/' * Error - (EQPT/tprn2n) Have data on the DATA0',
     $      " file for the nnn'",/7x,'triplet ',a,', ',a,', ',a,', but',
     $      " don't have the",/7x,'required data for the following',
     $      ' neutral-neutral pair(s):',/)
c
            if (.not.qfound1) then
              write (noutpt,1040) unam1(1:j2),unam1(1:j2)
              write (nttyo,1040) unam1(1:j2),unam1(1:j2)
 1040         format(9x,a,', ',a)
            endif
c
            if (.not.qfound2) then
              write (noutpt,1040) unam3(1:j4),unam3(1:j4)
              write (nttyo,1040) unam3(1:j4),unam3(1:j4)
            endif
c
            if (.not.qfound3) then
              write (noutpt,1040) unam1(1:j2),unam3(1:j4)
              write (nttyo,1040) unam1(1:j2),unam3(1:j4)
            endif
c
            nerr = nerr + 1
          endif
        endif
c
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1050)
        write (nttyo,1050)
 1050   format(/' * Warning - (EQPT/tprn2n) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  " nnn' triplets:",/)
c
        ncount = 0
        do n = 1,nn2ntr
          if (.not.qpdn2n(n)) then
            ncount = ncount + 1
            i = in2ntr(1,n)
            j = in2ntr(1,n)
            k = in2ntr(2,n)
            unam1 = uaqsp(i)
            unam2 = uaqsp(j)
            unam3 = uaqsp(k)
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            j4 = ilnobl(unam3)
            ustr80 = unam1(1:j2) // ', ' // unam2(1:j3) //
     $      ', ' // unam3(1:j4)
            j5 = ilnobl(ustr80)
            write (noutpt,1060) ustr80(1:j5)
            write (nttyo,1060) ustr80(1:j5)
 1060       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1070) ux8(1:j3)
          write (nttyo,1070) ux8(1:j3)
 1070     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1080)
        write (nttyo,1080)
 1080   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvn2n = nn2ntr - nodatc
      pcvn2n = (100.*ncvn2n)/float(nn2ntr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine tprna(abeta,alamna,inapr,ipbtmx,jpfcmx,natmax,
     $ ncvna,nerr,nnapr,noutpt,npx2mx,npx2t,nttyo,nwarn,pcvna,
     $ qpdna,uaqsp,upair)
c
c     Test and process the na (neutral, anion) pair Pitzer data read
c     from the DATA0 file. Find and flag errors, such as duplication of
c     data (e.g., two data blocks for the same na pair). The
c     conventional primitive Pitzer parameters are identical to the
c     observable parameters read from the data file:
c
c       lambda(na) -> lambda(na)
c
c     Check the coverage of entered Pitzer data against all possible
c     na pairs that can be composed of the aqueous neutral species and
c     anions present on the data file.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,nnapr,npx2mx
c
      integer noutpt,nttyo
c
      integer inapr(2,nnapr)
c
      integer ncvna,nerr,npx2t,nwarn
c
      logical qpdna(nnapr)
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real*8 abeta(jpfcmx,0:ipbtmx,npx2mx),
     $ alamna(jpfcmx,0:ipbtmx,nnapr)
c
      real*8 pcvna
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,j,jp,jpair,j2,j3,j4,j5,n,ncount,ndupl,nlistl,
     $ nn,nodatc
c
      integer ilnobl
c
      character*56 ustr56
      character*24 unam1,unam2
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Limit on the list of pairs for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Initialize the data arrays.
c
      do n = 1,nnapr
        qpdna(n) = .false.
        do j = 1,jpfcmx
          do i = 0,ipbtmx
            alamna(j,i,n) = 0.
          enddo
        enddo
      enddo
c
c     Check the entered data for na pairs.
c
      nodatc = 0
c
      do n = 1,nnapr
        i = inapr(1,n)
        j = inapr(2,n)
        unam1 = uaqsp(i)
        unam2 = uaqsp(j)
c
c       Search for unam1, unam2 in the upair array.
c       That array corresponds to the species pairs blocks.
c
        call srch22(jpair,unam1,unam2,upair,npx2mx,npx2t)
c
        if (jpair .gt. 0) then
c
c         Have found an entry.
c
          qpdna(n) = .true.
c
c         Store the data.
c
          do j = 1,jpfcmx
            do i = 0,ipbtmx
              alamna(j,i,n) = abeta(j,i,jpair)
            enddo
          enddo
c
c         Check for duplicate data sets.
c
          ndupl = 0
          do jp = jpair + 1,npx2t
            if (unam1(1:24) .eq. upair(1,jp)(1:24)) then
              if (unam2(1:24) .eq. upair(2,jp)(1:24)) then
                ndupl = ndupl + 1
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam2(1:j3)
              write (nttyo,1010) unam1(1:j2),unam2(1:j3)
 1010         format(/' * Error - (EQPT/tprna) Have found a',
     $        ' duplicate data block on the DATA0 file',
     $        /7x,'for the na pair ',a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j5 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
              write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
 1020         format(/' * Error - (EQPT/tprna) Have found ',a,
     $        ' duplicate data blocks on the DATA0 file',
     $        /7x,'for the na pair ',a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
c
        else
c
c         No data block was found on the DATA0 file.
c         Note that qpdna(n) is left with a value of .false.
c
          nodatc = nodatc + 1
        endif
c
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1040)
        write (nttyo,1040)
 1040   format(/' * Warning - (EQPT/tprna) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  ' na pairs:',/)
c
        ncount = 0
        do n = 1,nnapr
          if (.not.qpdna(n)) then
            ncount = ncount + 1
            i = inapr(1,n)
            j = inapr(2,n)
            unam1 = uaqsp(i)
            unam2 = uaqsp(j)
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            ustr56 = unam1(1:j2) // ', ' // unam2(1:j3)
            j4 = ilnobl(ustr56)
            write (noutpt,1050) ustr56(1:j4)
            write (nttyo,1050) ustr56(1:j4)
 1050       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1060) ux8(1:j3)
          write (nttyo,1060) ux8(1:j3)
 1060     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1070)
        write (nttyo,1070)
 1070   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvna = nnapr - nodatc
      pcvna = (100.*ncvna)/float(nnapr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine tprnc(abeta,alamnc,incpr,ipbtmx,jpfcmx,natmax,
     $ ncvnc,nerr,nncpr,noutpt,npx2mx,npx2t,nttyo,nwarn,pcvnc,
     $ qpdnc,uaqsp,upair)
c
c     Test and process the nc (neutral, cation) pair Pitzer data read
c     from the DATA0 file. Find and flag errors, such as duplication of
c     data (e.g., two data blocks for the same nc pair). The
c     conventional primitive Pitzer parameters are identical to the
c     observable parameters read from the data file:
c
c       lambda(nc) -> lambda(nc)
c
c     Check the coverage of entered Pitzer data against all possible
c     nc pairs that can be composed of the aqueous neutral species and
c     cations present on the data file.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,nncpr,npx2mx
c
      integer noutpt,nttyo
c
      integer incpr(2,nncpr)
c
      integer ncvnc,nerr,npx2t,nwarn
c
      logical qpdnc(nncpr)
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real*8 abeta(jpfcmx,0:ipbtmx,npx2mx),
     $ alamnc(jpfcmx,0:ipbtmx,nncpr)
c
      real*8 pcvnc
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,j,jp,jpair,j2,j3,j4,j5,n,ncount,ndupl,nlistl,
     $ nn,nodatc
c
      integer ilnobl
c
      character*56 ustr56
      character*24 unam1,unam2
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Limit on the list of pairs for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Initialize the data arrays.
c
      do n = 1,nncpr
        qpdnc(n) = .false.
        do j = 1,jpfcmx
          do i = 0,ipbtmx
            alamnc(j,i,n) = 0.
          enddo
        enddo
      enddo
c
c     Check the entered data for nc pairs.
c
      nodatc = 0
c
      do n = 1,nncpr
        i = incpr(1,n)
        j = incpr(2,n)
        unam1 = uaqsp(i)
        unam2 = uaqsp(j)
c
c       Search for unam1, unam2 in the upair array.
c       That array corresponds to the species pairs blocks.
c
        call srch22(jpair,unam1,unam2,upair,npx2mx,npx2t)
c
        if (jpair .gt. 0) then
c
c         Have found an entry.
c
          qpdnc(n) = .true.
c
c         Store the data.
c
          do j = 1,jpfcmx
            do i = 0,ipbtmx
              alamnc(j,i,n) = abeta(j,i,jpair)
            enddo
          enddo
c
c         Check for duplicate data sets.
c
          ndupl = 0
          do jp = jpair + 1,npx2t
            if (unam1(1:24) .eq. upair(1,jp)(1:24)) then
              if (unam2(1:24) .eq. upair(2,jp)(1:24)) then
                ndupl = ndupl + 1
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam2(1:j3)
              write (nttyo,1010) unam1(1:j2),unam2(1:j3)
 1010         format(/' * Error - (EQPT/tprnc) Have found a',
     $        ' duplicate data block on the DATA0 file',
     $        /7x,'for the nc pair ',a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j5 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
              write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
 1020         format(/' * Error - (EQPT/tprnc) Have found ',a,
     $        ' duplicate data blocks on the DATA0 file',
     $        /7x,'for the nc pair ',a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
c
        else
c
c         No data block was found on the DATA0 file.
c         Note that qpdnc(n) is left with a value of .false.
c
          nodatc = nodatc + 1
        endif
c
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1040)
        write (nttyo,1040)
 1040   format(/' * Warning - (EQPT/tprnc) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  ' nc pairs:',/)
c
        ncount = 0
        do n = 1,nncpr
          if (.not.qpdnc(n)) then
            ncount = ncount + 1
            i = incpr(1,n)
            j = incpr(2,n)
            unam1 = uaqsp(i)
            unam2 = uaqsp(j)
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            ustr56 = unam1(1:j2) // ', ' // unam2(1:j3)
            j4 = ilnobl(ustr56)
            write (noutpt,1050) ustr56(1:j4)
            write (nttyo,1050) ustr56(1:j4)
 1050       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1060) ux8(1:j3)
          write (nttyo,1060) ux8(1:j3)
 1060     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1070)
        write (nttyo,1070)
 1070   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvnc = nncpr - nodatc
      pcvnc = (100.*ncvnc)/float(nncpr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine tprnca(amunca,apsi,inapr,incatr,incpr,ipbtmx,
     $ jpfcmx,natmax,ncvnca,nerr,nnapr,nncatr,nncpr,noutpt,npx3mx,
     $ npx3t,nttyo,nwarn,pcvnca,qpdna,qpdnca,qpdnc,uaqsp,utripl)
c
c     Test and process the Pitzer data for nca (neutral, cation,
c     anion) triplets read from the DATA0 file. Find and flag errors,
c     such as duplication of data (e.g., two data blocks for the
c     same nca triplet). Calculate the conventional primitive Pitzer
c     parameters from the observable compound parameters read from
c     the data file:
c
c       zeta(nca) -> mu(nca)
c
c     Check the coverage of entered Pitzer data against all possible
c     nca triplets that can be composed of the neutral species, cations,
c     and anions present on the data file.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,nnapr,nncatr,nncpr,npx3mx
c
      integer noutpt,nttyo
c
      integer inapr(2,nnapr),incatr(3,nncatr),incpr(2,nncpr)
c
      integer ncvnca,nerr,npx3t,nwarn
c
      logical qpdna(nnapr),qpdnca(nncatr),qpdnc(nncpr)
c
      character(len=24) uaqsp(natmax),utripl(3,npx3mx)
c
      real*8 amunca(jpfcmx,nncatr),apsi(jpfcmx,npx3mx)
c
      real*8 pcvnca
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ii,j,jj,jt,jtripl,j2,j3,j4,j5,j6,k,n,ncount,ndupl,
     $ nlistl,nn,nodatc
c
      integer ilnobl
c
      logical qfound1,qfound2
c
      character*80 ustr80
      character*24 unam1,unam2,unam3
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Limit on the list of triplets for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Initialize the data arrays.
c
      do n = 1,nncatr
        qpdnca(n) = .false.
        do j = 1,jpfcmx
          amunca(j,n) = 0.
        enddo
      enddo
c
c     Check the entered data for nca triplets.
c
      nodatc = 0
c
      do n = 1,nncatr
        i = incatr(1,n)
        j = incatr(2,n)
        k = incatr(3,n)
        unam1 = uaqsp(i)
        unam2 = uaqsp(j)
        unam3 = uaqsp(k)
        j2 = ilnobl(unam1)
        j3 = ilnobl(unam2)
        j4 = ilnobl(unam3)
c
c       Search for unam1, unam2, unam3 in the utripl array.
c       That array corresponds to the species triplets blocks.
c
        call srch33(jtripl,unam1,unam2,unam3,utripl,npx3mx,npx3t)
c
        if (jtripl .le. 0) then
c
c         No data block was found on the DATA0 file.
c         Note that qpdnca(n) is left with a value of .false.
c
          nodatc = nodatc + 1
        else
c
c         Have found an entry.
c
          qpdnca(n) = .true.
c
c         Store the data.
c         Note: here "cphi" is really zeta.
c
          do j = 1,jpfcmx
            amunca(j,n) = apsi(j,jtripl)/6.
          enddo
c
c         Check for duplicate data sets.
c
          ndupl = 0
          do jt = jtripl + 1,npx3t
            if (unam1(1:24) .eq. utripl(1,jt)(1:24)) then
              if (unam2(1:24) .eq. utripl(2,jt)(1:24)) then
                if (unam3(1:24) .eq. utripl(3,jt)(1:24)) then
                  ndupl = ndupl + 1
                endif
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam2(1:j3),unam3(1:j4)
              write (nttyo,1010) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1010         format(/' * Error - (EQPT/tprnca) Have found a',
     $        ' duplicate data block on the DATA0 file',
     $        /7x,'for the nca triplet ',a,', ',a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j6 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j6),unam1(1:j2),unam2(1:j3),
     $        unam3(1:j4)
              write (nttyo,1020) ux8(1:j6),unam1(1:j2),unam2(1:j3),
     $        unam3(1:j4)
 1020         format(/' * Error - (EQPT/tprnca) Have found ',a,
     $        ' duplicate data blocks on the DATA0 file',
     $        /7x,'for the nca triplet ',a,', ',a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
c
c         Check for the presence of the corresponding lamda(nc) and
c         lambda(na) data. The presence of these data on the data
c         file is required.
c
          qfound1 = .false.
c
          do nn = 1,nncpr
            ii = incpr(1,nn)
            if (uaqsp(ii)(1:24) .eq. unam1(1:24)) then
              jj = incpr(2,nn)
              if (uaqsp(jj)(1:24) .eq. unam2(1:24)) then
                if (qpdnc(nn)) then
                  qfound1 = .true.
                  go to 130
                endif
              endif
            endif
          enddo
  130     continue
c
          qfound2 = .false.
c
          do nn = 1,nnapr
            ii = inapr(1,nn)
            if (uaqsp(ii)(1:24) .eq. unam1(1:24)) then
              jj = inapr(2,nn)
              if (uaqsp(jj)(1:24) .eq. unam3(1:24)) then
                if (qpdna(nn)) then
                  qfound2 = .true.
                  go to 140
                endif
              endif
            endif
          enddo
  140     continue
c
          if (.not.(qfound1 .and. qfound2)) then
c
c           Certain required data were not found on the DATA0 file.
c
            write (noutpt,1030) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1030) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1030       format(/' * Error - (EQPT/tprnca) Have data on the DATA0',
     $      ' file for the nca',/7x,'triplet ',a,', ',a,', ',a,', but',
     $      " don't have the",/7x,'required data for the following',
     $      ' neutral-ion pair(s):',/)
c
            if (.not.qfound1) then
              write (noutpt,1040) unam1(1:j2),unam2(1:j3)
              write (nttyo,1040) unam1(1:j2),unam2(1:j3)
 1040         format(9x,a,', ',a)
            endif
c
            if (.not.qfound2) then
              write (noutpt,1040) unam1(1:j2),unam3(1:j4)
              write (nttyo,1040) unam1(1:j2),unam3(1:j4)
            endif
c
            nerr = nerr + 1
          endif
        endif
c
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1050)
        write (nttyo,1050)
 1050   format(/' * Warning - (EQPT/tprnca) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  ' nca triplets:',/)
c
        ncount = 0
        do n = 1,nncatr
          if (.not.qpdnca(n)) then
            ncount = ncount + 1
            i = incatr(1,n)
            j = incatr(2,n)
            k = incatr(3,n)
            unam1 = uaqsp(i)
            unam2 = uaqsp(j)
            unam3 = uaqsp(k)
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            j4 = ilnobl(unam3)
            ustr80 = unam1(1:j2) // ', ' // unam2(1:j3) //
     $      ', ' // unam3(1:j4)
            j5 = ilnobl(ustr80)
            write (noutpt,1060) ustr80(1:j5)
            write (nttyo,1060) ustr80(1:j5)
 1060       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1070) ux8(1:j3)
          write (nttyo,1070) ux8(1:j3)
 1070     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1080)
        write (nttyo,1080)
 1080   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvnca = nncatr - nodatc
      pcvnca = (100.*ncvnca)/float(nncatr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine tprnn(abeta,acphi,alamnn,innpr,in2pr,ipbtmx,
     $ jpfcmx,natmax,ncvnn,nerr,nnnpr,nn2pr,noutpt,npx2mx,npx2t,
     $ nttyo,nwarn,pcvnn,qpdnn,qpdn2,uaqsp,upair)
c
c     Test and process the Pitzer data for nn' (neutral, different
c     neutral) pairs read from the DATA0 file. Find and flag errors,
c     such as duplication of data (e.g., two data blocks for the same
c     nn' pair). The conventional primitive Pitzer parameters are
c     identical to the observable parameters read from the data file:
c
c       lambda(nn') -> lambda(nn')
c
c     Check the coverage of entered Pitzer data against all possible
c     nn' pairs that can be composed of the neutral species present
c     on the data file.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       uaqsp  = array of names of aqueous species
c
c     Principal output:
c
c       nerr   = cumulative error counter
c       nwarn  = cumulative warning counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax,nnnpr,nn2pr,npx2mx
c
      integer noutpt,nttyo
c
      integer innpr(2,nnnpr),in2pr(nn2pr)
c
      integer ncvnn,nerr,npx2t,nwarn
c
      logical qfound1,qfound2
c
      logical qpdnn(nnnpr),qpdn2(nn2pr)
c
      character(len=24) uaqsp(natmax),upair(2,npx2mx)
c
      real*8 abeta(jpfcmx,0:ipbtmx,npx2mx),acphi(jpfcmx,npx2mx),
     $ alamnn(jpfcmx,0:ipbtmx,nnnpr)
c
      real*8 pcvnn
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
c-----------------------------------------------------------------------
c
      integer i,ii,j,jp,jpair,j2,j3,j4,j5,n,ncount,ndupl,nlistl,
     $ nn,nodatc
c
      integer ilnobl
c
      character*56 ustr56
      character*24 unam1,unam2
      character*8 ux8
c
c-----------------------------------------------------------------------
c
c     Limit on the list of pairs for which no data were found.
c
      data nlistl / 20 /
c
c-----------------------------------------------------------------------
c
c     Initialize the data arrays.
c
      do n = 1,nnnpr
        qpdnn(n) = .false.
        do j = 1,jpfcmx
          do i = 0,ipbtmx
            alamnn(j,i,n) = 0.
          enddo
        enddo
      enddo
c
c     Check the entered data for nn' pairs.
c
      nodatc = 0
c
      do n = 1,nnnpr
        i = innpr(1,n)
        j = innpr(2,n)
        unam1 = uaqsp(i)
        unam2 = uaqsp(j)
        j2 = ilnobl(unam1)
        j3 = ilnobl(unam2)
c
c       Search for unam1, unam2 in the upair array.
c       That array corresponds to the species pairs blocks.
c
        call srch22(jpair,unam1,unam2,upair,npx2mx,npx2t)
c
        if (jpair .gt. 0) then
c
c         Have found an entry.
c
          qpdnn(n) = .true.
c
c         Store the data.
c
          do j = 1,jpfcmx
            do i = 0,ipbtmx
              alamnn(j,i,n) = abeta(j,i,jpair)
            enddo
          enddo
c
c         Check for duplicate data sets.
c
          ndupl = 0
          do jp = jpair + 1,npx2t
            if (unam1(1:24) .eq. upair(1,jp)(1:24)) then
              if (unam2(1:24) .eq. upair(2,jp)(1:24)) then
                ndupl = ndupl + 1
              endif
            endif
          enddo
c
          if (ndupl .gt. 0) then
            if (ndupl .eq. 1) then
              write (noutpt,1010) unam1(1:j2),unam2(1:j3)
              write (nttyo,1010) unam1(1:j2),unam2(1:j3)
 1010         format(/' * Error - (EQPT/tprnn) Have found a',
     $        ' duplicate data block on the DATA0 file',
     $        /7x,"for the nn' pair ",a,', ',a,'.')
            else
              ux8 = ' '
              write (ux8,'(i5)') ndupl
              call lejust(ux8)
              j5 = ilnobl(ux8)
              write (noutpt,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
              write (nttyo,1020) ux8(1:j5),unam1(1:j2),unam2(1:j3)
 1020         format(/' * Error - (EQPT/tprnn) Have found ',a,
     $        ' duplicate data blocks on the DATA0 file',
     $        /7x,"for the nn' pair ",a,', ',a,'.')
            endif
            nerr = nerr + ndupl
          endif
c
        else
c
c         No data block was found on the DATA0 file.
c         Note that qpdnn(n) is left with a value of .false.
c
          nodatc = nodatc + 1
        endif
c
c       Check for the presence of the corresponding lamda(nn),
c       and lambda(n'n') data. The presence of these data on
c       the  data file is required.
c
        qfound1 = .false.
c
        do nn = 1,nn2pr
          ii = in2pr(nn)
          if (uaqsp(ii)(1:24) .eq. unam1(1:24)) then
            if (qpdn2(nn)) then
              qfound1 = .true.
              go to 130
            endif
          endif
        enddo
  130   continue
c
        qfound2 = .false.
c
        do nn = 1,nn2pr
          ii = in2pr(nn)
          if (uaqsp(ii)(1:24) .eq. unam2(1:24)) then
            if (qpdn2(nn)) then
              qfound2 = .true.
              go to 140
            endif
          endif
        enddo
  140   continue
c
        if (qpdnn(n) .and. .not.(qfound1 .and. qfound2)) then
c
c         Certain required data were not found on the DATA0 file.
c
          write (noutpt,1030) unam1(1:j2),unam2(1:j3)
          write (nttyo,1030) unam1(1:j2),unam2(1:j3)
 1030     format(/' * Error - (EQPT/tprnn) Have data on the DATA0',
     $    " file for the nn'",/7x,'pair ',a,', ',a,', but',
     $    " don't have the",/7x,'required data for the following',
     $    ' neutral-neutral pair(s):',/)
c
          if (.not.qfound1) then
            write (noutpt,1040) unam1(1:j2),unam1(1:j2)
            write (nttyo,1040) unam1(1:j2),unam1(1:j2)
 1040       format(9x,a,', ',a)
          endif
c
          if (.not.qfound2) then
            write (noutpt,1040) unam2(1:j3),unam2(1:j3)
            write (nttyo,1040) unam2(1:j3),unam2(1:j3)
          endif
c
          nerr = nerr + 1
        endif
c
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (nodatc .gt. 0) then
        write (noutpt,1050)
        write (nttyo,1050)
 1050   format(/' * Warning - (EQPT/tprnn) Did not find a data',
     $  ' block on the DATA0 file',/7x,'for any of the following',
     $  " nn' pairs:",/)
c
        ncount = 0
        do n = 1,nnnpr
          if (.not.qpdnn(n)) then
            ncount = ncount + 1
            i = innpr(1,n)
            j = innpr(2,n)
            unam1 = uaqsp(i)
            unam2 = uaqsp(j)
            j2 = ilnobl(unam1)
            j3 = ilnobl(unam2)
            ustr56 = unam1(1:j2) // ', ' // unam2(1:j3)
            j4 = ilnobl(ustr56)
            write (noutpt,1060) ustr56(1:j4)
            write (nttyo,1060) ustr56(1:j4)
 1060       format(9x,a)
            if (ncount .eq. nlistl) go to 200
          endif
        enddo
  200   continue
c
        nn = nodatc - ncount
        if (nn .gt. 0) then
          write (ux8,'(i5)') nn
          call lejust(ux8)
          j3 = ilnobl(ux8)
          write (noutpt,1070) ux8(1:j3)
          write (nttyo,1070) ux8(1:j3)
 1070     format(/9x,'plus ',a,' others')
        endif
        write (noutpt,1080)
        write (nttyo,1080)
 1080   format(1x)
        nwarn = nwarn + 1
      endif
c
      ncvnn = nnnpr - nodatc
      pcvnn = (100.*ncvnn)/float(nnnpr)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine tripck(na,nc,nerr,nn,noutpt,nttyo,n1,n2,n3,
     $ qdup12,qdup13,qdup23,unam1,unam2,unam3)
c
c     This suboutine checks the species triplets that were read
c     from the DATA0 file for illegal combinations.
c
c     The only legal combinations here correspond to ternary
c     systems and maximal third order in the expansion of the
c     Gibbs energy. These are:
c
c       nnn'      mu(nnn') maps to itself
c       nca       zeta(nca) maps to mu(nca)
c       cc'a      psi(cc'a) maps to mu(cc'a)
c       aa'c      psi(aa'c) maps to mu(aa'c)
c
c     Here n = neutral, n' a different neutral, c = cation, c' = a
c     different cation, a = anion, and a' = a different anion.
c     Solvent water (w) may not appear in any combination in the
c     normal Pitzer treatment of electrolyte solutions.
c
c     Other possible combinations are not allowed because of one or
c     more of the following reasons:
c
c       1. The combination corresponds to systems of higher order
c          (e.g., cc'c'')
c       2. The combination corresponds to systems of lesser order
c          (e.g., nnn and cca)
c       3. The combination corresponds to parameters that are defined
c          by convention to be zero (i.e., to unused parameters).
c          Examples include ccc and ncc.
c
c     This suboutine is called by:
c
c       EQPT/rdpz3.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       na     = number of anions in a species triplet
c       nc     = number of cations in a species triplet
c       nn     = number of neutral species in a species triplet
c       n1     = index of the first species in a triplet
c       n2     = index of the second species in a triplet
c       n3     = index of the third species in a triplet
c       unam1  = first name in a species triplet
c       unam2  = second name in a species triplet
c       unam3  = third name in a species triplet
c
c     Principal output:
c
c       nerr   = error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer noutpt,nttyo
c
      integer na,nc,nn,nerr,n1,n2,n3
c
      logical qdup12,qdup13,qdup23
c
      character*24 unam1,unam2,unam3
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer j2,j3,j4
c
      integer ilnobl
c
c-----------------------------------------------------------------------
c
      j2 = ilnobl(unam1)
      j3 = ilnobl(unam2)
      j4 = ilnobl(unam3)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for illegal appearance of solvent water.
c
      if (unam1(1:4) .eq.'H2O ' .or. unam2(1:4) .eq.'H2O ' .or.
     $  unam3(1:4).eq.'H2O ' .or. n1.eq.1 .or. n2.eq.1 .or.
     $  n3.eq.1) then
        write (noutpt,1430) unam1(1:j2),unam2(1:j3),unam3(1:j4)
        write (nttyo,1430) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1430   format(/' * Error - (EQPT/tripck) Have found an illegal data',
     $  ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $  ' among the blocks for',/7x,'"mixture parameters".',
     $  ' Solvent water may not appear in such a',/7x,'triplet in',
     $  ' the normal Pitzer treatment of electrolyte',
     $  /7x,'solutions.')
        nerr = nerr + 1
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (qdup12 .and. qdup13) then
c
c       The same species appears three times.
c
        if (nc.gt.0 .or. na.gt.0) then
c
c         The same cation or anion appears three times.(ccc or aaa).
c
          write (noutpt,1110) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1110) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1110     format(/' * Error - (EQPT/tripck) Have found an illegal data',
     $    ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $    ' among the blocks',/7x,'for "mixture parameters". The same',
     $    ' ion appears three times.',/7x,'This is not a valid',
     $    ' combination, as the corrresponding lambda and mu',
     $    /7x,'data are defined to be zero by convention in the normal',
     $    ' Pitzer',/7x,'treatment of electrolyte solutions.')
        endif
c
        if (nn .gt. 0) then
c
c         The same neutral appears three times (nnn).
c
          write (noutpt,1112) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1112) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1112     format(/' * Error - (EQPT/tripck) Have found an illegal data',
     $    ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $    ' among the blocks',/7x,'for "mixture parameters". The',
     $    ' same neutral appears three times.',/7x,'This is not',
     $    ' a valid combination for the present kind of block.',
     $    /7x,'Enter these data in a block for "single-salt',
     $    ' parameters".')
        endif
c
        nerr = nerr + 1
        go to 999
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for other illegal combinations involving two or more
c     neutrals.
c
      if (nn .eq. 3) then
        if (.not.(qdup12 .or. qdup13 .or. qdup23)) then
c
c         Have three distinct neutrals (nn'n'').
c
          write (noutpt,1130) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1130) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1130     format(/' * Error - (EQPT/tripck) Have found an illegal data',
     $    ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $    ' among the blocks',/7x,'for "mixture parameters". Three',
     $    ' distinct neutrals appear. This is not',/7x,'a valid',
     $    ' combination in the context of the normal Pitzer',
     $    /7x,'treatment of electrolyte solutions as it corresponds',
     $    ' to a',/7x,'quaternary system.')
          nerr = nerr + 1
          go to 999
        endif
      endif
c
      if (nn .eq. 2) then
        if (nc.eq.1 .or. na.eq.1) then
c
          if (qdup12 .or. qdup23 .or. qdup13) then
c
c           Have one of the following combinations: nnc or nna.
c
            write (noutpt,1132) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1132) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1132       format(/' * Error - (EQPT/tripck) Have found an illegal',
     $      ' data block for the',/7x,'species triplet ',a,', ',a,', ',
     $      a,' among the blocks',/7x,'for "mixture parameters". One',
     $      ' neutral appears twice with an ion.',/7x,'This is not a',
     $      ' valid combination in the context of the normal Pitzer',
     $      /7x,'treatment of electrolyte solutions. The corresponding',
     $      ' parameters',/7x,'are not used.')
          else
c
c           Have one of the following combinations: nn'c or nn'a.
c
            write (noutpt,1136) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1136) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1136       format(/' * Error - (EQPT/tripck) Have found an illegal',
     $      ' data block for the',/7x,'species triplet ',a,', ',a,', ',
     $      a,' among the blocks',/7x,'for "mixture parameters". Two',
     $      ' neutrals appear with an ion.',/7x,'This is not a',
     $      ' valid combination in the context of the normal Pitzer',
     $      /7x,'treatment of electrolyte solutions as it corresponds',
     $      ' to a',/7x,'quaternary system.')
          endif
          nerr = nerr + 1
          go to 999
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for other illegal combinations involving two or more
c     cations.
c
      if (nc .eq. 3) then
        if (.not.(qdup12 .or. qdup13 .or. qdup23)) then
c
c         Have three distinct cations (cc'c'').
c
          write (noutpt,1140) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1140) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1140     format(/' * Error - (EQPT/tripck) Have found an illegal data',
     $    ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $    ' among the blocks',/7x,'for "mixture parameters". Three',
     $    ' distinct cations appear. This is',/7x,'not a valid',
     $    ' combination in the context of the normal Pitzer',
     $    /7x,'treatment of electrolyte solutions as it corresponds',
     $    ' to a',/7x,'quaternary system.')
          nerr = nerr + 1
          go to 999
        endif
c
        if (qdup12 .and. qdup13) then
c
c         Have one cation appearing three times (ccc).
c
          write (noutpt,1142) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1142) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1142     format(/' * Error - (EQPT/tripck) Have found an illegal data',
     $    ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $    ' among the blocks',/7x,'for "mixture parameters". A single',
     $    ' cation appears three times. This',/7x,'is not a valid',
     $    ' combination in the context of the normal Pitzer',
     $    /7x,'treatment of electrolyte solutions. The corresponding',
     $    ' parameters are',/7x,'zero by convention.')
          nerr = nerr + 1
          go to 999
        endif
c
        if (qdup12 .or. qdup13 .or. qdup23) then
c
c         Have one cation appearing two times (ccc').
c
          write (noutpt,1144) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1144) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1144     format(/' * Error - (EQPT/tripck) Have found an illegal data',
     $    ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $    ' among the blocks',/7x,'for "mixture parameters". A single',
     $    ' cation appears twice with another',/7x,'cation. This is',
     $    ' not a valid combination in the context of the normal',
     $    /7x,'Pitzer treatment of electrolyte solutions. The',
     $    ' corresponding',/7x,'parameters are not used.')
          nerr = nerr + 1
          go to 999
        endif
      endif
c
      if (nc .eq. 2) then
c
        if (qdup12 .or. qdup23 .or. qdup13) then
c
          if (nn .eq. 1) then
c
c           Have a repeated cation and a neutral (ccn).
c
            write (noutpt,1150) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1150) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1150       format(/' * Error - (EQPT/tripck) Have found an illegal',
     $      ' data block for the',/7x,'species triplet ',a,', ',a,', ',
     $      a,' among the blocks',/7x,'for "mixture parameters". One',
     $      ' cation appears twice with a neutral.',/7x,'This is not a',
     $      ' valid combination in the context of the normal Pitzer',
     $      /7x,'treatment of electrolyte solutions. The',
     $      ' corresponding parameters',/7x,'are not used.')
          elseif (na .eq. 1) then
c
c           Have a repeated cation and an anion (cca).
c
            write (noutpt,1152) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1152) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1152       format(/' * Error - (EQPT/tripck) Have found an illegal',
     $      ' data block for the',/7x,'species triplet ',a,', ',a,', ',
     $      a,' among the blocks',/7x,'for "mixture parameters". One',
     $      ' cation appears twice with an anion.',/7x,'This is not a',
     $      ' valid combination for the present type of block. The',
     $      /7x,'corresponding parameters properly appear in a block',
     $      ' under',/7x,'"single-salt parameters".')
          endif
          nerr = nerr + 1
          go to 999
        else
c
          if (nn .eq. 1) then
c
c           Have two cations and a neutral (c'cn).
c
            write (noutpt,1154) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1154) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1154       format(/' * Error - (EQPT/tripck) Have found an illegal',
     $      ' data block for the',/7x,'species triplet ',a,', ',a,', ',
     $      a,' among the blocks',/7x,'for "mixture parameters". Two',
     $      ' cations appear with a neutral.',/7x,'This is not a',
     $      ' valid combination in the context of the normal Pitzer',
     $      /7x,'treatment of electrolyte solutions as it corresponds',
     $      ' to a',/7x,'quaternary system.')
            nerr = nerr + 1
            go to 999
          endif
c
c         Have two cations and an anion (cc'a). That is a legal
c         combination.
c
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Check for other illegal combinations involving two or more
c     anions.
c
      if (na .eq. 3) then
        if (.not.(qdup12 .or. qdup13 .or. qdup23)) then
c
c         Have three distinct anions (aa'a'').
c
          write (noutpt,1160) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1160) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1160     format(/' * Error - (EQPT/tripck) Have found an illegal data',
     $    ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $    ' among the blocks',/7x,'for "mixture parameters". Three',
     $    ' distinct anions appear. This is',/7x,'not a valid',
     $    ' combination in the context of the normal Pitzer',
     $    /7x,'treatment of electrolyte solutions as it corresponds',
     $    ' to a',/7x,'quaternary system.')
          nerr = nerr + 1
          go to 999
        endif
c
        if (qdup12 .and. qdup13) then
c
c         Have one anion appearing three times (aaa).
c
          write (noutpt,1162) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1162) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1162     format(/' * Error - (EQPT/tripck) Have found an illegal data',
     $    ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $    ' among the blocks',/7x,'for "mixture parameters". A single',
     $    ' anion appears three times. This',/7x,'is not a valid',
     $    ' combination in the context of the normal Pitzer',
     $    /7x,'treatment of electrolyte solutions. The corresponding',
     $    ' parameters are',/7x,'zero by convention.')
          nerr = nerr + 1
          go to 999
        endif
c
        if (qdup12 .or. qdup13 .or. qdup23) then
c
c         Have one anion appearing two times (aaa').
c
          write (noutpt,1164) unam1(1:j2),unam2(1:j3),unam3(1:j4)
          write (nttyo,1164) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1164     format(/' * Error - (EQPT/tripck) Have found an illegal data',
     $    ' block for the',/7x,'species triplet ',a,', ',a,', ',a,
     $    ' among the blocks',/7x,'for "mixture parameters". A single',
     $    ' anion appears twice with another',/7x,'anion. This is',
     $    ' not a valid combination in the context of the normal',
     $    /7x,'Pitzer treatment of electrolyte solutions. The',
     $    ' corresponding',/7x,'parameters are not used.')
          nerr = nerr + 1
          go to 999
        endif
      endif
c
      if (na .eq. 2) then
c
        if (qdup12 .or. qdup23 .or. qdup13) then
c
          if (nn .eq. 1) then
c
c           Have a repeated anion and a neutral (aan).
c
            write (noutpt,1170) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1170) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1170       format(/' * Error - (EQPT/tripck) Have found an illegal',
     $      ' data block for the',/7x,'species triplet ',a,', ',a,', ',
     $      a,' among the blocks',/7x,'for "mixture parameters". One',
     $      ' anion appears twice with a neutral.',/7x,'This is not a',
     $      ' valid combination in the context of the normal Pitzer',
     $      /7x,'treatment of electrolyte solutions. The',
     $      ' corresponding parameters',/7x,'are not used.')
          elseif (nc .eq. 1) then
c
c           Have a repeated anion and a cation (aac).
c
            write (noutpt,1173) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1173) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1173       format(/' * Error - (EQPT/tripck) Have found an illegal',
     $      ' data block for the',/7x,'species triplet ',a,', ',a,', ',
     $      a,' among the blocks',/7x,'for "mixture parameters". One',
     $      ' anion appears twice with a cation.',/7x,'This is not a',
     $      ' valid combination for the present type of block. The',
     $      /7x,'corresponding parameters properly appear in a block',
     $      ' under',/7x,'"single-salt parameters".')
          endif
          nerr = nerr + 1
          go to 999
        else
c
          if (nn .eq. 1) then
c
c           Have two anions and a neutral (a'an).
c
            write (noutpt,1174) unam1(1:j2),unam2(1:j3),unam3(1:j4)
            write (nttyo,1174) unam1(1:j2),unam2(1:j3),unam3(1:j4)
 1174       format(/' * Error - (EQPT/tripck) Have found an illegal',
     $      ' data block for the',/7x,'species triplet ',a,', ',a,', ',
     $      a,' among the blocks',/7x,'for "mixture parameters". Two',
     $      ' anions appear with a neutral.',/7x,'This is not a',
     $      ' valid combination in the context of the normal Pitzer',
     $      /7x,'treatment of electrolyte solutions as it corresponds',
     $      ' to a',/7x,'quaternary system.')
            nerr = nerr + 1
            go to 999
          endif
c
c         Have two anions and a cation (aa'c). That is a legal
c         combination.
c
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
c
      end
      subroutine vazpck(nat,natmax,nazt,naztmx,noutpt,nttyo,
     $ uaqsp,uazp)
c
c     Validate the aqueous species names used to specify hard core
c     diameters. Write a note if such a name does not appear on the
c     main list of aqueous species.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nat    = the number of aqueous species
c       nazt   = the number of specified hard core diameters
c       uaqsp  = array of names of aqueous species
c       uazp   = array of aqueous species names used to specify
c                  hard core diamters on the data file
c
c     Principal output:
c
c       None
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer natmax,naztmx
c
      integer noutpt,nttyo
c
      integer nat,nazt
c
      character*24 uaqsp(natmax),uazp(naztmx)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*24 unam
c
      integer j2,na,naz
c
      integer ilnobl
c
c-----------------------------------------------------------------------
c
c     Loop over all aqueous species names used to specify hard core
c     diameters.
c
      do naz = 1,nazt
        unam = uazp(naz)
        if (unam(1:7) .ne. '<blank>') then
c
c         Check that each such name appears on the main list of
c         aqueous species.
c
          do na = 1,nat
            if (unam(1:24) .eq. uaqsp(na)(1:24)) go to 100
          enddo
c
c         Did not find this name on the main list of aqueous species.
c
          j2 = ilnobl(unam)
          write (noutpt,1000) unam(1:j2)
          write (nttyo,1000) unam(1:j2)
 1000     format(/' * Note - (EQPT/vazpck) A hard core diameter is',
     $    ' specified on the',/7x,'data file for ',a,', but there is',
     $    ' no species block for this',/7x,'in the aqueous species',
     $    ' superblock. Therefore, this species will',/7x,'not appear',
     $    ' in any computed model and the hard core diameter value',
     $    /7x,'will not be used. It is suggested to remove the',
     $    ' hard core diameter',/7x,'in question or to add the',
     $    ' corresponding species block.')
c
  100     continue
        endif
      enddo
c
      end
      subroutine vxspck(iktmax,issot,nerr,nmt,nmtmax,noutpt,nttyo,
     $ nxt,nxtmax,uminsp,ussoph,ussosp)
c
c     Validate the names of solid solution end-members. Make sure that
c     these names appear on the list of pure minerals.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       nxt    = the number of solid solutions
c       issot  = array of numbers of end-members of solid solutions
c       ussoph = array of names of solid solutions
c       ussosp = array of names of end-members of solid solutions
c       uminsp = array of pure mineral names
c
c     Principal output:
c
c       nerr   = error counter
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer iktmax,nmtmax,nxtmax
c
      integer noutpt,nttyo
c
      integer nerr,nmt,nxt
c
      integer issot(nxtmax)
c
      character(len=24) uminsp(nmtmax),ussoph(nxtmax),
     $ ussosp(iktmax,nxtmax)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      character*24 unam
c
      integer i,ikt,j2,j3,kerr,nm,nx
c
      integer ilnobl
c
c-----------------------------------------------------------------------
c
c     Loop over all solid solution phases.
c
      do nx = 1,nxt
c
        ikt = issot(nx)
        kerr = 0
c
c       Check that each end-member appears on the list of pure minerals.
c
        do i = 1,ikt
          unam = ussosp(i,nx)
          if (unam(1:7) .ne. '<blank>') then
c
c           Check that each end-member appears on the list of
c           pure minerals.
c
            do nm = 1,nmt
              if (unam(1:24) .eq. uminsp(nm)(1:24)) go to 100
            enddo
c
c           Did not find this end-member on the list of pure minerals.
c
            kerr = kerr + 1
            nerr = nerr + 1
c
            if (kerr .eq. 1) then
c
c             Write a header for the solid solution.
c
              j2 = ilnobl(ussoph(nx))
              write (noutpt,1000) ussoph(nx)(1:j2)
              write (nttyo,1000) ussoph(nx)(1:j2)
 1000         format(/' * Error - (EQPT/vxspck) The following',
     $        ' end-members of solid solution',/7x,a,' are not present',
     $        ' on the data file as pure minerals:',/)
            endif
c
            j3 = ilnobl(unam)
            write (noutpt,1010) unam(1:j3)
            write (nttyo,1010) unam(1:j3)
 1010       format(9x,a)
c
  100       continue
          endif
        enddo
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine wrazp(azero,insgf,nazt,naztmx,ndata1,ndat1f,
     $ noutpt,nttyo,uazp)
c
c     This subroutine writes on the DATA1 and DATA1F files the "bdot"
c     data read from the DATA0 file by EQPT/rdazp.f.
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndata1 = unit number of the DATA1 file
c       ndat1f = unit number of the DATA1F file
c       nazt   = the number of elements in the uazp array
c       uazp   = array containing lines of data
c       azero  = array of corresponding hard core diameters
c       insgf  = array of corresponding neutral species
c                  activity coefficient flags
c
c     Principal output:
c
c       None
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer naztmx
c
      integer ndata1,ndat1f,noutpt,nttyo
c
      integer nazt
c
      integer insgf(naztmx)
c
      character*24 uazp(naztmx)
c
      real*8 azero(naztmx)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer ineu,naz
c
      character*72 uterm,utermc
      character*24 uendit
c
      real*8 zero
c
c-----------------------------------------------------------------------
c
      data uendit / 'endit.' /
c
c-----------------------------------------------------------------------
c
      uterm(1:48) = '+-----------------------------------------------'
      uterm(49:72) = '------------------------'
      utermc = uterm
      utermc(1:1) = '*'
c
c     Write the azero ('bdot') data on the DATA1 and DATA1F files.
c
      do naz = 1,nazt
        write (ndata1) uazp(naz),azero(naz),insgf(naz)
        write (ndat1f,1010) uazp(naz),azero(naz),insgf(naz)
 1010   format(a24,2x,f7.1,2x,i2)
      enddo
c
c     Write the block terminator.
c
      zero = 0.
      ineu = 0
      write (ndata1) uendit,zero,ineu
      write (ndat1f,1010) uendit,zero,ineu
      write (ndat1f,1020) utermc(1:72)
 1020 format(a)
c
      end
      subroutine wrhdr(ikt_asv,ipch_asv,ipcv_asv,jpfc_asv,nap_asv,
     $ narx_asv,nat_asv,nbt_asv,nct_asv,ndata1,ndat1f,ngt_asv,
     $ nlat_asv,nlt_asv,nmt_asv,nmut_asv,npt_asv,nst_asv,ntid_asv,
     $ ntpr_asv,nxt_asv,uakey)
c
c     This suboutine writes a header on the DATA1 and DATA1F files.
c     The header includes the string "data1', followed by the keystring
c     for the type of aqueous species activity coefficient model, and
c     the dimensioning parameters required to read the rest of the data
c     on the DATA1 file. The dimensioning parameters are used by EQ3NR
c     and EQ6.
c
c     This suboutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       ndata1    = the unit number of the DATA1 file
c       ndat1f    = the unit number of the DATA1F file
c       uakey     = the keystring identifying the type of model for the
c                     aqueous species activity coefficients
c       ikt_asv  = the maximum number of end-member component species
c                    in any solid solution on the data file
c       jpfc_asv = the number of terms (coefficients) in the
c                    temperature function used to represent Pitzer
c                    interaction parameters
c       nap_asv  = maximum number of distinct sets of Pitzer alpha
c                    parameters
c       nat_asv  = the number of aqueous species on the data file
c       nbt_asv  = the number of basis species on the data file
c       nct_asv  = the number of chemical elements on the data file
c       ngt_asv  = the number of gas species on the data file
c       nlt_asv  = the number of pure liquid species on the data file
c       nmt_asv  = the number of gas species on the data file
c       npt_asv  = The number of phases of all types on the data file
c       nlat_asv = the number of members in the set of Pitzer lambda
c                    coefficients
c       nmut_asv = the number of members in the set of Pitzer mu
c                    coefficients
c       nst_asv  = the number of species of all types on the data file
c       ntid_asv = the number of lines in the data file title
c       nxt_asv  = the number of solid-solution phases on the data file
c
c     Principal output:
c
c       None
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ndata1,ndat1f
c
      integer ikt_asv,ipch_asv,ipcv_asv,jpfc_asv,nap_asv,narx_asv,
     $ nat_asv,nbt_asv,nct_asv,ngt_asv,nlat_asv,nlt_asv,nmt_asv,
     $ nmut_asv,npt_asv,nst_asv,ntid_asv,ntpr_asv,nxt_asv
c
      character(len=8) uakey
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer j2,j3
c
      integer ilnobl
c
      character(len=72) uterm,utermc
      character(len=56) ux56
      character(len=8) udat1
c
c-----------------------------------------------------------------------
c
      uterm(1:48) = '+-----------------------------------------------'
      uterm(49:72) = '------------------------'
      utermc = uterm
      utermc(1:1) = '*'
c
c     Write 'data1' at the top of the DATA1 and DATA1F files.
c
      udat1 = 'data1'
      j2 = ilnobl(udat1)
c
      write (ndata1) udat1
      write (ndat1f,1000) udat1(1:j2)
 1000 format(a)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Next write the keystring for the type of model for the activity
c     coefficients of the aqueous species.
c
      j3 = ilnobl(uakey)
c
      write (ndata1) uakey
      write (ndat1f,1000) uakey(1:j3)
      write (ndat1f,1000) utermc(1:72)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the minimum dimensioning parameters required by the current
c     data file. This will be used by EQ3NR and EQ6 to allocate array
c     sizes for arrays which will contain the data read from this data
c     file.
c
c     Write the standard grid parameters on the output files.
c
      ux56 = 'Dim: chemical elements'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) nct_asv
      write (ndat1f,1010) nct_asv
 1010 format(i5)
c
      ux56 = 'Dim: basis species'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) nbt_asv
      write (ndat1f,1010) nbt_asv
c
      ux56 = 'Dim: total species of all types'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) nst_asv
      write (ndat1f,1010) nst_asv
c
      ux56 = 'Dim: total phases'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) npt_asv
      write (ndat1f,1010) npt_asv
c
      ux56 = 'Dim: aqueous species'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) nat_asv
      write (ndat1f,1010) nat_asv
c
      ux56 = 'Dim: pure minerals'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) nmt_asv
      write (ndat1f,1010) nmt_asv
c
      ux56 = 'Dim: pure liquids'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) nlt_asv
      write (ndat1f,1010) nlt_asv
c
      ux56 = 'Dim: gas species'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) ngt_asv
      write (ndat1f,1010) ngt_asv
c
      ux56 = 'Dim: solid solutions'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) nxt_asv
      write (ndat1f,1010) nxt_asv
c
      ux56 = 'Dim: max. components in a solid solution'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) ikt_asv
      write (ndat1f,1010) ikt_asv
c
      ux56 = 'Dim: lines in the data file title'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) ntid_asv
      write (ndat1f,1010) ntid_asv
c
      ux56 = 'Dim: ranges in the logK temperature grid'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) ntpr_asv
      write (ndat1f,1010) ntpr_asv
c
      ux56 = 'Dim: max. points in a logK temperature grid range'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) narx_asv
      write (ndat1f,1010) narx_asv
c
      ux56 = 'Dim: dH/dP order'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) ipch_asv
      write (ndat1f,1010) ipch_asv
c
      ux56 = 'Dim: dV/dP order'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1000) ux56(1:j2)
      write (ndata1) ipcv_asv
      write (ndat1f,1010) ipcv_asv
c
      if (uakey(1:8) .eq. 'Pitzer  ') then
        ux56 = 'Dim: distinct sets of Pitzer alpha parameters'
        write (ndata1) ux56
        j2 = ilnobl(ux56)
        write (ndat1f,1000) ux56(1:j2)
        write (ndata1) nap_asv
        write (ndat1f,1010) nap_asv
c
        ux56 = 'Dim: Pitzer lambda parameters'
        write (ndata1) ux56
        j2 = ilnobl(ux56)
        write (ndat1f,1000) ux56(1:j2)
        write (ndata1) nlat_asv
        write (ndat1f,1010) nlat_asv
c
        ux56 = 'Dim: Pitzer mu parameters'
        write (ndata1) ux56
        j2 = ilnobl(ux56)
        write (ndat1f,1000) ux56(1:j2)
        write (ndata1) nmut_asv
        write (ndat1f,1010) nmut_asv
c
        ux56 = 'Dim: coefficients in the Pitzer parameter'
     $  // ' temp. function'
        write (ndata1) ux56
        j2 = ilnobl(ux56)
        write (ndat1f,1000) ux56(1:j2)
        write (ndata1) jpfc_asv
        write (ndat1f,1010) jpfc_asv
      endif
c
      write (ndat1f,1000) utermc(1:72)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  999 continue
      end
      subroutine wrpar(aamatr,adh,adhh,adhv,aphi,apr,avgrid,bdh,bdhh,
     $ bdhv,bdot,bdoth,bdotv,cco2,cof,dadhh,dadhv,dbdhh,dbdhv,dbdth,
     $ dbdtv,dhfe,dvfe,eps100,gmmatr,ipch,ipchmx,ipcv,ipcvmx,ipivot,
     $ narxmx,narxt,ndata1,ndat1f,noutpt,ntprmx,ntprt,nttyo,presg,
     $ prehw,tdamax,tdamin,tempc,tempcs,tmpcmx,uakey,xhfe,xlke,xvfe,
     $ xvec,yvec)
c
c     This subroutine takes the data read from the DATA0 file by the
c     EQPT/rdpar.f, processes it by converting data on a temperature
c     grid to the equivalent set of coefficients of interpolating
c     polynomials, and writes this data on the DATA1 and DATA1F files.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       adh    = array of A(gamma,10) values on the standard temperature
c                  grid
c       aphi   = array of A(phi) values on the standard temperature grid
c       bdh    = array of B(gamma) values on the standard temperature
c                  grid
c       bdot   = array of B-dot values on the standard temperature
c                  grid
c       cco2   = array of coefficients for the Drummond (1981)
c                  equation
c       ndata1 = unit number of the DATA1 file
c       ndat1f = unit number of the DATA1F file
c       presg  = array of pressures on the standard temperature grid
c       tempc  = array of temperatures defining the standard
c                  temperature grid
c       uakey  = string specifying the type of data file ("SEDH" or
c                  "Pitzer") being processed
c       xlke   = array of log K values for the special "Eh" reaction
c                  on the standard temperature grid
c
c     Principal output:
c
c       apr    = array of polynomial coefficients (combined, for all
c                  temperature ranges)
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipchmx,ipcvmx,narxmx,ntprmx
c
      integer ipivot(narxmx),narxt(ntprmx)
c
      integer ndata1,ndat1f,noutpt,nttyo
c
      integer ipch,ipcv,ntprt
c
      character(len=8) uakey
c
      real(8) tdamax,tdamin
      real(8) cco2(5)
c
      real(8) adh(narxmx,ntprmx),adhh(narxmx,ntprmx),
     $ adhv(narxmx,ntprmx),aphi(narxmx,ntprmx),bdh(narxmx,ntprmx),
     $ bdhh(narxmx,ntprmx),bdhv(narxmx,ntprmx),bdot(narxmx,ntprmx),
     $ bdoth(narxmx,ntprmx),bdotv(narxmx,ntprmx),
     $ dadhh(narxmx,ntprmx,ipchmx),dadhv(narxmx,ntprmx,ipcvmx),
     $ dbdhh(narxmx,ntprmx,ipchmx),dbdhv(narxmx,ntprmx,ipcvmx),
     $ dbdth(narxmx,ntprmx,ipchmx),dbdtv(narxmx,ntprmx,ipcvmx),
     $ dhfe(narxmx,ntprmx,ipchmx),dvfe(narxmx,ntprmx,ipcvmx),
     $ prehw(narxmx,ntprmx),presg(narxmx,ntprmx),xhfe(narxmx,ntprmx),
     $ xlke(narxmx,ntprmx),xvfe(narxmx,ntprmx)
c
      real(8) apr(narxmx,ntprmx),avgrid(narxmx,ntprmx)
      real(8) tempc(narxmx,ntprmx),tempcs(narxmx,ntprmx),tmpcmx(ntprmx)
      real(8) aamatr(narxmx,narxmx),gmmatr(narxmx,narxmx)
      real(8) cof(narxmx),xvec(narxmx),yvec(narxmx)
c
      real(8) eps100
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,ipc,j2,j3,n,nt,ntpr
c
      integer ilnobl
c
      character(len=10) ux10
      character(len=72) uterm,utermc
      character(len=56) ux56
      character(len=24) ux24,ux24a,ux24b
c
      real(8) adtxmn,adtx11,p01_8,txmn,tx11
c
c-----------------------------------------------------------------------
c
      uterm(1:48) = '+-----------------------------------------------'
      uterm(49:72) = '------------------------'
      utermc = uterm
      utermc(1:1) = '*'
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the temperature limits on the output files.
c
      ux56 = 'Data file maximum and minimum temperatures (C)'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1100) ux56(1:j2)
 1100 format(a)
      write (ndata1) tdamin,tdamax
      write (ndat1f,1110) tdamin,tdamax
 1110 format(2f10.3)
c
      write (noutpt,1120) tdamin
      write (nttyo,1120) tdamin
 1120 format(//' The minimum temperature is ',f10.3,'C')
      write (noutpt,1130) tdamax
      write (nttyo,1130) tdamax
 1130 format(' The maximum temperature is ',f10.3,'C')
c
      ux56 = 'Maximum temperature (C) by range'
      write (ndata1) ux56
      j2 = ilnobl(ux56)
      write (ndat1f,1140) ux56(1:j2)
 1140 format(a)
      do ntpr = 1,ntprt
        n = narxt(ntpr)
        write (ndata1) tempc(n,ntpr)
        write (ndat1f,1150) tempc(n,ntpr)
 1150   format(f10.3)
      enddo
c
      write (ndat1f,1010) utermc(1:72)
c
      write (noutpt,1160)
      write (nttyo,1160)
 1160 format(/' The maximum temperatures (C) by range are:')
      do ntpr = 1,ntprt
        n = narxt(ntpr)
        write (noutpt,1170) tempc(n,ntpr)
        write (nttyo,1170) tempc(n,ntpr)
 1170   format(3x,f10.3)
      enddo
c
      write (noutpt,1000)
 1000 format(/)
c
c
      tx11 = tempc(1,1)
      txmn = tdamin
c
c     Note: on some data files, 0.01C is used as an approximation
c     to 0C in order to avoid some equation-of-state difficulties.
c     In such cases, consider 0.01C to be the same as 0C for the
c     purpose of the following test.
c
      ux10 = '0.01      '
      read (ux10,'(f10.3)') p01_8
      adtx11 = abs(tx11 - p01_8)
      adtxmn = abs(txmn - p01_8)
      if (adtx11 .le. 1.e-6) tx11 = 0.
      if (adtxmn .le. 1.e-6) txmn = 0.
c
      if ((tx11 - tdamin) .gt. 0.001) then
        write (ux24a,"(f10.3)") tdamin
        call lejust(ux24a)
        j2 = ilnobl(ux24a)
        write (ux24b,"(f10.3)") tempc(1,1)
        call lejust(ux24b)
        j3 = ilnobl(ux24b)
        write (noutpt,1200) ux24a(1:j2),ux24b(1:j3)
        write (nttyo,1200) ux24a(1:j2),ux24b(1:j3)
 1200   format(/' * Warning - (EQPT/rdpar) The minimum temperature for',
     $  ' this data file',/7x,'is less than the lowest temperature in',
     $  ' the first temperature',/7x,'range. If EQ3NR and EQ6 are',
     $  ' required to make any calculations',/7x,'between ',a,'C',
     $  ' and ',a,'C, they will do so by extrapolating',/7x,'the',
     $  ' data from the first range.')
      endif
c
      n = narxt(ntprt)
      if ((tdamax - tempc(n,ntprt)) .gt. 0.001) then
        write (ux24a,"(f10.3)") tempc(n,ntprt)
        call lejust(ux24a)
        j2 = ilnobl(ux24a)
        write (ux24b,"(f10.3)") tdamax
        call lejust(ux24b)
        j3 = ilnobl(ux24b)
        write (noutpt,1210) ux24a(1:j2),ux24b(1:j3)
        write (nttyo,1210) ux24a(1:j2),ux24b(1:j3)
 1210   format(/' * Warning - (EQPT/rdpar) The maximum temperature for',
     $  ' this data file',/7x,'is greater than the highest temperature',
     $  ' in the last temperature',/7x,'range. If EQ3NR and EQ6 are',
     $  ' required to make any calculations',/7x,'between ',a,'C',
     $  ' and ',a,'C, they will do so by extrapolating',/7x,'the',
     $  ' data from the last range.')
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Process and write the data for the standard pressure grid.
c
c     Calling sequence substitutions:
c       presg for avgrid
c
      call intrp(aamatr,apr,presg,cof,eps100,gmmatr,ipivot,
     $ narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $ xvec,yvec)
c
      ux24 = 'presg'
      j2 = ilnobl(ux24)
      write (ndata1) ux24
      write (ndat1f,1010) ux24(1:j2)
 1010 format(a)
      write (noutpt,1020) ux24(1:j2)
 1020 format(7x,a)
c
      do ntpr = 1,ntprt
        nt = narxt(ntpr)
        write (ndata1) (apr(i,ntpr), i = 1,nt)
        write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
 1030   format( 5(1pe16.9) )
      enddo
c
      write (ndat1f,1010) utermc(1:72)
c
      if (ipcv .ge. 0) then
c
c       Process and write the data for the half-width of the standard
c       pressure envelope.
c
c       Calling sequence substitutions:
c         prehw for avgrid
c
        call intrp(aamatr,apr,prehw,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'prehw'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
        write (noutpt,1020) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
        enddo
c
        write (ndat1f,1010) utermc(1:72)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Process and write the next parameters only if processing a
c     "SEDH" type data file.
c
      if (uakey(1:8) .eq. 'SEDH    ') then
c
c       Process and write the A(gamma,10) data.
c
c       Calling sequence substitutions:
c         adh for avgrid
c
        call intrp(aamatr,apr,adh,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'adh'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
        write (noutpt,1020) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
        enddo
c
        write (ndat1f,1010) utermc(1:72)
c
        if (ipch .ge. 0) then
c
c         Process and write the A(H) data.
c
c         Calling sequence substitutions:
c           adhh for avgrid
c
          call intrp(aamatr,apr,adhh,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'adhh'
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
          write (noutpt,1020) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
          enddo
c
          write (ndat1f,1010) utermc(1:72)
c
c         Process and write the dnA(H)/dPn data.
c
          do ipc = 1,ipch
c
            do ntpr = 1,ntprt
              do n = 1,narxt(ntpr)
                avgrid(n,ntpr) = dadhh(n,ntpr,ipc)
              enddo
            enddo
c
            call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $      narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $      xvec,yvec)
c
            ux24 = 'dadhh( )'
            write (ux24(7:7),'(i1)') ipc
            j2 = ilnobl(ux24)
            write (ndata1) ux24
            write (ndat1f,1010) ux24(1:j2)
            write (noutpt,1020) ux24(1:j2)
c
            do ntpr = 1,ntprt
              nt = narxt(ntpr)
              write (ndata1) (apr(i,ntpr), i = 1,nt)
              write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
            enddo
c
            write (ndat1f,1010) utermc(1:72)
          enddo
        endif
c
        if (ipcv .ge. 0) then
c
c         Process and write the A(V) data.
c
c         Calling sequence substitutions:
c           adhv for avgrid
c
          call intrp(aamatr,apr,adhv,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'adhv'
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
          write (noutpt,1020) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
          enddo
c
          write (ndat1f,1010) utermc(1:72)
c
c         Process and write the dnA(V)/dPn data.
c
          do ipc = 1,ipcv
c
            do ntpr = 1,ntprt
              do n = 1,narxt(ntpr)
                avgrid(n,ntpr) = dadhv(n,ntpr,ipc)
              enddo
            enddo
c
            call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $      narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $      xvec,yvec)
c
            ux24 = 'dadhv( )'
            write (ux24(7:7),'(i1)') ipc
            j2 = ilnobl(ux24)
            write (ndata1) ux24
            write (ndat1f,1010) ux24(1:j2)
            write (noutpt,1020) ux24(1:j2)
c
            do ntpr = 1,ntprt
              nt = narxt(ntpr)
              write (ndata1) (apr(i,ntpr), i = 1,nt)
              write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
            enddo
c
            write (ndat1f,1010) utermc(1:72)
          enddo
        endif
c
c       Process and write the B(gamma) data.
c
c       Calling sequence substitutions:
c         bdh for avgrid
c
        call intrp(aamatr,apr,bdh,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'bdh'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
        write (noutpt,1020) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
        enddo
c
        write (ndat1f,1010) utermc(1:72)
c
        if (ipch .ge. 0) then
c
c         Process and write the B(H) data.
c
c         Calling sequence substitutions:
c           bdhh for avgrid
c
          call intrp(aamatr,apr,bdhh,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'bdhh'
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
          write (noutpt,1020) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
          enddo
c
          write (ndat1f,1010) utermc(1:72)
c
c         Process and write the dnB(H)/dPn data.
c
          do ipc = 1,ipch
c
            do ntpr = 1,ntprt
              do n = 1,narxt(ntpr)
                avgrid(n,ntpr) = dbdhh(n,ntpr,ipc)
              enddo
            enddo
c
            call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $      narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $      xvec,yvec)
c
            ux24 = 'dbdhh( )'
            write (ux24(7:7),'(i1)') ipc
            j2 = ilnobl(ux24)
            write (ndata1) ux24
            write (ndat1f,1010) ux24(1:j2)
            write (noutpt,1020) ux24(1:j2)
c
            do ntpr = 1,ntprt
              nt = narxt(ntpr)
              write (ndata1) (apr(i,ntpr), i = 1,nt)
              write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
            enddo
c
            write (ndat1f,1010) utermc(1:72)
          enddo
        endif
c
        if (ipcv .ge. 0) then
c
c         Process and write the B(V) data.
c
c         Calling sequence substitutions:
c           bdhv for avgrid
c
          call intrp(aamatr,apr,bdhv,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'bdhv'
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
          write (noutpt,1020) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
          enddo
c
          write (ndat1f,1010) utermc(1:72)
c
c         Process and write the dnB(V)/dPn data.
c
          do ipc = 1,ipcv
c
            do ntpr = 1,ntprt
              do n = 1,narxt(ntpr)
                avgrid(n,ntpr) = dbdhv(n,ntpr,ipc)
              enddo
            enddo
c
            call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $      narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $      xvec,yvec)
c
            ux24 = 'dbdhv( )'
            write (ux24(7:7),'(i1)') ipc
            j2 = ilnobl(ux24)
            write (ndata1) ux24
            write (ndat1f,1010) ux24(1:j2)
            write (noutpt,1020) ux24(1:j2)
c
            do ntpr = 1,ntprt
              nt = narxt(ntpr)
              write (ndata1) (apr(i,ntpr), i = 1,nt)
              write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
            enddo
c
            write (ndat1f,1010) utermc(1:72)
          enddo
        endif
c
c       Process and write the B-dot data.
c       interpolate and write the polynomial coefficients for bdot
c
c       Calling sequence substitutions:
c         bdot for avgrid
c
        call intrp(aamatr,apr,bdot,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'bdot'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
        write (noutpt,1020) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
        enddo
c
        write (ndat1f,1010) utermc(1:72)
c
        if (ipch .ge. 0) then
c
c         Process and write the B-dot(H) data.
c
c         Calling sequence substitutions:
c           bdoth for avgrid
c
          call intrp(aamatr,apr,bdoth,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'bdoth'
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
          write (noutpt,1020) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
          enddo
c
          write (ndat1f,1010) utermc(1:72)
c
c         Process and write the dnB-dot(H)/dPn data.
c
          do ipc = 1,ipch
c
            do ntpr = 1,ntprt
              do n = 1,narxt(ntpr)
                avgrid(n,ntpr) = dbdth(n,ntpr,ipc)
              enddo
            enddo
c
            call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $      narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $      xvec,yvec)
c
            ux24 = 'dbdth( )'
            write (ux24(7:7),'(i1)') ipc
            j2 = ilnobl(ux24)
            write (ndata1) ux24
            write (ndat1f,1010) ux24(1:j2)
            write (noutpt,1020) ux24(1:j2)
c
            do ntpr = 1,ntprt
              nt = narxt(ntpr)
              write (ndata1) (apr(i,ntpr), i = 1,nt)
              write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
            enddo
c
            write (ndat1f,1010) utermc(1:72)
          enddo
        endif
c
        if (ipcv .ge. 0) then
c
c         Process and write the B-dot(V) data.
c
c         Calling sequence substitutions:
c           bdotv for avgrid
c
          call intrp(aamatr,apr,bdotv,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'bdotv'
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
          write (noutpt,1020) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
          enddo
c
          write (ndat1f,1010) utermc(1:72)
c
c         Process and write the dnB-dot(V)/dPn data.
c
          do ipc = 1,ipcv
c
            do ntpr = 1,ntprt
              do n = 1,narxt(ntpr)
                avgrid(n,ntpr) = dbdtv(n,ntpr,ipc)
              enddo
            enddo
c
            call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $      narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $      xvec,yvec)
c
            ux24 = 'dbdtv( )'
            write (ux24(7:7),'(i1)') ipc
            j2 = ilnobl(ux24)
            write (ndata1) ux24
            write (ndat1f,1010) ux24(1:j2)
            write (noutpt,1020) ux24(1:j2)
c
            do ntpr = 1,ntprt
              nt = narxt(ntpr)
              write (ndata1) (apr(i,ntpr), i = 1,nt)
              write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
            enddo
c
            write (ndat1f,1010) utermc(1:72)
          enddo
        endif
c
c       Write the CCO2 coefficients.
c
        ux24 = 'cco2'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
        write (noutpt,1020) ux24(1:j2)
c
        write (ndata1) (cco2(i), i = 1,5)
        write (ndat1f,1030) (cco2(i), i = 1,5)
        write (ndat1f,1010) utermc(1:72)
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Process and write the next parameter only if processing a
c     "Pitzer" type data file.
c
      if (uakey(1:8) .eq. 'Pitzer  ') then
c
c       Process and write the A(phi) data.
c
c       Calling sequence substitutions:
c         aphi for avgrid
c
        call intrp(aamatr,apr,aphi,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'aphi'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
        write (noutpt,1020) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
        enddo
c
        write (ndat1f,1010) utermc(1:72)
c
        if (ipch .ge. 0) then
c
c         Process and write the A(H) data.
c
c         Calling sequence substitutions:
c           adhh for avgrid
c
          call intrp(aamatr,apr,adhh,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'adhh'
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
          write (noutpt,1020) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
          enddo
c
          write (ndat1f,1010) utermc(1:72)
c
c         Process and write the dnA(H)/dPn data.
c
          do ipc = 1,ipch
c
            do ntpr = 1,ntprt
              do n = 1,narxt(ntpr)
                avgrid(n,ntpr) = dadhh(n,ntpr,ipc)
              enddo
            enddo
c
            call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $      narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $      xvec,yvec)
c
            ux24 = 'dadhh( )'
            write (ux24(7:7),'(i1)') ipc
            j2 = ilnobl(ux24)
            write (ndata1) ux24
            write (ndat1f,1010) ux24(1:j2)
            write (noutpt,1020) ux24(1:j2)
c
            do ntpr = 1,ntprt
              nt = narxt(ntpr)
              write (ndata1) (apr(i,ntpr), i = 1,nt)
              write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
            enddo
c
            write (ndat1f,1010) utermc(1:72)
          enddo
        endif
c
        if (ipcv .ge. 0) then
c
c         Process and write the A(V) data.
c
c         Calling sequence substitutions:
c           adhv for avgrid
c
          call intrp(aamatr,apr,adhv,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'adhv'
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
          write (noutpt,1020) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
          enddo
c
          write (ndat1f,1010) utermc(1:72)
c
c         Process and write the dnA(V)/dPn data.
c
          do ipc = 1,ipcv
c
            do ntpr = 1,ntprt
              do n = 1,narxt(ntpr)
                avgrid(n,ntpr) = dadhv(n,ntpr,ipc)
              enddo
            enddo
c
            call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $      narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $      xvec,yvec)
c
            ux24 = 'dadhv( )'
            write (ux24(7:7),'(i1)') ipc
            j2 = ilnobl(ux24)
            write (ndata1) ux24
            write (ndat1f,1010) ux24(1:j2)
            write (noutpt,1020) ux24(1:j2)
c
            do ntpr = 1,ntprt
              nt = narxt(ntpr)
              write (ndata1) (apr(i,ntpr), i = 1,nt)
              write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
            enddo
c
            write (ndat1f,1010) utermc(1:72)
          enddo
        endif
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Process and write the thermodynamic data for the "Eh" reaction.
c
c     Begin with the log K data.
c
c     Calling sequence substitutions:
c       xlke for avgrid
c
      call intrp(aamatr,apr,xlke,cof,eps100,gmmatr,ipivot,
     $ narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $ xvec,yvec)
c
      ux24 = 'xlke'
      j2 = ilnobl(ux24)
      write (ndata1) ux24
      write (ndat1f,1010) ux24(1:j2)
      write (noutpt,1020) ux24(1:j2)
c
      do ntpr = 1,ntprt
        nt = narxt(ntpr)
        write (ndata1) (apr(i,ntpr), i = 1,nt)
        write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
      enddo
c
      write (ndat1f,1010) utermc(1:72)
c
      if (ipch .ge. 0) then
c
c       Process and write the enthalpy of reaction data.
c
c       Calling sequence substitutions:
c         xhfe for avgrid
c
        call intrp(aamatr,apr,xhfe,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'xhfe'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
        write (noutpt,1020) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
        enddo
c
        write (ndat1f,1010) utermc(1:72)
c
c       Process and write the pressure derivatives of the enthalpy
c       of reaction.
c
        do ipc = 1,ipch
c
          do ntpr = 1,ntprt
            do n = 1,narxt(ntpr)
              avgrid(n,ntpr) = dhfe(n,ntpr,ipc)
            enddo
          enddo
c
          call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'dhfe( )'
          write (ux24(7:7),'(i1)') ipc
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
          write (noutpt,1020) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
          enddo
c
          write (ndat1f,1010) utermc(1:72)
        enddo
      endif
c
      if (ipcv .ge. 0) then
c
c       Process and write the volume of reaction data.
c
c       Calling sequence substitutions:
c         xvfe for avgrid
c
        call intrp(aamatr,apr,xvfe,cof,eps100,gmmatr,ipivot,
     $  narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $  xvec,yvec)
c
        ux24 = 'xvfe'
        j2 = ilnobl(ux24)
        write (ndata1) ux24
        write (ndat1f,1010) ux24(1:j2)
        write (noutpt,1020) ux24(1:j2)
c
        do ntpr = 1,ntprt
          nt = narxt(ntpr)
          write (ndata1) (apr(i,ntpr), i = 1,nt)
          write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
        enddo
c
        write (ndat1f,1010) utermc(1:72)
c
c       Process and write the pressure derivatives of the volume
c       of reaction.
c
        do ipc = 1,ipcv
c
          do ntpr = 1,ntprt
            do n = 1,narxt(ntpr)
              avgrid(n,ntpr) = dvfe(n,ntpr,ipc)
            enddo
          enddo
c
          call intrp(aamatr,apr,avgrid,cof,eps100,gmmatr,ipivot,
     $    narxmx,narxt,noutpt,ntprmx,ntprt,nttyo,tempc,tempcs,tmpcmx,
     $    xvec,yvec)
c
          ux24 = 'dvfe( )'
          write (ux24(7:7),'(i1)') ipc
          j2 = ilnobl(ux24)
          write (ndata1) ux24
          write (ndat1f,1010) ux24(1:j2)
          write (noutpt,1020) ux24(1:j2)
c
          do ntpr = 1,ntprt
            nt = narxt(ntpr)
            write (ndata1) (apr(i,ntpr), i = 1,nt)
            write (ndat1f,1030) (apr(i,ntpr), i = 1,nt)
          enddo
c
          write (ndat1f,1010) utermc(1:72)
        enddo
      endif
c
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
      subroutine wrpz23(alphca,alamaa,alamca,alamcc,alamna,alamnc,
     $ alamnn,alamn2,amuaac,amua2c,amucca,amuc2a,amunca,amun2n,
     $ amun3,ipbtmx,iaapr,icapr,iccpr,inapr,incpr,innpr,in2pr,
     $ iaactr,ia2ctr,iccatr,ic2atr,incatr,in2ntr,in3tr,jpdblo,
     $ jpfcmx,natmax,naapr,ncapr,nccpr,nnapr,nncpr,nnnpr,nn2pr,
     $ naactr,na2ctr,nccatr,nc2atr,nncatr,nn2ntr,nn3tr,ndata1,
     $ ndat1f,noutpt,nttyo,uaqsp,uethfl)
c
c     This subroutine writes the processed Pitzer parameters (in
c     conventional lambda and mu form) on the DATA1 and DATA1F files.
c
c     This subroutine is called by:
c
c       EQPT/eqpt.f
c
c-----------------------------------------------------------------------
c
c     Principal input:
c
c       alamaa  = array of coefficients for computing lamda parameters
c                   for aa' pairs
c       alamca  = array of coefficients for computing lamda parameters
c                   for ca pairs
c       alamcc  = array of coefficients for computing lamda parameters
c                   for cc' pairs
c       alamna  = array of coefficients for computing lamda parameters
c                   for na pairs
c       alamnc  = array of coefficients for computing lamda parameters
c                   for nc pairs
c       alamnn  = array of coefficients for computing lamda parameters
c                   for nn' pairs
c       alamn2  = array of coefficients for computing lamda parameters
c                   for nn pairs
c
c       amuaac  = array of coefficients for computing mu parameters
c                   for aa'c triplets
c       amua2c  = array of coefficients for computing mu parameters
c                   for aac triplets
c       amucca  = array of coefficients for computing mu parameters
c                   for cc'a triplets
c       amuc2a  = array of coefficients for computing mu parameters
c                   for cca triplets
c       amunca  = array of coefficients for computing mu parameters
c                   for nca triplets
c       amun2n  = array of coefficients for computing mu parameters
c                   for nnn' triplets
c       amun3   = array of coefficients for computing mu parameters
c                   for nnn triplets
c
c       iaapr   = species index array for aa' pairs
c       icapr   = species index array for ca pairs
c       iccpr   = species index array for cc' pairs
c       inapr   = species index array for na pairs
c       incpr   = species index array for nc pairs
c       innpr   = species index array for nn' pairs
c       in2pr   = species index array for nn pairs
c
c       iaactr  = species index array for aa'c triplets
c       ia2ctr  = species index array for aac triplets
c       iccatr  = species index array for cc'a triplets
c       ic2atr  = species index array for cca triplets
c       incatr  = species index array for nca triplets
c       in2ntr  = species index array for nn'n triplets
c
c       naapr   = number of aa' pairs
c       ncapr   = number of ca pairs
c       nccpr   = number of cc' pairs
c       nnapr   = number of na pairs
c       nncpr   = number of nc pairs
c       nnnpr   = number of nn' pairs
c       nn2pr   = number of nn pairs
c
c       naactr  = number of aa'c triplets
c       na2ctr  = number of aac triplets
c       nccatr  = number of cc'a triplets
c       nc2atr  = number of cca triplets
c       nncatr  = number of nca triplets
c       nn2ntr  = number of nn'n triplets
c
c       ndata1 = unit number of the DATA1 file
c       ndat1f = unit number of the DATA1F file
c
c       uethfl = E-theta flag string
c       upair  = array of names in species pairs
c       utripl = array of names in species triplets
c
c     Principal output:
c
c       none
c
c-----------------------------------------------------------------------
c
      implicit none
c
c-----------------------------------------------------------------------
c
c     Calling sequence variable declarations.
c
      integer ipbtmx,jpfcmx,natmax
c
      integer ndata1,ndat1f,noutpt,nttyo
c
      integer jpdblo
      integer naapr,ncapr,nccpr,nnapr,nncpr,nnnpr,nn2pr
      integer naactr,na2ctr,nccatr,nc2atr,nncatr,nn2ntr,nn3tr
c
      integer iaapr(2,naapr),icapr(2,ncapr),iccpr(2,nccpr),
     $ inapr(2,nnapr),incpr(2,nncpr),innpr(2,nnnpr),in2pr(nn2pr)
      integer iaactr(3,naactr),ia2ctr(2,na2ctr),iccatr(3,nccatr),
     $ ic2atr(2,nc2atr),incatr(3,nncatr),in2ntr(2,nn2ntr),in3tr(nn3tr)
c
      character*24 uaqsp(natmax)
      character*8 uethfl
c
      real*8 alphca(ipbtmx,ncapr)
c
      real*8 alamaa(jpfcmx,0:ipbtmx,naapr),
     $ alamca(jpfcmx,0:ipbtmx,ncapr),alamcc(jpfcmx,0:ipbtmx,nccpr),
     $ alamna(jpfcmx,0:ipbtmx,nnapr),alamnc(jpfcmx,0:ipbtmx,nncpr),
     $ alamnn(jpfcmx,0:ipbtmx,nnnpr),alamn2(jpfcmx,0:ipbtmx,nn2pr)
c
      real*8 amuaac(jpfcmx,naactr),amua2c(jpfcmx,na2ctr),
     $ amucca(jpfcmx,nccatr),amuc2a(jpfcmx,nc2atr),
     $ amunca(jpfcmx,nncatr),amun2n(jpfcmx,nn2ntr),amun3(jpfcmx,nn3tr)
c
c-----------------------------------------------------------------------
c
c     Local variable declarations.
c
      integer i,j,jpfc,j2,j3,j4,k,n
c
      integer ilnobl
c
      character(len=16) ux16
c
      logical qnzdat
c
      character*80 ustr
      character*24 ublk24,ustp24,uend24,unam1,unam2,unam3
      character*72 uterm,utermc
c
      real*8 zero
c
c-----------------------------------------------------------------------
c
      data uend24 / 'endit.                  '  /
      data ublk24 / '                        '  /
      data ustp24 / 'stop.                   '  /
      data zero   /    0.0    /
c
c-----------------------------------------------------------------------
c
      uterm(1:48) = '+-----------------------------------------------'
      uterm(49:72) = '------------------------'
      utermc = uterm
      utermc(1:1) = '*'
c
      j3 = ilnobl(uend24)
      j4 = ilnobl(ustp24)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (jpdblo .eq. -1) then
c
c       Old Pitzer data block organization.
c
c       Write the E-lambda flag.
c
        ustr = 'E-lambda flag = ' // uethfl
        write (ndata1) ustr
        j2 = ilnobl(ustr)
        write (ndat1f,1010) ustr(1:j2)
 1010   format('*',/a,/'*')
      else
c
c       New Pitzer data block organization.
c
c       Do not write the E-lambda flag. It is implicitly "on" in the
c       case of the new Pitzer data block organization.
c
        continue
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the lambda set for ca pairs.
c
      write (ndat1f,1100)
 1100 format("* Coefficients for lamda(ca) parameters")
      write (ndat1f,1110) utermc
 1110 format(a72)
c
      do n = 1,ncapr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do i = 0,ipbtmx
          do jpfc = 1,jpfcmx
            if (alamca(jpfc,i,n) .ne. 0.) then
              qnzdat = .true.
              go to 120
            endif
          enddo
        enddo
 120    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = icapr(1,n)
          j = icapr(2,n)
          unam1 = uaqsp(i)
          unam2 = uaqsp(j)
c
          write (ndata1) unam1,unam2
          j2 = ilnobl(unam2)
          write (ndat1f,1120) unam1,unam2(1:j2)
 1120     format(a24,2x,a)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) alamca(1,0,n),alamca(1,1,n),alamca(1,2,n)
            write (ndat1f,1130) alamca(1,0,n),alamca(1,1,n),
     $      alamca(1,2,n)
 1130       format(3x,'lambda0 = ',f9.5,3x,'lambda1 = ',f9.5,
     $      3x,'lambda2 = ',f9.5)
c
            write (ndata1) alphca(1,n),alphca(2,n)
            write (ndat1f,1140) alphca(1,n),alphca(2,n)
 1140       format(25x,'alpha1 = ',f5.1,7x,'alpha2 = ',f5.1)
c
            write (ndata1) alamca(2,0,n),alamca(3,0,n)
            write (ndat1f,1150) alamca(2,0,n),alamca(3,0,n)
 1150       format(4x,'dl0/dt = ',1pe10.3,2x,'d2l0/dt2 = ',1pe10.3)
c
            write (ndata1) alamca(2,1,n),alamca(3,1,n)
            write (ndat1f,1160) alamca(2,1,n),alamca(3,1,n)
 1160       format(4x,'dl1/dt = ',1pe10.3,2x,'d2l1/dt2 = ',1pe10.3)
c
            write (ndata1) alamca(2,2,n),alamca(3,2,n)
            write (ndat1f,1170) alamca(2,2,n),alamca(3,2,n)
 1170       format(4x,'dl2/dt = ',1pe10.3,2x,'d2l2/dt2 = ',1pe10.3)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'alpha( )'
            j2 = 8
            do i = 1,ipbtmx
              write (ux16(7:7),'(i1)') i
              write (ndata1) ux16,alphca(i,n)
              write (ndat1f,'(2x,a," = ",1pe12.5)')
     $        ux16(1:j2),alphca(i,n)
            enddo
c
            ux16 = 'lambda( )'
            j2 = 9
            do i = 0,ipbtmx
              write (ux16(8:8),'(i1)') i
              write (ndata1) ux16
              write (ndat1f,'(2x,a,":")') ux16(1:j2)
              do j = 1,jpfcmx
                write (ndata1) alamca(j,i,n)
                write (ndat1f,'(4x,"a",i1," = ",1pe15.8)')
     $          j,alamca(j,i,n)
              enddo
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
 1180     format(a72)
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the lambda set for nn pairs.
c
      write (ndat1f,1200)
 1200 format("* Coefficients for lamda(nn) parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,nn2pr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do i = 0,ipbtmx
          do jpfc = 1,jpfcmx
            if (alamn2(jpfc,i,n) .ne. 0.) then
              qnzdat = .true.
              go to 130
            endif
          enddo
        enddo
 130    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = in2pr(n)
          unam1 = uaqsp(i)
          unam2 = unam1
c
          write (ndata1) unam1,unam2
          j2 = ilnobl(unam2)
          write (ndat1f,1120) unam1,unam2(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) alamn2(1,0,n),alamn2(1,1,n),alamn2(1,2,n)
            write (ndat1f,1130) alamn2(1,0,n),alamn2(1,1,n),
     $      alamn2(1,2,n)
c
c           No alpha parameters for this kind of pair.
c
            write (ndata1) zero,zero
            write (ndat1f,1140) zero, zero
c
            write (ndata1) alamn2(2,0,n),alamn2(3,0,n)
            write (ndat1f,1150) alamn2(2,0,n),alamn2(3,0,n)
c
            write (ndata1) alamn2(2,1,n),alamn2(3,1,n)
            write (ndat1f,1160) alamn2(2,1,n),alamn2(3,1,n)
c
            write (ndata1) alamn2(2,2,n),alamn2(3,2,n)
            write (ndat1f,1170) alamn2(2,2,n),alamn2(3,2,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'lambda(0)'
            j2 = 9
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) alamn2(j,0,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,alamn2(j,0,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the lambda set for nc pairs.
c
      write (ndat1f,1210)
 1210 format("* Coefficients for lamda(nc) parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,nncpr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do i = 0,ipbtmx
          do jpfc = 1,jpfcmx
            if (alamnc(jpfc,i,n) .ne. 0.) then
              qnzdat = .true.
              go to 140
            endif
          enddo
        enddo
 140    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = incpr(1,n)
          j = incpr(2,n)
          unam1 = uaqsp(i)
          unam2 = uaqsp(j)
c
          write (ndata1) unam1,unam2
          j2 = ilnobl(unam2)
          write (ndat1f,1120) unam1,unam2(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) alamnc(1,0,n),alamnc(1,1,n),alamnc(1,2,n)
            write (ndat1f,1130) alamnc(1,0,n),alamnc(1,1,n),
     $      alamnc(1,2,n)
c
c           No alpha parameters for this kind of pair.
c
            write (ndata1) zero,zero
            write (ndat1f,1140) zero, zero
c
            write (ndata1) alamnc(2,0,n),alamnc(3,0,n)
            write (ndat1f,1150) alamnc(2,0,n),alamnc(3,0,n)
c
            write (ndata1) alamnc(2,1,n),alamnc(3,1,n)
            write (ndat1f,1160) alamnc(2,1,n),alamnc(3,1,n)
c
            write (ndata1) alamnc(2,2,n),alamnc(3,2,n)
            write (ndat1f,1170) alamnc(2,2,n),alamnc(3,2,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'lambda(0)'
            j2 = 9
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) alamnc(j,0,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,alamnc(j,0,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the lambda set for na pairs.
c
      write (ndat1f,1220)
 1220 format("* Coefficients for lamda(na) parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,nnapr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do i = 0,ipbtmx
          do jpfc = 1,jpfcmx
            if (alamna(jpfc,i,n) .ne. 0.) then
              qnzdat = .true.
              go to 150
            endif
          enddo
        enddo
 150    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = inapr(1,n)
          j = inapr(2,n)
          unam1 = uaqsp(i)
          unam2 = uaqsp(j)
c
          write (ndata1) unam1,unam2
          j2 = ilnobl(unam2)
          write (ndat1f,1120) unam1,unam2(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) alamna(1,0,n),alamna(1,1,n),alamna(1,2,n)
            write (ndat1f,1130) alamna(1,0,n),alamna(1,1,n),
     $      alamna(1,2,n)
c
c           No alpha parameters for this kind of pair.
c
            write (ndata1) zero,zero
            write (ndat1f,1140) zero, zero
c
            write (ndata1) alamna(2,0,n),alamna(3,0,n)
            write (ndat1f,1150) alamna(2,0,n),alamna(3,0,n)
c
            write (ndata1) alamna(2,1,n),alamna(3,1,n)
            write (ndat1f,1160) alamna(2,1,n),alamna(3,1,n)
c
            write (ndata1) alamna(2,2,n),alamna(3,2,n)
            write (ndat1f,1170) alamna(2,2,n),alamna(3,2,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'lambda(0)'
            j2 = 9
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) alamna(j,0,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,alamna(j,0,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the lambda set for nn' pairs.
c
      write (ndat1f,1230)
 1230 format("* Coefficients for lamda(nn') parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,nnnpr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do i = 0,ipbtmx
          do jpfc = 1,jpfcmx
            if (alamnn(jpfc,i,n) .ne. 0.) then
              qnzdat = .true.
              go to 160
            endif
          enddo
        enddo
 160    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = innpr(1,n)
          j = innpr(2,n)
          unam1 = uaqsp(i)
          unam2 = uaqsp(j)
c
          write (ndata1) unam1,unam2
          j2 = ilnobl(unam2)
          write (ndat1f,1120) unam1,unam2(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) alamnn(1,0,n),alamnn(1,1,n),alamnn(1,2,n)
            write (ndat1f,1130) alamnn(1,0,n),alamnn(1,1,n),
     $      alamnn(1,2,n)
c
c           No alpha parameters for this kind of pair.
c
            write (ndata1) zero,zero
            write (ndat1f,1140) zero, zero
c
            write (ndata1) alamnn(2,0,n),alamnn(3,0,n)
            write (ndat1f,1150) alamnn(2,0,n),alamnn(3,0,n)
c
            write (ndata1) alamnn(2,1,n),alamnn(3,1,n)
            write (ndat1f,1160) alamnn(2,1,n),alamnn(3,1,n)
c
            write (ndata1) alamnn(2,2,n),alamnn(3,2,n)
            write (ndat1f,1170) alamnn(2,2,n),alamnn(3,2,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'lambda(0)'
            j2 = 9
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) alamnn(j,0,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,alamnn(j,0,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      write (ndata1) uend24,ublk24,ublk24
      write (ndat1f,1270) uend24(1:j3)
 1270 format(a)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the lambda set for cc' pairs.
c
      write (ndat1f,1320)
 1320 format("* Coefficients for lamda(cc') parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,nccpr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do i = 0,ipbtmx
          do jpfc = 1,jpfcmx
            if (alamcc(jpfc,i,n) .ne. 0.) then
              qnzdat = .true.
              go to 170
            endif
          enddo
        enddo
 170    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = iccpr(1,n)
          j = iccpr(2,n)
          unam1 = uaqsp(i)
          unam2 = uaqsp(j)
c
          write (ndata1) unam1,unam2
          j2 = ilnobl(unam2)
          write (ndat1f,1120) unam1,unam2(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) alamcc(1,0,n),alamcc(1,1,n),alamcc(1,2,n)
            write (ndat1f,1130) alamcc(1,0,n),alamcc(1,1,n),
     $      alamcc(1,2,n)
c
c           No alpha parameters for this kind of pair.
c
            write (ndata1) zero,zero
            write (ndat1f,1140) zero, zero
c
            write (ndata1) alamcc(2,0,n),alamcc(3,0,n)
            write (ndat1f,1150) alamcc(2,0,n),alamcc(3,0,n)
c
            write (ndata1) alamcc(2,1,n),alamcc(3,1,n)
            write (ndat1f,1160) alamcc(2,1,n),alamcc(3,1,n)
c
            write (ndata1) alamcc(2,2,n),alamcc(3,2,n)
            write (ndat1f,1170) alamcc(2,2,n),alamcc(3,2,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'lambda(0)'
            j2 = 9
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) alamcc(j,0,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,alamcc(j,0,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the lambda set for aa' pairs.
c
      write (ndat1f,1330)
 1330 format("* Coefficients for lamda(aa') parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,naapr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do i = 0,ipbtmx
          do jpfc = 1,jpfcmx
            if (alamaa(jpfc,i,n) .ne. 0.) then
              qnzdat = .true.
              go to 180
            endif
          enddo
        enddo
 180    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = iaapr(1,n)
          j = iaapr(2,n)
          unam1 = uaqsp(i)
          unam2 = uaqsp(j)
c
          write (ndata1) unam1,unam2
          j2 = ilnobl(unam2)
          write (ndat1f,1120) unam1,unam2(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) alamaa(1,0,n),alamaa(1,1,n),alamaa(1,2,n)
            write (ndat1f,1130) alamaa(1,0,n),alamaa(1,1,n),
     $      alamaa(1,2,n)
c
c           No alpha parameters for this kind of pair.
c
            write (ndata1) zero,zero
            write (ndat1f,1140) zero, zero
c
            write (ndata1) alamaa(2,0,n),alamaa(3,0,n)
            write (ndat1f,1150) alamaa(2,0,n),alamaa(3,0,n)
c
            write (ndata1) alamaa(2,1,n),alamaa(3,1,n)
            write (ndat1f,1160) alamaa(2,1,n),alamaa(3,1,n)
c
            write (ndata1) alamaa(2,2,n),alamaa(3,2,n)
            write (ndat1f,1170) alamaa(2,2,n),alamaa(3,2,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'lambda(0)'
            j2 = 9
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) alamaa(j,0,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,alamaa(j,0,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      write (ndata1) uend24,ublk24,ublk24
      write (ndat1f,1270) uend24(1:j3)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the mu set for cca triplets.
c
      write (ndat1f,1340)
 1340 format("* Coefficients for mu(cca) parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,nc2atr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do jpfc = 1,jpfcmx
          if (amuc2a(jpfc,n) .ne. 0.) then
            qnzdat = .true.
            go to 220
          endif
        enddo
 220    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = ic2atr(1,n)
          k = ic2atr(2,n)
          unam1 = uaqsp(i)
          unam2 = unam1
          unam3 = uaqsp(k)
c
          write (ndata1) unam1,unam2,unam3
          j2 = ilnobl(unam3)
          write (ndat1f,1370) unam1,unam2,unam3(1:j2)
 1370     format(a24,2x,a24,2x,a)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) amuc2a(1,n),amuc2a(2,n),amuc2a(3,n)
            write (ndat1f,1380) amuc2a(1,n),amuc2a(2,n),amuc2a(3,n)
 1380       format(5x,'mummx = ',f9.5,2x,'dmummx/dt = ',1pe10.3,
     $      2x,'d2mummx/dt2 = ',1pe10.3)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'mu'
            j2 = 2
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) amuc2a(j,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,amuc2a(j,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the mu set for aac triplets.
c
      write (ndat1f,1430)
 1430 format("* Coefficients for mu(aac) parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,na2ctr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do jpfc = 1,jpfcmx
          if (amua2c(jpfc,n) .ne. 0.) then
            qnzdat = .true.
            go to 230
          endif
        enddo
 230    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = ia2ctr(1,n)
          k = ia2ctr(2,n)
          unam1 = uaqsp(i)
          unam2 = unam1
          unam3 = uaqsp(k)
c
          write (ndata1) unam1,unam2,unam3
          j2 = ilnobl(unam3)
          write (ndat1f,1370) unam1,unam2,unam3(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) amua2c(1,n),amua2c(2,n),amua2c(3,n)
            write (ndat1f,1380) amua2c(1,n),amua2c(2,n),amua2c(3,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'mu'
            j2 = 2
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) amua2c(j,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,amua2c(j,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
       endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      write (ndata1) uend24,ublk24,ublk24
      write (ndat1f,1270) uend24(1:j3)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the mu set for cc'a triplets.
c
      write (ndat1f,1470)
 1470 format("* Coefficients for mu(cc'a) parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,nccatr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do jpfc = 1,jpfcmx
          if (amucca(jpfc,n) .ne. 0.) then
            qnzdat = .true.
            go to 240
          endif
        enddo
 240    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = iccatr(1,n)
          j = iccatr(2,n)
          k = iccatr(3,n)
          unam1 = uaqsp(i)
          unam2 = uaqsp(j)
          unam3 = uaqsp(k)
c
          write (ndata1) unam1,unam2,unam3
          j2 = ilnobl(unam3)
          write (ndat1f,1370) unam1,unam2,unam3(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) amucca(1,n),amucca(2,n),amucca(3,n)
            write (ndat1f,1380) amucca(1,n),amucca(2,n),amucca(3,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'mu'
            j2 = 2
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) amucca(j,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,amucca(j,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the mu set for aa'c triplets.
c
      write (ndat1f,1490)
 1490 format("* Coefficients for mu(aa'c) parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,naactr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do jpfc = 1,jpfcmx
          if (amuaac(jpfc,n) .ne. 0.) then
            qnzdat = .true.
            go to 260
          endif
        enddo
 260    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = iaactr(1,n)
          j = iaactr(2,n)
          k = iaactr(3,n)
          unam1 = uaqsp(i)
          unam2 = uaqsp(j)
          unam3 = uaqsp(k)
c
          write (ndata1) unam1,unam2,unam3
          j2 = ilnobl(unam3)
          write (ndat1f,1370) unam1,unam2,unam3(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) amuaac(1,n),amuaac(2,n),amuaac(3,n)
            write (ndat1f,1380) amuaac(1,n),amuaac(2,n),amuaac(3,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'mu'
            j2 = 2
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) amuaac(j,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,amuaac(j,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the mu set for nnn triplets.
c
      write (ndat1f,1510)
 1510 format("* Coefficients for mu(nnn) parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,nn3tr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do jpfc = 1,jpfcmx
          if (amun3(jpfc,n) .ne. 0.) then
            qnzdat = .true.
            go to 270
          endif
        enddo
 270    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = in3tr(n)
          unam1 = uaqsp(i)
          unam2 = unam1
          unam3 = unam1
c
          write (ndata1) unam1,unam2,unam3
          j2 = ilnobl(unam3)
          write (ndat1f,1370) unam1,unam2,unam3(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) amun3(1,n),amun3(2,n),amun3(3,n)
            write (ndat1f,1380) amun3(1,n),amun3(2,n),amun3(3,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'mu'
            j2 = 2
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) amun3(j,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,amun3(j,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the mu set for nnn' triplets.
c
      write (ndat1f,1520)
 1520 format("* Coefficients for mu(nnn') parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,nn2ntr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do jpfc = 1,jpfcmx
          if (amun2n(jpfc,n) .ne. 0.) then
            qnzdat = .true.
            go to 280
          endif
        enddo
 280    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = in2ntr(1,n)
          k = in2ntr(2,n)
          unam1 = uaqsp(i)
          unam2 = unam1
          unam3 = uaqsp(k)
c
          write (ndata1) unam1,unam2,unam3
          j2 = ilnobl(unam3)
          write (ndat1f,1370) unam1,unam2,unam3(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) amun2n(1,n),amun2n(2,n),amun2n(3,n)
            write (ndat1f,1380) amun2n(1,n),amun2n(2,n),amun2n(3,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'mu'
            j2 = 2
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) amun2n(j,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,amun2n(j,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Write the mu set for nca triplets.
c
      write (ndat1f,1530)
 1530 format("* Coefficients for mu(nca) parameters")
      write (ndat1f,1110) utermc
c
      do n = 1,nncatr
c
c       Are there any non-zero data?
c
        qnzdat = .false.
        do jpfc = 1,jpfcmx
          if (amunca(jpfc,n) .ne. 0.) then
            qnzdat = .true.
            go to 290
          endif
        enddo
 290    continue
c
        if (qnzdat) then
c
c         Write a block.
c
          i = incatr(1,n)
          j = incatr(2,n)
          k = incatr(3,n)
          unam1 = uaqsp(i)
          unam2 = uaqsp(j)
          unam3 = uaqsp(k)
c
          write (ndata1) unam1,unam2,unam3
          j2 = ilnobl(unam3)
          write (ndat1f,1370) unam1,unam2,unam3(1:j2)
c
          if (jpdblo .eq. -1) then
c
c           Old Pitzer data block organization.
c
            write (ndata1) amunca(1,n),amunca(2,n),amunca(3,n)
            write (ndat1f,1380) amunca(1,n),amunca(2,n),amunca(3,n)
          else
c
c           New Pitzer data block organization.
c
            ux16 = 'mu'
            j2 = 2
            write (ndata1) ux16
            write (ndat1f,'(2x,a,":")') ux16(1:j2)
            do j = 1,jpfcmx
              write (ndata1) amunca(j,n)
              write (ndat1f,'(4x,"a",i1," = ",1pe15.8)') j,amunca(j,n)
            enddo
          endif
c
c         Write the block terminator.
c
          write (ndata1) uterm
          write (ndat1f,1180) uterm
        endif
      enddo
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      write (ndata1) uend24,ublk24,ublk24
      write (ndat1f,1270) uend24(1:j3)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      write (ndata1) ustp24,ublk24,ublk24
      write (ndat1f,1270) ustp24(1:j4)
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      end
